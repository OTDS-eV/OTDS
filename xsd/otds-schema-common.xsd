<!-- Mit XMLSpy v2011 rel. 3 (x64) (http://www.altova.com) von Sebastian Oremek (TravelTainment GmbH) bearbeitet -->
<!-- edited with XMLSpy v2011 rel. 3 (x64) (http://www.altova.com) by Sebastian Oremek (TravelTainment GmbH) -->
<!-- Test -->
<xs:schema xmlns="http://otds-group.org/otds" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xml="http://www.w3.org/XML/1998/namespace" xmlns:internal="http://otds-group.org/otds/internal" targetNamespace="http://otds-group.org/otds" elementFormDefault="qualified">
	<!-- Import xml: namespace -->
	<xs:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="http://www.w3.org/2001/xml.xsd"/>
	<xs:include schemaLocation="otds-schema-property-nbc.xsd"/>
	<xs:simpleType name="SourceAttributeType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_3298">
		Die Source Angabe folgt folgender Syntax
		
			source = ( Eigenschaft1+Eigenschaft2+... ":" ) ? steps
		
			Eigenschaft1 = "local" | "global"
			
			Eigenschaft2 ="real" | "virtual" | "ComponentType.all"
			
			Eigenschaft3 ="self" | "ancestors" | "descendants" | "Hierarchy.all"

			Eigenschaft4 = "first" | "last" | "DayAllocation.all"

			Falls Eigenschaften angegeben werden muss zwingend die oben angegebene Reihenfolge der Eigenschaften eingehalten werden.
		
			steps = oneOrMoreNameSteps | zeroOrMoreNameSteps | componentSteps
		
			oneOrMoreNameSteps = nameStep ( "." nameStep ) *
		
			zeroOrMoreNameSteps = ( nameStep "." ) *
		
			nameStep = "#" name
		
			name ist eine Folge von Zeichen aus der Menge "A"-"Z", "a"-"z", "0"-"9", "-" und "_". Keine Umlaute. Mindestens ein Zeichen
		
			componentSteps ist eine Liste gültiger Werte, siehe im folgenden
				
		Gültige 'componentSteps' sind zunächst:
		
			- Products.GlobalValue
			- Products.Product
			- Products.Product.Brands
			- Products.Product.Brands.Brand
			- Products.Product.Accommodations
			- Products.Product.Accommodations.Accommodation
			- Products.Product.Accommodations.Accommodation.SellingAccom
			- Products.Product.Accommodations.Accommodation.SellingAccom.Board
			- Products.Product.Accommodations.Accommodation.SellingAccom.Unit
			- Products.Product.Accommodations.Accommodation.SellingAccom.Unit.SellingUnit
			- Products.Product.Accommodations.AccommodationWrapper
			- Products.Product.Flights
			- Products.Product.Flights.OnewayFlight
			- Products.Product.Flights.OnewayFlight.BookingClass
			- Products.Product.Flights.ReturnFlight
			- Products.Product.Flights.ReturnFlight.BookingClass
			- Products.Product.Flights.ReturnFlight.Inbound
			- Products.Product.Flights.ReturnFlight.Outbound
			- Products.Product.Flights.FlightWrapper
			- Products.Product.Addons
			- Products.Product.Addons.Addon
			- Products.Product.Addons.Addon.Service
			- Products.Product.Addons.Addon.ServiceFeature
			- Products.Product.Addons.AddonWrapper				
		
		Desweiteren sind alle Unterschrittfolgen aus obigen Pfaden erlaubt, also 'Board', 'Accommodation.SellingAccom' oder 'SellingAccom.Unit.SellingUnit'. 
		'Accommodation.Unit' hingegen ist nicht erlaubt, da in diesem Fall einige Zwischenschritte fehlen.
		
				</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_3298">
				The Source specification obeys the following syntax
				
				source = ( Feature1+Feature2+... ":" ) ? steps
				
				Feature1 = "local" | "global"
				
				Feature2 ="real" | "virtual" | "ComponentType.all"
				
				Feature3 ="self" | "ancestors" | "descendants" | "Hierarchy.all"
				
				Feature4 = "first" | "last" | "DayAllocation.all"
				
				If features are specified, the order of features as given above has strictly to be followed.
				
				steps = oneOrMoreNameSteps | zeroOrMoreNameSteps | componentSteps
				
				oneOrMoreNameSteps = nameStep ( "." nameStep ) *
				
				zeroOrMoreNameSteps = ( nameStep "." ) *
				
				nameStep = "#" name
				
				name is a string of characters from "A"-"Z", "a"-"z", "0"-"9", "-" and "_". No umlauts allowed, one character is minimum.
				
				componentSteps is a list of valid values, see below.
				
				Valid 'componentSteps' are:
				
			- Products.GlobalValue
			- Products.Product
			- Products.Product.Brands
			- Products.Product.Brands.Brand
			- Products.Product.Accommodations
			- Products.Product.Accommodations.Accommodation
			- Products.Product.Accommodations.Accommodation.SellingAccom
			- Products.Product.Accommodations.Accommodation.SellingAccom.Board
			- Products.Product.Accommodations.Accommodation.SellingAccom.Unit
			- Products.Product.Accommodations.Accommodation.SellingAccom.Unit.SellingUnit
			- Products.Product.Accommodations.AccommodationWrapper
			- Products.Product.Flights
			- Products.Product.Flights.OnewayFlight
			- Products.Product.Flights.OnewayFlight.BookingClass
			- Products.Product.Flights.ReturnFlight
			- Products.Product.Flights.ReturnFlight.BookingClass
			- Products.Product.Flights.ReturnFlight.Inbound
			- Products.Product.Flights.ReturnFlight.Outbound
			- Products.Product.Flights.FlightWrapper
			- Products.Product.Addons
			- Products.Product.Addons.Addon
			- Products.Product.Addons.Addon.Service
			- Products.Product.Addons.Addon.ServiceFeature
			- Products.Product.Addons.AddonWrapper		
				
				In addition to that all subsequent steps from the paths above are permitted, that is 'Board', 'Accommodation.SellingAccom' or 'SellingAccom.Unit.SellingUnit'. 
				'Accommodation.Unit' in the contrary is not permitted, as here some intermediate steps are missing.
				
			</xs:documentation>
		</xs:annotation>
		<xs:union>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:pattern value="((((Scope\.)?(global|local|current))|(((ComponentType.)?(real|virtual))|ComponentType\.all)|(((Hierarchy\.)?(self|ancestors|descendants))|Hierarchy\.all)|(((DayAllocation\.)?(first|last))|DayAllocation\.all))(\+(((Scope\.)?(global|local|current))|(((ComponentType.)?(real|virtual))|ComponentType\.all)|(((Hierarchy\.)?(self|ancestors|descendants))|Hierarchy\.all)|(((DayAllocation\.)?(first|last))|DayAllocation\.all)))*:)?(#[A-Za-z0-9\-_]+(\.(#[A-Za-z0-9\-_]+))*|(#[A-Za-z0-9\-_]+\.)*(ThisComponent|Products|Products\.GlobalValue|Products\.Product|Products\.Product\.Brands|Products\.Product\.Brands\.Brand|Products\.Product\.Accommodations|Products\.Product\.Accommodations\.Accommodation|Products\.Product\.Accommodations\.Accommodation\.SellingAccom|Products\.Product\.Accommodations\.Accommodation\.SellingAccom\.Board|Products\.Product\.Accommodations\.Accommodation\.SellingAccom\.Unit|Products\.Product\.Accommodations\.Accommodation\.SellingAccom\.Unit\.SellingUnit|Products\.Product\.Accommodations\.AccommodationWrapper|Products\.Product\.Flights|Products\.Product\.Flights\.OnewayFlight|Products\.Product\.Flights\.OnewayFlight\.BookingClass|Products\.Product\.Flights\.ReturnFlight|Products\.Product\.Flights\.ReturnFlight\.BookingClass|Products\.Product\.Flights\.ReturnFlight\.Inbound|Products\.Product\.Flights\.ReturnFlight\.Outbound|Products\.Product\.Flights\.FlightWrapper|Products\.Product\.Addons\.Addon|Products\.Product\.Addons\.Addon\.Service|Products\.Product\.Addons\.Addon\.ServiceFeature|GlobalValue|Product|Product\.Brands|Product\.Brands\.Brand|Product\.Accommodations|Product\.Accommodations\.Accommodation|Product\.Accommodations\.Accommodation\.SellingAccom|Product\.Accommodations\.Accommodation\.SellingAccom\.Board|Product\.Accommodations\.Accommodation\.SellingAccom\.Unit|Product\.Accommodations\.Accommodation\.SellingAccom\.Unit\.SellingUnit|Product\.Accommodations\.AccommodationWrapper|Product\.Flights|Product\.Flights\.OnewayFlight|Product\.Flights\.OnewayFlight\.BookingClass|Product\.Flights\.ReturnFlight|Product\.Flights\.ReturnFlight\.BookingClass|Product\.Flights\.ReturnFlight\.Inbound|Product\.Flights\.ReturnFlight\.Outbound|Product\.Flights\.FlightWrapper|Product\.Addons|Product\.Addons\.Addon|Product\.Addons\.Addon\.Service|Product\.Addons\.Addon\.ServiceFeature|Product\.Addons\.AddonWrapper|Brands|Brands\.Brand|Brand|Accommodations|Accommodations\.Accommodation|Accommodations\.Accommodation\.SellingAccom|Accommodations\.Accommodation\.SellingAccom\.Board|Accommodations\.Accommodation\.SellingAccom\.Unit|Accommodations\.Accommodation\.SellingAccom\.Unit\.SellingUnit|Accommodations\.AccommodationWrapper|AccommodationWrapper|Accommodation|Accommodation\.SellingAccom|Accommodation\.SellingAccom\.Board|Accommodation\.SellingAccom\.Unit|Accommodation\.SellingAccom\.Unit\.SellingUnit|Flights|Flights\.OnewayFlight|Flights\.OnewayFlight\.BookingClass|Flights\.ReturnFlight|Flights\.ReturnFlight\.BookingClass|Flights\.ReturnFlight\.Inbound|Flights\.ReturnFlight\.Outbound|Flights\.FlightWrapper|FlightWrapper|OnewayFlight|OnewayFlight\.BookingClass|ReturnFlight|ReturnFlight\.BookingClass|ReturnFlight\.Inbound|ReturnFlight\.Outbound|Addons|Addons\.Addon\.Service|Addons\.Addon\.ServiceFeature|Addons\.AddonWrapper|AddonWrapper|Addon|Addon\.Service|Addon\.ServiceFeature|SellingAccom|SellingAccom\.Board|SellingAccom\.Unit|SellingAccom\.Unit\.SellingUnit|BookingClass|Inbound|Outbound|Service|ServiceFeature|Board|Unit|Unit\.SellingUnit|SellingUnit))"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:attributeGroup name="ProductComponentGroup">
		<xs:attribute name="Name" type="NameType">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_54">Dieses Element definiert einen Namen, der innerhalb der ProductRules von den Filtern innerhalb des Attributes "Source" als Referenz benutzt werden kann. Falls die CombiComponent innerhalb eines Pauschalproduktes als "ReturnFlight" verwendet wird, dann ist es unbedingt notwendig, dass als Name "ReturnFlight" angegeben wird. Andernfalls können sich Conditions aus den Komponenten "Accommodation" oder "Addon" nicht auf den durch die CombiComponente definierten ReturnFlight beziehen. Ist "Name" nicht besetzt, so werden folgende Defaultwerte in Abhängigkeit des Komponenten-Kontexts vereinbart: 
- Befinden wir uns im Kontext einer Accommodation-Komponente so ist der Default="Accommodation" 
- Im Kontext einer ReturnFlight-Komponente ist der Default="ReturnFlight" 
- Im Kontext einer OnewayFlight-Komponente ist der Default="OnewayFlight" - Im Kontext einer Addon-Komponente ist der Default="Addon" 
- Im Kontext einer CombiComponente ist der Default="CombiComponent" </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_54">This element defines a name that can be used as a reference within the ProductRules of the filters within the "Source" attribute. If the CombiComponent is used as a "ReturnFlight" within a package deal, then it is imperative that the name "Return Flight" is specified. Otherwise the conditions from the "Accommodation" or "Addon" components will not correspond with the ReturnFlight value defined by the CombiComponent.
If the "Name" is unspecified, the following default values will be used depending on the component context: 
- In the context of an accommodation component, the default = "Accommodation"
- In the context of a return flight component, the default = "ReturnFlight"
- In the context of a one way flight component, the default = "OnewayFlight"
- In the context of an add-on component, the default = "Addon"
- In the context of a combined component, the default = "CombiComponent"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="ProductComponentBaseGroup"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="ProductComponentBaseGroup">
		<xs:attribute name="DayAllocationIndex" type="xs:int">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_55">Dieses Attribut bestimmt die Platzierung der Komponente im Reiseverlauf. Es werden der Komponente also bestimmte Tage der Reise zugewiesen. Das Attribut ist in der Regel nicht besetzt. Es werden folgende Defaultwerte in Abhängigkeit des Komponenten-Kontexts vereinbart: 
- Befinden wir uns im Kontext einer Accommodation-Komponente so ist der Default="0" 
- Für die reine ReturnFlight-Komponente ist die Verwendung von DayAllocationIndex nicht erlaubt, sondern wird separat in Inbound und Outbound gesetzt 
- Im Kontext einer OutboundComponente ist der Default="-2" 
- Im Kontext einer InboundComponente ist der Default="2" 
- Im Kontext einer Addon-Komponente ist der Default="0" 
- Im Kontext einer Combi-Komponente ist der Default="0" 
- Im Kontext einer Outbound-Combi-Komponente ist der Default="-2" 
- Im Kontext einer Inbound-Combi-Komponente ist der Default="2" </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_55">This attribute specifies the positioning of the itinerary's components. Specific days of travel are assigned to the components. This attribute is not usually specified. The following default values ​​are used depending on the component context:
- In the context of an accommodation component, the default = "0"
- For the ReturnFlight component, the use of the DayAllocationIndex is not allowed, but is set separately with regard to inbound and outbound flights
- In the context of an outbound component, the default = "-2"
- In the context of an inbound component, the default = "2"
- In the context of an add-on component, the default = "0"
- In the context of a combination component, the default = "0"
- In the context of an outbound combined component, the default = "-2"
- In the context of an inbound combined component, the default = "2"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DayAllocationLevel" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_56">Dieses Attribut definiert, welches DayAllocationLevel für diese Komponente benutzt wird. Innerhalb der ProductDefinition muss es für jedes DayAllocationLevel ein DayAllocationStart und ein DayAllocationEnd geben. Ist dieses nicht explizit angegeben, so werden Start und End jeweils mit Defaultwerten und entsprechendem DayAllocationLevel zugrunde gelegt. Der Default ist 0. </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_56">This attribute defines which DayAllocationLevel should be used for these components. Within the ProductDefinition there must be a DayAllocationStart and a DayAllocationEnd for each DayAllocationLevel. If these are not explicitly given, the Start and End will be determined as default values for the corresponding DayAllocationLevel.
The default is 0.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="ConditionsCombinatoricsAttributGroup">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_57">Attributsgruppe zur Steuerung der Reihenfolge der Conditions im Zusammenhang mit der Auswertung Combinatorics</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_57">Attribute group to control the order of Conditions in relation to the Combinatorics analysis</xs:documentation>
		</xs:annotation>
		<xs:attribute name="ImpactExecutionOrder" type="ExecutionOrderEnum" use="optional" default="BeforeCombinatorics">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_58">Dieses Attribut definiert, ob eine Bedingung in die Combinatorics-Auswertung einbezogen wird oder nicht. Beispiel: Bei der Dauerreduktion gibt es komplette Ausschlüsse von Rabatten und auch nur Prozente auf die bezahlten Nächte. Im Falle der bezahlten Nächte enthält dieses Attribut "BeforeCombinatorics". Im Falle der kompletten Nicht-Vereinbarkeit ist es ein "AfterCombinatorics". </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_58">This attribute defines whether or not a condition is included in the Combinatorics analysis. Example: For long-term reductions, there can be complete rejection of any exclusions of discounts and also only percentages of the nights paid for. In the case of the nights paid the attribute receives a "BeforeCombinatorics". In the case of the complete incompatibility of discounts, it gets an "AfterCombinatorics".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="ApplyAttributeGroup">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_1446">Attributsgruppe zur Steuerung aller Applies wie z.B.: ApplyTo, AppliedBy, etc.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_1446">Attribute group for steering all Applies as for example: ApplyTo, AppliedBy, etc.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="ComponentAttributeGroup">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8843">Das Attribut Component gibt an, auf welche Komponente sich dieses PriceItem bezieht. Durch die explizite Angabe einer Komponente ist es möglich, dass ein Percent-PriceItem sich auf ein absolutes PriceItem einer anderen Komponente bezieht. Das Attribut Source stellt eine Erweiterung zum Attribut dar. Wird gleichzeitig das Attribut 'Component' und das Attribut 'Source' angegeben, so wird nur die Source ausgewertet. Werden beide Attribute nicht angegeben, wird für das Attribut 'Component der Wert 'ThisComponent' angenommen.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8843">The attribute Component defines, which component the PriceItem refers to. By explicitly defining a componente it is possible to have a Percent-PriceItem referring to an absolute PriceItem of another component. The attribute Source represents an extension of the attribute. If both the attribute 'Component' and the attribute 'Source' are stated, only Source will be analyzed. If both attributes are not stated, the value 'ThisComponent' is assumed for the attribute 'Component'.</xs:documentation>
			</xs:annotation>
		</xs:attributeGroup>
		<xs:attribute name="LogicalRelation" type="LogicalRelationEnum" use="optional" default="Or">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_3205">Dieses Attribut definiert, ob die ermittelte Menge der PriceItem-Paare mit anderen Apply-Mengen verodert oder verundet werden. Default = "Or"</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_3205">This attribute defines, if the identified set of PriceItem pairs is combined with other Apply sets by OR or AND. Default = "Or"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="ApplyToAttributeGroup">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_9065">Attributsgruppe zur Steuerung aller ApplyTos wie z.B.: ApplyTo, etc.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_9065">Attribute group for steering all ApplyTos as for example: ApplyTo, etc.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="ApplyAttributeGroup">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_3220">Das Attribut Component gibt an, auf welche Komponente sich dieses PriceItem bezieht. Durch die explizite Angabe einer Komponente ist es möglich, dass ein Percent-PriceItem sich auf ein absolutes PriceItem einer anderen Komponente bezieht. Das Attribut Source stellt eine Erweiterung zum Attribut dar. Wird gleichzeitig das Attribut 'Component' und das Attribut 'Source' angegeben, so wird nur die Source ausgewertet. Werden beide Attribute nicht angegeben, wird für das Attribut 'Component der Wert 'ThisComponent' angenommen.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_3220">The attribute Component indicates, which component this PriceItem refers to. With the explicit indication of a component it becomes possible, that a Percent-PriceItem refers to an absolute PriceItem of another component. The attribute Source is an extension of the attribute. If both attributes 'Component' and 'Source' are indicated simultaneously, only Source is evaluated. If none of the attributes are indicated, the value  'ThisComponent' is assumed for the attribute 'Component'.</xs:documentation>
			</xs:annotation>
		</xs:attributeGroup>
		<xs:attribute name="Include" type="IncludeAttributeEnum">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_3248">Mit Include="ApplyDescendants" können weitere PriceItems inkludiert werden, die von den adressierten PriceItems angewendet werden. So kann man bestimmte PercentPriceItems zuordnen und zusätzlich alle PriceItems inkludieren, die sich über ApplyTo und AppliedBy auf dieses PriceItem beziehen. Dieses Attribut berücksichtigt nur eine Apply-Hierarchie! Sollte ein Bezug auf ein generisches Absolute hergestellt werden, so wird hierbei dessen Include nicht mitberücksichtigt.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_3248">With Include="ApplyDescendants" more PriceItems can be included that are applied by the addressed PriceItems. So you can assign specific PercentPriceItems and additionally include all PriceItems that refer to this PriceItem via ApplyTo and AppliedBy. This attribute only considers an Apply hierarchy! If a reference to a generic absolute is to be obtained, its Include will not be taken into account.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="PriceTagsApplyType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_3253">The TagConditionType defines a condition for certain tags including the indication of Class, Location and value of the tag. Tags are value pairs indicated in defined node points. By tags the compilation of offers as well as the price calculation can be influenced.</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="ConsideredPriceTagsReferenceType">
				<xs:attributeGroup ref="ApplyAttributeGroup"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="BookingWithoutNodeType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_59">In diesem Element werden alle Values uusammengefasst, die zum Buchen notwendig sind. Später können über den BookingEntry andere Namespaces ergänzt werden, so dass spezifisch für verschiedene Buchungssysteme Values zusammen mit dem dazugehörenden Parameternamen angegeben werden können.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_59">In this element, all values ​​required for booking are combined. Later other Namespaces can be added to the BookingEntry, so that values specific to different booking systems are specified along with their corresponding parameter names​​.</xs:documentation>
		</xs:annotation>
		<xs:group ref="BookingWithoutNodeGroup"/>
	</xs:complexType>
	<xs:group name="BookingWithoutNodeGroup">
		<xs:sequence>
			<xs:element name="BookingGroup" type="BookingGroupType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="1.9"/>
		</xs:sequence>
	</xs:group>
	<xs:complexType name="BookingType">
		<xs:complexContent>
			<xs:extension base="SimpleUpdateNodeType">
				<xs:group ref="BookingWithoutNodeGroup"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BookingParameterType">
		<xs:choice minOccurs="0">
			<xs:element name="Value" type="xs:string"/>
			<xs:element name="Date">
				<xs:complexType>
					<xs:attribute name="Source" type="SourceAttributeType" default="ThisComponent">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_60">In diesem Attribut wird eine Referenz auf den Context der DayAllocation definiert. Zulässige Werte sind: 
- ThisComponent 
- Product 
- Accommodation 
- ReturnFlight 
- OnewayFlight 
- Outbound 
- Inbound 
- Addon 

Default ist "ThisComponent". Es sind aber theoretisch auch Namensreferenzen erlaubt. Siehe dazu auch in der Thematischen Dokumentation die Kapitel zum Source-Attribut. (Todo: Verlinkung) </xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_60">In this attribute a reference to the context of the DayAllocation will be defined.
Permitted values are:
- ThisComponent
- Product
- Accommodation
- ReturnFlight
- OnewayFlight
- Outbound
- Inbound
- Addon

Default is "ThisComponent".
Theoretically, however, name references are also allowed. For further information, see the Source Attribute chapter of the Thematic Documentation. (Todo: link)</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="DayType" type="DayTypeEnum" use="required">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_61">Dieses Attribut definiert, welches Datum in das Buchungsfeld übernommen werden soll. Mögliche Werte sind: 
- CheckIn 
- CheckOut</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_61">This attribute defines which date should be entered in the booking field.
Possible values are:
- CheckIn
- CheckOut</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="DateFormat" type="DateFormatEnum" default="[D01][M01][Y01]">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_62">Dieses Attribut definiert, in welcher Form das Datum in dem Feld angegeben wird. Dieses Template folgt den Regeln des picture Argumentes der xslt:format-date Funktion aus dem XSLT 2.0 Standard. Die Argumente language und country werden auf den Wert des Market Elementes der OTDS Lieferung gesetzt.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_62">This attribute defines in what form the date should be entered in the field. This template follows the rules of the picture argument of the xslt:format-date function from the XSLT 2.0 Standard. The arguments language and country are set to the values of the Market element of the OTDS delivery.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element name="Duration">
				<xs:complexType>
					<xs:attribute name="Source" type="SourceAttributeType" default="ThisComponent">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_63">In diesem Attribut wird eine Referenz auf den Context der DayAllocation definiert. Zulässige Werte sind: 
- Product
- Accommodation 
- ReturnFlight 
- OnewayFlight 
- Outbound 
- Inbound 
- Addon 

Default ist "ThisComponent". Es sind aber theoretisch auch Namensreferenzen erlaubt. Siehe dazu auch in der Thematischen Dokumentation die Kapitel zum Source-Attribut. (Todo: Verlinkung) </xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_63">A reference to the context of the DayAllocation will be defined in this attribute.
Permitted values are:
- Product
- Accommodation
- ReturnFlight
- OnewayFlight
- Outbound
- Inbound
- Addon

Default is "ThisComponent".
Theoretically, name references are also allowed.
For further information, see the Source Attribute chapter of the Thematic Documentation. (Todo: link)</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element name="PersonAge">
				<xs:complexType>
					<xs:attribute name="AgeType" type="AgeTypeEnum" default="TravelAge">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_64">Dieses Attribut definiert, in welcher Art die Altersangabe übergeben werden soll. Folgende Werte sind zulässig: 
- DateOfBirth 
- TravelAge 
- BookingAge 

Ages werden als Integer in Jahren angegeben. Das Format der Datumsangabe wird im Attribut "DateFormat" definiert. </xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_64">This attribute defines which type of age entry should be given.
The following values are permitted:
- DateOfBirth
- TravelAge
- BookingAge

Ages are to be entered as integers in years. The format of the date entry is defined in the "DateFormat" attribute.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="DateFormat" type="DateFormatEnum" default="[D01][M01][Y01]">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_65">Dieses Attribut definiert, in welcher Form das Datum in dem Feld angegeben wird. Dieses Template folgt den Regeln des picture Argumentes der xslt:format-date Funktion aus dem XSLT 2.0 Standard. Die Argumente language und country werden auf den Wert des Market Elementes der OTDS Lieferung gesetzt.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_65">This attribute defines in what form the date should be entered in the field. This template follows the rules of the picture argument of the xslt:format-date function from the XSLT 2.0 Standard. The arguments language and country are set to the values of the Market element of the OTDS delivery.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element name="Tag" type="EmptyTagConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_66">Dieses Element referenziert über seine Attribute ein Tag im OTDS-Baum, dessen Value an dieser Stelle als Booking-Value eingefügt wird. Eine Referenzierung auf Tags des TagTypes= "Price" ist nicht definiert und führt dazu, dass der Value="" verwendet wird.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_66">This element uses its attributes to reference a tag in the OTDS tree, whose value is entered at this position as Booking Value. A reference to tags of TagType = "Price" is not defined and will lead to the Value="" being used.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ConditionalTag" type="EmptyTagConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_67">Dieses Element referenziert über seine Attribute ein Tag im OTDS-Baum, dessen Value an dieser Stelle als Booking-Value eingefügt wird. Eine Referenzierung auf Tags des TagTypes= "Price" ist nicht definiert und führt dazu, dass der Value="" verwendet wird.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_67">This element uses its attributes to reference a tag in the OTDS tree, whose value is entered at this position as Booking Value. A reference to tags of TagType = "Price" is not defined and will lead to the Value="" being used.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:attribute name="Name" type="NameType" default="Default">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_68">Dieses Attribut definiert zusammen mit dem Attribut "Area" und dem Attribut "Field" die Eindeutigkeit eines BookingParameters während der finalen Verarbeitung.  </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_68">Along with the "Area" and "Field" attributes, this attribute defines the uniqueness of a BookingParameter during the final processing.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Field" type="FieldEnum" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_69">Dieses Attribut definiert, welches Feld des BuchungsContextes angesprochen wird. Mögliche Werte sind: 
- Title (dieses Feld definiert die Anreden, klassisch in Deutschland: D, H, K, B) 
- Brand (dieses Feld definiert die Brandcodes) 
- TravelType (dieses Feld definiert die Reiseart) 
- RequestCode (dieses Feld definiert die Anforderung. Klassisch "F" für Flug, "H" für Hotel, "FW" für Ferienwohnungen, etc.) 
- ServiceCode (dieses Feld definiert den Leistungscode oder Buchungscode des Hotels, des Fluges oder der Zusatzleistung) - ServiceFeatureCode (dieses Feld definiert den Code für die nächste Unterteilung der Leistung. Bei Hotels ist es das Zimmer, bei Flügen die Buchungsklasse und bei Addons der Service) 
- BoardCode (dieses Feld definiert den Code für die Verpflegung. Bei Zusatzleistungen wird dieses Feld manchmal zur weiteren Unterteilung von Services benutzt) 
- Assignment (dieses Feld definiert die Belegung einer Komponente. Teilweise wird dieses Feld auch für Platzierung von Kinderbetten-Codierungen benutzt) 
- DateStart (dieses Feld definiert den Starttermin der einzelnen Komponenten im Buchungskontext. Die Zuweisung erfolgt in der Regel über das Child-Element Date) 
- DateEnd (dieses Feld definiert den Endtermin der einzelnen Komponenten im Buchungskontext. Die Zuweisung erfolgt in der Regel über das Child-Element Date oder Duration) 
- Age (dieses Feld definiert das Alter der einzelnen Mitreisenden im Buchungskontext. Die Zuweisung erfolgt in der Regel über das Child-Element PersonAge)</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_69">This attribute defines which field of the BookingContext is being referred to. Possible values are:
- Title (This field defines the title. Classic in Germany D, H, K, B)
- Brand (This field defines the brand codes.)
- TravelType (This field defines the travel type.)
- RequestCode (This field defines the request. Classic "F" for flight, "H" for hotel, "FW" for holiday apartment, etc.)
- ServiceCode (This field defines the service code or booking code of the hotel, flight, or additional service.)
- ServiceFeatureCode (This field defines the code for the next sub-division of the service. For hotels it is the room, for flights it is the booking class, and for add-ons the service.)
- BoardCode (This field defines the code for board. For add-ons, this field is sometimes used as a further sub-division under services.)
- Assignment (This field defines the occupancy of a component. The field is sometimes also used for placing cot codes.)
- DateStart (This field defines the start date of individual components in the booking context. This is generally assigned via the Child-Element Date.)
- DateEnd (This field defines the end date of individual components in the booking context. This is generally assigned via the Child-Element Date or Duration.)
- Age (This field defines the age of each of the travellers in the booking context. This is generally assigned via the Child-Element PersonAge.)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Index" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_70">Dieses Attribut definiert, an welcher Position der BookingParameter mit einem anderen BookingParameter zusammengefügt wird. Der Wert kann positive und negative Werte annehmen. Default ist 0.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_70">This attribute defines at what position a booking parameter is added another booking parameter.
The value can be positive or negative. The default is 0.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="LeftSeparator" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_71">LeftSeparator - Ist der Parameter nicht der erste Parameter, wird dieser Separator direkt vor dem Parameter eingefügt.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_71">LeftSeparator - If the parameter is not the first, this separator will be inserted directly in front of it.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="RightSeparator" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_72">RightSeparator - Ist der Parameter nicht der letzte Parameter, wird dieser Separator direkt nach dem Parameter eingefügt</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_72">RightSeparator - If the parameter is not the last, this separator will be inserted directly behind it.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="PadLength" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_73">PadLength - Gibt an, dass der Parameter mittels eines Füllzeichens auf eine feste Länge gebracht werden soll. Ist der Parameter schon länger als PadLength, wird kein Padding vorgenommen. Vorgabe ist 0.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_73">PadLength - specifies the parameter should be strecthed to a certain length using fill character. If the parameter is already longer than PadLength, no padding is required. The default is 0.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="PadOrientation" type="PadOrientationEnum" default="Right">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_74">PadOrientation - Legt fest, auf welcher Seite des Parameters das Füllzeichen eingefügt wird. Vorgabe ist Right. Left - fügt das Padding links ein; Right - fügt das Padding rechts ein.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_74">PadOrientation - specifies on which side of the parameter the fill character is inserted. The default is Right. Left - padding will be inserted to the left; Right - padding will be inserted to the right.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Padding" type="xs:string" default=" ">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_75">Padding - Legt das Zeichen fest, mit welchem der Parameter aufgefüllt wird. Vorgabe ist das Leerzeichen.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_75">Padding - determines the character with which the parameter is filled up. The default is a space.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="PadCondition" type="PadConditionEnum" default="Always">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_76"> PadCondition - Legt zusätzliche Bedingungen fest, wann das Padding zu erfolgen hat. Möglich sind folgende Werte: 
- Always: Das Padding wird immer eingefügt. 
- NotFirst: Das Padding wird eingefügt, wenn der Parameter nicht der erste Parameter ist. 
- NotLast: Das Padding wird eingefügt, wenn der Parameter nicht der letzte Parameter ist. 
- NotAtEnds: Das Padding wird eingefügt, wenn der Parameter weder der erste noch der letzte Parameter ist. 
Default= Always </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_76">PadCondition - specifies additional conditions when padding is to be used. Possible values ​​are as follows:
- Always: padding is always inserted
- NotFirst: padding is inserted, if the parameter is not the first parameter.
- NotLast: padding is inserted, if the parameter is not the last parameter.
- NotAtEnds: padding is inserted, if the parameter is neither the first nor the last parameter.
Default = Always</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="BookingReplaceType">
		<xs:attribute name="Source" type="BookingReplaceSourceAttributeType" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_77">Dieses Attribut addressiert eine KomponentInstanz. Klassisch entspricht eine Leistungszeile einer KomponentInstanz. Die Adressierung erfolgt analog zum Attribut "Source" in den Conditions. Default ist "ThisComponent". In "BookingReplace" ist zusätzlich die Verwendung von "*" (Stern) erlaubt. Der Stern steht für beliebige Werte. Mit Hilfe von "*" (Stern) matcht man jeden beliebigen Wert der "Source" von BookingElementen. </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_77">This attribute addresses a single component instance. Typically this conforms to a service line in a component instance. Addressing is the same as for the "Source" attribute in the conditions. Default is "ThisComponent".
In "BookingReplace" the additional use of "*" (asterisk) is allowed. The asterisk stands for any value. Using the "*" (asterisk) any value can be matched with the "Source" attribute in the booking elements.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Class" type="xs:string" default="*">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_78">Dieses Attribut identifiziert innerhalb einer Group unterschiedliche Leistungszeilen. Zum Beispiel, wenn eine Komponente zwei Leistungszeilen erzeugt. Der Wert "*" (Stern) steht für beliebige Werte. Mit Hilfe von "*" (Stern) matcht man jeden beliebigen Wert der "Class" von BookingElementen.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_78">This attribute identifies different service lines within a group. For example, if a component produces 2 service lines. The value "*" (asterisk) stands for any value​​. Using the "*" (asterisk) matches any value to the "Class" of booking elements.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="BookingGroupType">
		<xs:sequence>
			<xs:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_79">Wildcard erlaubt Child-Element aus dem Amadeus-Namespace. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_79">The wildcard allows a child element from the Amadeus namespace.</xs:documentation>
				</xs:annotation>
			</xs:any>
			<xs:element name="BookingReplace" type="BookingReplaceType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_80">Mit diesem Element können beliebige Buchungsparameter innerhalb eines Buchungscontexts ersetzt werden. Die Verwendung der Attribute erfolgt analog zu den Attributen in BookingParameter. Die Attribute in BookingReplace haben lediglich zusätzlich den Value "*". Stern steht dabei für beliebige Werte. Dadurch kann ein Replace mehrere Instanzen von BookingParameter ersetzen.
BookingReplace wird vorzugsweise bei der Definition von "Flughüllen"  benutzt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_80">With this element any booking parameters can be replaced within a booking context. The use of attributes is similar to the attributes in booking parameters. The attributes in BookingReplace only have the value "*". The asterisk stands for any value. This allows multiple instances of substitutions within the booking parameters.
BookingReplace is preferably used in the definition of "flight cases".</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BookingParameter" type="BookingParameterType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_81">Mit diesem Element können Buchungsparameter und deren Platzierung innerhalb eines Buchungskontexts definiert werden. Die Art der Verwendung des Parameters wird dabei über verschiedene Attribute festgelegt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_81">With this element booking parameters and their placement within a booking context are defined. The nature of the use of this parameter is set using various attributes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Condition" type="ConditionType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="EvaluationBase" type="EvaluationBaseEnum"/>
		<xs:attribute name="Priority" type="xs:int" default="0"/>
		<xs:attribute name="Area" type="AreaEnum" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_83">Dieses Attribut definiert, welchen Bereich der Buchung der Parameter zugeordnet wird. Folgende Werte sind möglich: 
- GlobalArea (für Globale Werte wie Brand und TravelType) 
- ServiceArea (für Werte der Leistungszeilen, also für Flüge, Accommodations und Addons)
- PersonArea (für Werte des Personenblockes)</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_83">This attribute defines to which part of the booking the parameter is assigned. The following values are permitted:
- GlobalArea (For global values such as Brand and TravelType)
- ServiceArea (For values of the service lines for flights, accommodation and add-ons)
- PersonArea (For values of the persons block.)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Source" type="SourceAttributeType" default="ThisComponent">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_84">Dieses Attribut adressiert eine Komponenteninstanz. Einer Komponenteninstanz entsprechen in diesem Zusammenhang alle Leistungszeilen einer Komponente. Die Adressierung der Komponenteninstanz erfolgt analog zum Attribut "Source" in den Conditions. Default ist "ThisComponent". Globale Parameter werden als eigenständige Buchungszeile an die Komponente 'Product' gehängt.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_84">This attribute addresses a single component instance. A component instance contained in this context refers to all the service lines of a component. The addressing of the component instance is the same as for the "Source"attribute in the conditions.
Default is "ThisComponent". Global parameters are treated as separate booking factors attached to the 'Product' component.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Class" type="xs:string" default="Default">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_85">Dieses Attribut identifiziert innerhalb einer Komponenteninstanz unterschiedliche Leistungszeilen. Zum Beispiel wenn eine Komponente zwei Leistungszeilen erzeugt.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_85">This attribute identifies different service lines within a component instance. For example, if a component produces 2 service lines</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:element name="BookingEntry" type="BookingEntryType" abstract="true">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_86">Das BookingEntry ist die Integrationsmarke für Namespaces verschiedener Reservierungssysteme. Es ist denkbar, dass an dieser Stelle später komplexe Strukturen zum Befüllen von Reservierungssystemen platziert werden können.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_86">The BookingEntry identifies the integration of namespaces from other reservation systems. It is conceivable that at this point complex structures might later be introduced to fill reservation systems.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="BookingEntryType"/>
	<xs:element name="PropertyEntry" type="PropertyEntryType" abstract="true">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_87">Das PropertyEntry ist die Integrationsmarke für Namespaces verschiedener Attributierungssysteme. Es ist denkbar, dass an dieser Stelle später komplexe Strukturen zum Definieren der Attribute platziert werden können.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_87">The PropertyEntry identifies the integration of namespaces from other attribution systems. It is conceivable that at this point complex structures might later be introduced to define the placement of attributes.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="PropertyEntryType"/>
	<xs:complexType name="OccupancyType">
		<xs:complexContent>
			<xs:extension base="MultipleSimpleUpdateNodeType">
				<xs:sequence>
					<xs:sequence>
						<xs:element name="Person" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_88">Definition der Personen, die in der Unterkunft buchbar sind. Die Personen werden nach Alter absteigend definiert.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_88">Definition of persons who can be booked into the accommodation. Persons are defined in descending order by age.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:complexContent>
									<xs:extension base="OccupancyPersonType">
										<xs:attribute name="MatchAvailability" type="MatchAvailabilityEnum">
											<xs:annotation>
												<xs:documentation xml:lang="de" xml:id="de_8844">Diese Element bestimmt, ob es einen Bezug zwischen der Anzahl der Personen und der in der Availability/DayState/Open angegebenen Zahl gibt. 
Ist der Wert in Availability/DayState/Open eines Angebotes muss >= der Anzahl der mit "MatchCount" markierten Personen sein. Alle Personen, die mit "Ignore" markiert sind, spielen bei dieser Auswertung keine Rolle.</xs:documentation>
												<xs:documentation xml:lang="en" xml:id="en_8844">This element defines if there is a correlation between the number of personen and the number stated in the Availability/DayState/Open. 
If the value in Availability/DayState/Open of an offer must be >= the number of the persons marked with "MatchCount". All personen that are marked with "Ignore" are not considered in this evalation.</xs:documentation>
											</xs:annotation>
										</xs:attribute>
									</xs:extension>
								</xs:complexContent>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:element name="Exclude" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_89">Ausschluss von Belegungsmöglichkeiten</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_89">Possible occupancy exclusions</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="OccupancyExcludeType"/>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OccupancyExcludeType">
		<xs:sequence>
			<xs:element name="Person" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_90">Definition der Personen, die in der Unterkunft buchbar sind</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_90">Definition of persons who can be booked into the accommodation</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="BaseOccupancyPersonType"/>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="BaseOccupancyPersonType">
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:sequence>
					<xs:element name="MinAge" type="PersonAgeType" minOccurs="1">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_91">Mindestalter der Person(en)</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_91">Minimum age of the person (s)</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="MaxAge" type="PersonAgeType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_92">Höchstalter der Person(en)</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_92">Maximum age of the person(s)</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:sequence>
					<xs:element name="MaxAge" type="PersonAgeType" minOccurs="1">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_3263">Höchstalter der Person(en)</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_3263">Maximum age of the person(s)</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:choice>
			<xs:choice minOccurs="1">
				<xs:sequence>
					<xs:element name="MinCount" type="xs:unsignedShort" minOccurs="1" internal:otdsversion="1.9">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_93">Mindestanzahl Personen</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_93">Minimum number of persons</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="MaxCount" type="xs:unsignedShort" minOccurs="0" internal:otdsversion="1.9">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_94">Maximale Anzahl Personen</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_94">Maximum number of persons</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:sequence>
					<xs:element name="MaxCount" type="xs:unsignedShort" minOccurs="1" internal:otdsversion="1.9">
						<xs:annotation>
							<xs:documentation xml:lang="de">Maximale Anzahl Personen</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:element name="Count" type="xs:unsignedShort" minOccurs="1" internal:otdsversion="1.9">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_95">Genaue Anzahl der Person(en)</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_95">Exact number of person (s)</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="OccupancyPersonType">
		<xs:complexContent>
			<xs:extension base="BaseOccupancyPersonType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BrandType">
		<xs:complexContent>
			<xs:extension base="MultipleCompositeUpdateNodeWithTagsType">
				<xs:sequence>
					<xs:element name="Booking" type="BookingType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_96">Unter diesem Zweig werden die Buchungsparameter für die entsprechende Marke platziert. </xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_96">Under this branch the reservation parameters for the corresponding brand are placed.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Properties" type="PropertiesType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_6">Stammdaten der Brand.
Zum Beispiel: 
- MarketingBrandName
- MarketingBrandCode
</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_6">Master data for accommodation: 
For example:
- MarketingBrandName
- MarketingBrandCode
</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BrandsType">
		<xs:complexContent>
			<xs:extension base="CompositeUpdateNodeType">
				<xs:sequence maxOccurs="unbounded">
					<xs:element name="Brand" type="BrandType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_97">Unter diesem Zweig können eine oder mehrere Brands bzw. Marken definiert werden, unter denen die gelieferten Angebote verkauft werden. Das Key-Attribute sollte so gefüllt sein, dass die Marke daraus abgeleitet werden kann. In den Komponenten und Regeln kann man über "Tags" Einschränkungen (Filter) bzw. Bedingungen (Conditions) bzgl. der Verwendung der Brands definieren.
Dazu müssen an diesem Knoten entsprechende Tags definiert werden, auf die sich die Conditions und Filter beziehen können. Näheres dazu finden Sie in der "Thematischen Spezifikation" unter "Tags und Keys". 
Die Brands haben bzgl. der Datenproduktion eine wichtige Rolle, da jede Brand eine eigene Instanz aller Angebote aller Komponenten erzeugt. Über entsprechende Tag-Filter kann wiederum die Verwendung der Brands eingeschränkt werden, so dass bestimmte Angebote ggf. nur für bestimmte Brands erzeugt werden. Außerdem kann man über die Tag-Condition entsprechenden Einfluss auf die Preisberechnung nehmen. Die Preise können sich also je nach betrachteter Brand unterscheiden.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_97">Under this branch one or more brands can be defined, under which the delivered offers are sold. The key attributes should be filled so that the brand can be derived from them. In the components and rules "Tags" can be used to define restrictions (Filter) or conditions (Conditions) regarding the assignment of brands. Tags corresponding to this node must be defined, which Conditions and Filters can then relate to. For details, refer to "Thematic specification" under "Tags and Keys". With respect to data production brands play an important role, since every brand creates its own instance of all offers of all components. Using the appropriate tag filter, the use of the brands is limited so that some deals may be generated only for certain brands. You can also use the Tag condition to have a corresponding influence on the price calculation. Prices may therefore differ depending on the brand specified.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ComponentsType">
		<xs:complexContent>
			<xs:extension base="SimpleUpdateNodeType">
				<xs:choice maxOccurs="unbounded">
					<xs:element name="Accommodation" type="RuleAccommodationComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_98">Dieses Element definiert, dass in dem definierten Produkt eine Accommodation-Komponente enthalten sein muss. Falls mehrere Accommodation-Komponenten vorkommen, kann man über das Attribut "Name" jede einzelne eindeutig kennzeichnen. Über diese Kennzeichnung kann man sich in den Filtern eindeutig auf eine Komponente beziehen. Das optionale Attribut "DayAllocationIndex" bestimmt die Zuordnung der Komponenten im Reiseverlauf.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_98">This element defines that an accommodation component must contain the defined product. If there are several accommodation components, each one can be individually labelled using the "Name" attribute. You can refer to a certain component in the filters using this name. The optional attribute "DayAllocationIndex" determines the classification of components in the travel itinerary.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="ReturnFlight" type="RuleReturnFlightComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_99">Dieses Element definiert, dass in dem definierten Produkt eine ReturnFlight-Komponente enthalten sein muss. Falls mehrere ReturnFlight-Komponenten vorkommen, kann man über das Attribut "Name" jede einzelne eindeutig kennzeichnen. Über diese Kennzeichnung kann man sich in den Filtern eindeutig auf eine Komponente beziehen. Das optionale Attribut "DayAllocationIndex" bestimmt die Zuordnung der Komponenten im Reiseverlauf.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_99">This element defines that the defined product must contain a ReturnFlight component. If there are several ReturnFlight components, each one can be individually labelled using the "Name" attribute. You can refer to a certain component in the filters using this name.
The optional attribute "DayAllocationIndex" determines the classification of components in the travel itinerary.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="OnewayFlight" type="RuleOnewayFlightComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_100">Dieses Element definiert, dass in dem definierten Produkt eine OnewayFlight-Komponente enthalten sein muss. Falls mehrere OnewayFlight-Komponenten vorkommen, kann man über das Attribut "Name" jede einzelne eindeutig kennzeichnen. Über diese Kennzeichnung kann man sich in den Filtern eindeutig auf eine Komponente beziehen. Das optionale Attribut "DayAllocationIndex" bestimmt die Zuordnung der Komponenten im Reiseverlauf.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_100">This element defines that the defined product must contain a OnewayFlight component. If there are several OnewayFlight components, each one can be individually labelled using the "Name" attribute. You can refer to a certain component in the filters using this name.
The optional attribute "DayAllocationIndex" determines the classification of components in the travel itinerary.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Addon" type="RuleAddonComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_101">Dieses Element definiert, dass in dem definierten Produkt eine Addon-Komponente enthalten sein muss. Falls mehrere Addon-Komponenten vorkommen, kann man über das Attribut "Name" jede einzelne eindeutig kennzeichnen. Über diese Kennzeichnung kann man sich in den Filtern eindeutig auf eine Komponente beziehen. Das optionale Attribut "DayAllocationIndex" bestimmt die Zuordnung der Komponenten im Reiseverlauf.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_101">This element defines that the defined product must contain an Addon component. If there are several Addon components, each one can be individually labelled using the "Name" attribute. You can refer to a certain component in the filters using this name.
The optional attribute "DayAllocationIndex" determines the classification of components in the travel itinerary.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefinedComponent" type="RuleDefinedComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_102">Dieses Element definiert, dass eine in DefinedComponent definierte Komponente im Produkt enthalten sein muss. Über das Attribut "Use" wird festgelegt, welche DefinedComponents benutzt werden. Es werden jeweils alle DefinedComponents benutzt, deren Attribut "Role" mit dem Attribut "Use" übereinstimmen. Über das Attribut "Name" findet eine eindeutige Kennzeichnung der DefinedComponent statt. Über diese Kennzeichnung kann man sich in den Filtern der Rule eindeutig auf diese Komponente beziehen. Das optionale Attribut "DayAllocationIndex" bestimmt die Zuordnung der Komponenten im Reiseverlauf. Die empfohlenen Werte für Dayallocation in Verbindung mit dem Komponententyp der hier definierten CombiComponente sollte unbedingt eingehalten werden.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_102">This element defines that the product must contain a component defined in DefinedComponent. The "Use" attribute defines which DefinedComponents are being used. All DefinedComponents which have matching "Role" and "Use" attributes are used in each case. The "Name" attribute is used to give the DefinedComponent a unique name. You can use this name in the filters to apply the rule specifically to this component. The optional attribute "DayAllocationIndex" determines the classification of components in the travel itinerary. The recommended values for Dayallocation in relation to the component type of the CombiComponent defined here should be adhered to.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="CombiComponent" type="RuleCombiComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_103">Dieses Element definiert, dass in dem definierten Produkt eine CombiComponent enthalten sein muss. Falls mehrere CombiComponents vorkommen, kann man über das Attribut "Name" jede einzelne eindeutig kennzeichnen. Über diese Kennzeichnung kann man sich in den Filtern eindeutig auf eine Komponente beziehen. Das optionale Attribut "DayAllocationIndex" bestimmt die Zuordnung der Komponenten im Reiseverlauf. Die empfohlenen Werte für Dayallocation in Verbindung mit dem Komponententyp der hier definierten CombiComponente sollte unbedingt eingehalten werden.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_103">This element defines that the defined product must contain a CombiComponent. If there are several CombiComponents, each one can be individually named using the "Name" attribute. You can refer to a certain component in the filters using this name.
The optional attribute "DayAllocationIndex" determines the classification of components in the travel itinerary. The recommended values for Dayallocation in relation to the component type of the CombiComponent defined here should be adhered to.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="ProductComponent">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_104">Dieser Zweig definiert eine Komponente, die aus einem kompletten Produkt besteht. In OTDS Version 1.0 ist die Verwendung dieses Elements ausschließlich im Zusammenhang mit der Komponente "Addon" definiert, um die Abhängigkeiten optionaler Addons von Produkten festzulegen.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_104">This branch defines a component that consists of a complete product. In OTDS Version 1.0 the use of this element is exclusively defined in relation to the "Addon" component, in order to establish the dependencies of the optional add-ons of products.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="RuleProductComponentType">
									<xs:attribute name="Name" type="NameType">
										<xs:annotation>
											<xs:documentation xml:lang="de" xml:id="de_105">Dieses Element definiert einen Namen, der innerhalb der ProductRules von den Filtern innerhalb des Attributes "Source" als Referenz benutzt werden kann. 
							</xs:documentation>
											<xs:documentation xml:lang="en" xml:id="en_105">This element defines a name within the product rules of the filters using the "Source" attribute as the reference.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="ProductType" type="ProductTypeEnum" use="required">
										<xs:annotation>
											<xs:documentation xml:lang="de" xml:id="de_106">Über dieses Attribut werden die Produkte referenziert, für die dieses Element steht. Es wird dabei auf das Attribute "ProductType" im Element "Product" verwiesen.</xs:documentation>
											<xs:documentation xml:lang="en" xml:id="en_106">This attribute references the products that this element stands for. The "ProductType" attribute in the "Product" element is referred to.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
					<xs:element name="AccommodationWrapper" type="RuleAccommodationWrapperComponentType" internal:otdsversion="2.0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_549">Dieses Element definiert, dass in dem definierten Produkt ein AccommodationWarpper enthalten ist, der eine oder mehrere Accommodations enthalten. Falls mehrere AccommodationWrapper definiert sind, kann man über das Attribut "Name" jede einzelne eindeutig kennzeichnen. Über diese Kennzeichnung kann man sich in den Filtern eindeutig auf die WrapperKomponente beziehen. Das optionale Attribut "DayAllocationIndex" bestimmt die Zuordnung der Komponenten im Reiseverlauf.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_549">This element defines that an AccommodationWrapper is part of the defined product. 
							The AccommodationWrapper contains one or more accommodation components. If there are several AccommodationWrappers, each one can be individually labelled using the "Name" attribute. You can refer to a certain component in the filters using this name.
The optional attribute "DayAllocationIndex" determines the classification of components in the travel itinerary.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="FlightWrapper" type="RuleFlightWrapperComponentType" internal:otdsversion="2.0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_550">Dieses Element definiert, dass in dem	definierten Produkt ein FlightWrapper enthalten ist, der eine oder mehrere OnewayFlights enthalten. Falls mehrere FlightWrapper definiert sind, kann man über das Attribut "Name" jede einzelne eindeutig kennzeichnen. Über diese Kennzeichnung kann man sich in den Filtern eindeutig auf die WrapperKomponente beziehen.  
Das optionale Attribut "DayAllocationIndex" bestimmt die Zuordnung der Komponenten im Reiseverlauf.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_550">This element defines that an FlightWrapper is part of the defined product. 
							The FlightWrapper contains one or more OnewayFlight components. If there are several FlightWrapper, each one can be individually labelled using the "Name" attribute. You can refer to a certain component in the filters using this name.
The optional attribute "DayAllocationIndex" determines the classification of components in the travel itinerary.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="AddonWrapper" type="RuleAddonWrapperComponentType" internal:otdsversion="2.0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_551">Dieses Element definiert, dass in dem definierten Produkt ein AddonWrapper enthalten ist, der eine oder mehrere Addons enthält. Falls mehrere AddonWrapper definiert sind, kann man über das Attribut "Name" jede einzelne eindeutig kennzeichnen. Über diese Kennzeichnung kann man sich in den Filtern eindeutig auf die WrapperKomponente beziehen. 
Das optionale Attribut "DayAllocationIndex" bestimmt die Zuordnung der Komponenten im Reiseverlauf.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_551">This element defines that an AddonWrapper is part of the defined product. 
							The AddonWrapper contains one or more Addon components. If there are several AddonWrapper, each one can be individually labelled using the "Name" attribute. You can refer to a certain component in the filters using this name.
The optional attribute "DayAllocationIndex" determines the classification of components in the travel itinerary.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="ExternalComponent" internal:otdsversion="2.0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_8845">Dieses Element definiert, dass dieses Produkt zwingend eine externe, also nicht in der Lieferung enthaltene Komponente des mit @Role definierten Typs benötigt. Das verarbeitenden System ergänzt das Produkt um die externe Komponente.
Erst mit dieser externen Komponente ist das Produkt vollständig. Die externe Komponente ist immer zeit - und personenallozierend. Abhängig von der @Role sind nur die externen Komponenten mit Role="Accommodation" und Role="Addon" zeitlich flexible Komponenten.
Key-, Tag, ConditionalTag-, Filter oder Conditions in Kombination mit externen Komponenten werden derzeit explizit als "False" ausgewertet.

Das optionale Attribut "DayAllocationIndex" bestimmt die Zuordnung der Komponenten im Reiseverlauf.
Das optionale Attribut "Name" ermöglicht einen möglichen Bezug auf diese Komponente in Filtern und Conditions über das Attribut "Source" in Kombination mit dem Präfix "#"+Name. 

Die klassische Product-Definition eines DataMix-Produktes besteht damit aus 3 Components:
1. ExternalComponent "Outbound"
2. Accommodation
3. ExternalComponent "Inbound" 
</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_8845">This element defines, that it is mandatory for the product to contain an external (thus not included in the delivery) component of the type defined by @Role. The processing system complements the product with the external components.
Only with this external component the product becomes complete. The external component always is time- and person allocating. Depending on the  @Role only the external components with Role="Accommodation" and Role="Addon" are flexible components with respect to time.
Key-, Tag, ConditionalTag-, Filter or Conditions in combination with external components as of today explicitly are evaluated as "False".

The optional attribute "DayAllocationIndex" defines the correlation of the components within the itinerary.
The optional attribute "Name" allows a possible reference to these components in Filters and Conditions concerning the attribute "Source" combined with the prefix "#"+Name. 

The classic product definition of a DataMix-product thus consists of three Components:
1. ExternalComponent "Outbound"
2. Accommodation
3. ExternalComponent "Inbound" 
</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="RuleExternalComponentType"/>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
					<xs:element name="VirtualComponent" type="RuleVirtualComponentType" internal:otdsversion="2.0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_9000">Dieses Element definiert, dass in dem definierten Produkt eine virtuelle Komponente als Platzhalter enthalten ist. Diese Komponente ist eine Komponente mit flexibler Zeit- und Personenallozierung. 
Man kann sich in Filtern oder Conditions nicht auf diese Komponente beziehen.	Das optionale Attribut "DayAllocationIndex" bestimmt die Zuordnung der Komponenten im Reiseverlauf.
							</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_9000">This element definiert, that the defined product contains a virtual component as a place holder. This component is a component with flexible time- and person allocation. 
It is not possible to refer to this component in filters nor in conditions. The optional attribute "DayAllocationIndex" defines the correlation of the components within the itinerary.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GroupDefinitionsType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_107">Die GroupDefinition legt fest, welche Angebote zur Gruppe  gehören und in welcher Reihenfolge die Elemente der Gruppe sortiert werden.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_107">The GroupDefinition establishes which offers belong to the group and in which order the elements of the group should be sorted.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SimpleUpdateNodeType">
				<xs:sequence>
					<xs:element name="GroupDefinition" maxOccurs="unbounded">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="GroupBy">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_108">Die Angaben in GroupBy definieren, über welche Parameter die Angebote gruppiert werden. Die häufigste Verwendung wird sein, dass eine Gruppierung der Returnflüge über Abflughafen, Zielflughafen, Termin und Dauer erfolgt.</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_108">The entries in GroupBy define by what parameters the offers should be grouped. The most common use is that return flights are grouped via departure airport, destination airport, departure date and time, and duration.</xs:documentation>
									</xs:annotation>
									<xs:complexType>
										<xs:sequence maxOccurs="unbounded">
											<xs:choice>
												<xs:element name="Element">
													<xs:annotation>
														<xs:documentation xml:lang="de" xml:id="de_109">Dieses Element adressiert einen bestimmten Parameter innerhalb des Angebotskontextes. Über das Attribut "Source" wird die Unterkomponente adressiert. Der Body dieses Elements spezifiziert den SourceKnoten als nächsten untergeordneten Knoten unterhalb der adressierten Unterkomponente. Die Gruppierung erfolgt über den in diesem Element festgelegten Parameter. Das bedeutet, für alle Elemente einer Gruppe ist der hier definierte Parameter gleich. </xs:documentation>
														<xs:documentation xml:lang="en" xml:id="en_109">This element addresses a certain parameter within the offer context.
Accommodation components are addressed using the "Source" attribute. The body of this element specifies SourceNodes as the next subordinate nodes beneath the addressed sub-components.
The grouping takes place in the parameter determined in this element. That means that the parameter defined here is the same for all elements of a group.</xs:documentation>
													</xs:annotation>
													<xs:complexType>
														<xs:simpleContent>
															<xs:extension base="MatchElementEnum">
																<xs:attributeGroup ref="ConditionAttributeGroup"/>
																<xs:attributeGroup ref="SourceAttributeGroup"/>
															</xs:extension>
														</xs:simpleContent>
													</xs:complexType>
												</xs:element>
												<xs:element name="Date">
													<xs:annotation>
														<xs:documentation xml:lang="de" xml:id="de_110">Die Gruppierung erfolgt über das in den Attributen definierte Datum. Das bedeutet, alle Elemente einer Gruppe haben das gleiche CheckIn- oder CheckOut-Datum bezogen auf die durch die Attribute definierte Komponente.</xs:documentation>
														<xs:documentation xml:lang="en" xml:id="en_110">The grouping is done via the date defined in the attributes. That means that all elements of a group have the same check-in or check-out date relating to the components defined by the attributes.</xs:documentation>
													</xs:annotation>
													<xs:complexType>
														<xs:attribute name="Source" type="SourceAttributeType" default="ThisComponent">
															<xs:annotation>
																<xs:documentation xml:lang="de" xml:id="de_111">In diesem Attribut wird eine Referenz auf den Context der DayAllocation definiert. Zulässige Werte sind: - Product, - Accommodation, - ReturnFlight, - OnewayFlight, - Outbound, - Inbound, - Addon. Default ist "ThisComponent". Es sind aber theoretisch auch Namensreferenzen erlaubt. Siehe dazu auch in der Thematischen Dokumentation die Kapitel zum Source-Attribut. In diesem Falll definiert die Source, welches Datum aus welcher Unterkomponente für die Gruppierung verwendet wird.</xs:documentation>
																<xs:documentation xml:lang="en" xml:id="en_111">In this attribute a reference to the context of the DayAllocation will be defined. Permitted values are: - Product, - Accommodation, - ReturnFlight, - OnewayFlight, - Outbound, - Inbound, - Addon. Default is "ThisComponent". Theoretically, name references are also allowed. For further information, see the Source Attribute chapter of the Thematic Documentation. In this case, the source defines which date from which sub-component should be used for the grouping.</xs:documentation>
															</xs:annotation>
														</xs:attribute>
														<xs:attribute name="DayType" type="DayTypeEnum" use="required">
															<xs:annotation>
																<xs:documentation xml:lang="de" xml:id="de_112">Dieses Attribut definiert, ob es sich bei dem definierten Datum um eine CheckIn- oder CheckOut-Datum handelt. 
Mögliche Werte sind: 
- CheckIn 
- CheckOut</xs:documentation>
																<xs:documentation xml:lang="en" xml:id="en_112">This attribute defines whether the date defined concerns a CheckIn or CheckOut date.
Possible values are:
- CheckIn
- CheckOut</xs:documentation>
															</xs:annotation>
														</xs:attribute>
													</xs:complexType>
												</xs:element>
												<xs:element name="Duration">
													<xs:annotation>
														<xs:documentation xml:lang="de" xml:id="de_113">Die Gruppierung erfolgt über die hier definierte Duration. Das bedeutet, alle Elemente einer Gruppe haben die gleiche Duration bezogen auf die durch Source definierte Komponente.</xs:documentation>
														<xs:documentation xml:lang="en" xml:id="en_113">The grouping takes place via the Duration defined here. That means that all elements in a group have the same duration, in terms of the components defined through the source.</xs:documentation>
													</xs:annotation>
													<xs:complexType>
														<xs:attribute name="Source" type="SourceAttributeType" default="ThisComponent">
															<xs:annotation>
																<xs:documentation xml:lang="de" xml:id="de_114">In diesem Attribut wird eine Referenz auf den Context der DayAllocation definiert. Zulässige Werte sind: 
- Product
- Accommodation
 - ReturnFlight
 - OnewayFlight
 - Outbound
 - Inbound
 - Addon. 
 Default ist "ThisComponent". Es sind aber theoretisch auch Namensreferenzen erlaubt. Siehe dazu auch in der Thematischen Dokumentation die Kapitel zum Source-Attribut. </xs:documentation>
																<xs:documentation xml:lang="en" xml:id="en_114">A reference to the context of the DayAllocation will also be defined in this attribute. Permitted values are: 
- Product
- Accommodation
- ReturnFlight
- OnewayFlight
- Outbound
- Inbound
- Addon. 
Default is "ThisComponent". Theoretically, name references are also allowed. For further information, see the Source Attribute chapter of the Thematic Documentation.</xs:documentation>
															</xs:annotation>
														</xs:attribute>
													</xs:complexType>
												</xs:element>
												<xs:element name="Tag" type="EmptyTagConditionType">
													<xs:annotation>
														<xs:documentation xml:lang="de" xml:id="de_115">Dieses Element adressiert ein bestimmtes Tag innerhalb des Angebotskontextes. Die Gruppierung erfolgt über das hier referenzierte Tag. Das bedeutet, alle Elemente einer Gruppe haben den gleichen Tag-Value.</xs:documentation>
														<xs:documentation xml:lang="en" xml:id="en_115">This element addresses a certain tag within the offer context. The grouping is done via the tag referenced here. That means that all elements of a group have the same tag value.</xs:documentation>
													</xs:annotation>
												</xs:element>
											</xs:choice>
										</xs:sequence>
									</xs:complexType>
								</xs:element>
								<xs:element name="Sequence">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_116">Unter diesem Element wird die Reihenfolge der einzelnen Elemente der Gruppe definiert. Die Reihenfolge der Sort-Elemente im XML geben auch die Rangfolge der Abarbeitung der Sortierkriterien an. So kann man nach mehreren Kriterien nacheinander aufwärts oder abwärts sortieren, wie man es zum Beispiel aus MS-Excel kennt.</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_116">The order of individual elements in a group is defined under this element. The order of the sort elements in the XML also indicates the processing rank order of the sort criteria. They can be filtered in ascending or descending order by various criteria, as you may already know from Microsoft Excel.</xs:documentation>
									</xs:annotation>
									<xs:complexType>
										<xs:sequence>
											<xs:element name="Sort" maxOccurs="unbounded">
												<xs:annotation>
													<xs:documentation xml:lang="de" xml:id="de_117">Jedes Sort Element enthält eine Anzahl von Kriterien, nach denen aufwärts oder abwärts sortiert werden soll. Es wird zuerst nach dem ersten Sort-Element sortiert, danach bei Gleichheit nach dem nächsten Sort-Element. Das Attribut "Order" gibt an, ob aufwärts oder abwärts sortiert werden soll. Mit "Add" und "Average" können einzelne Sortierkriterien auch vor der Sortierung zusammengefasst werden.</xs:documentation>
													<xs:documentation xml:lang="en" xml:id="en_117">Each Sort element contains a number of criteria by which you can sort in ascending or descending order. First of all it will be sorted by the first Sort element, then by the next element if the first element is the same value. The "Order" attribute indicates whether the elements are to be sorted in ascending or descending order. With "Add" and "Average" individual sort criteria can also be added before the sorting takes place.</xs:documentation>
												</xs:annotation>
												<xs:complexType>
													<xs:choice>
														<xs:element name="Sum">
															<xs:annotation>
																<xs:documentation xml:lang="de" xml:id="de_121">In diesem Element können mehrere Elemente zu einer Summe zusammengeführt werden. Die Elemente müssen dabei zueinander passen. Das heißt, das Element 'Price' kann immer nur mit Tags des TagTypes "Price" auftreten. Und Tags des TagType="Numeric" können nur mit anderen Tags des TagType="Numeric" auftreten. Das erste ChildElement (laut XML-Order) des Elementes "Sum" gibt den geforderten TagType vor. Kommen danach Elemente oder Tags, die nicht zum geforderten TagType passen, so werden diese in die Summe mit dem Wert 0 integriert.</xs:documentation>
																<xs:documentation xml:lang="en" xml:id="en_121">In this element, a number of elements are combined to form a sum.
The elements must be compatible. That is, the element 'Price' can only occur within the "Price" tag types. And tags which = "Numeric" can only occur with other tags of the "Numeric" tag type.
With the first child element (according to XML order) the "Sum" element determines the required tag type. Elements or tags that do not match the required tag type, will be integrated into the sum with the value 0.</xs:documentation>
															</xs:annotation>
															<xs:complexType>
																<xs:sequence maxOccurs="unbounded">
																	<xs:choice>
																		<xs:element name="Price" type="SortPriceType">
																			<xs:annotation>
																				<xs:documentation xml:lang="de" xml:id="de_122">Dieses Element referenziert eine Menge von PriceItems. Zur Berechnung der Summe, die zur Sortierung benutzt wird, werden nur die PriceItems herangezogen, die bezogen auf die Platzierung der GroupDefinition an einem Ancestor-Knoten oder einem Descendant-Knoten hängen und für das gerade betrachtete Angebot gültig sind. Über die Source kann die Verwendung von PriceItems auf bestimmte Komponenten oder SubKomponenten eingeschränkt werden. Dazu wurde extra eingeführt, dass die Source auch auf Descendants und Ancestors referenzieren kann.
Schauen Sie dazu in die Doku unter dem Begriff "Source-Hierarchy".</xs:documentation>
																				<xs:documentation xml:lang="en" xml:id="en_122">This element defines a number of PriceItems. For the calculation of the sum, which is used for sorting only PriceItems attached to an ancestor node or descendant node within the GroupDefinition list, and those valid for the offer currently being viewed, are used. Via Source the use of PriceItems can be limited for specific Components or SubComponents. For doing so the possibility for Source to reference descendants and ancestors has been introduced. 
For more details please refer to the documentation and look for "Source-Hierarchy".</xs:documentation>
																			</xs:annotation>
																		</xs:element>
																		<xs:element name="Tag" type="EmptyTagConditionType">
																			<xs:annotation>
																				<xs:documentation xml:lang="de" xml:id="de_123">Dieses Element referenziert ein Tag oder eine Menge von Tags, welche zur Sortierung herangezogen werden und Bestandteil einer Summenbildung sind. In der Summe sind nur Tags der Typen Numeric oder Price erlaubt.
String-Tags führen zu ungültigen Ergebnissen der Summe. Die Attribute des Tags definieren, welche Tags im XML-Baum referenziert wird. </xs:documentation>
																				<xs:documentation xml:lang="en" xml:id="en_123">This element defines a tag or several tags, which is used for sorting and forms a component of a sum.
Within the sum only the tags Numeric or Price are permitted. String-tags lead to invalid results of the sum. The attributes of the tag define which tag in the XML tree is referenced.</xs:documentation>
																			</xs:annotation>
																		</xs:element>
																	</xs:choice>
																</xs:sequence>
															</xs:complexType>
														</xs:element>
														<xs:element name="Connect">
															<xs:annotation>
																<xs:documentation xml:lang="de" xml:id="de_125">Dieses Element definiert, dass mehrere Tags des TagTypes ="String" zu einem String zusammengeführt werden und dann eine lexikalische Sortierung nach diesem String erfolgt. Alle Elemente müssen dem TagType="String" entsprechen. Die Values der referenzierten Tags werden in der unter Element "Connect" aufgeführten XML-Order aneinandergefügt. Entspricht ein Tag nicht dem TagType="String", so wird es mit dem Wert "" (leerer String) in die Zeichenkette eingefügt. 
Es gilt die folgende generell in OTDS festgelegte Definition für Zeichenketten-Sortierungen: Zeichenketten werden grundsätzlich mit dem linken Zeichen beginnend Zeichen für Zeichen sortiert, wobei das erste Zeichen die höchste Priorität besitzt. Die Sortierung folgt den ASCII-Values der Zeichen und entspricht damit folgender aufsteigenden Liste: - . 0 1 2 3 usw. A B C usw. _ a b c usw. | ~ </xs:documentation>
																<xs:documentation xml:lang="en" xml:id="en_125">This element defines that multiple tags of the tag type = "String" will merge into a single string and then be sorted lexically. All elements must have the tag type ="String".
The values ​​of the referenced tags are combined in the "Connect" element and listed in XML order. If the tag is not of the "String" tag type it will inserted into the string with the value "" (empty string).
The following definition established in OTDS for character string sorting applies:
Character strings are generally sorted character by character, beginning with the character on the left, whereby the first character has the highest priority. The sorting follows the ASCII values of characters and corresponds to the following list in ascending order:
- . 0 1 2 3 etc. A B C etc. _ a b c etc. | ~</xs:documentation>
															</xs:annotation>
															<xs:complexType>
																<xs:sequence maxOccurs="unbounded">
																	<xs:element name="Tag">
																		<xs:annotation>
																			<xs:documentation xml:lang="de" xml:id="de_126">Dieses Element definiert ein Tag, welches zur Sortierung herangezogen wird und Bestandteil einer zusammengesetzten Zeichenkette ist. Die Attribute des Tags definieren, welches Tag im XML-Baum referenziert wird. </xs:documentation>
																			<xs:documentation xml:lang="en" xml:id="en_126">This element defines a tag which is used for sorting and is component of a composite character string.
The attributes of the tag define which tag in the XML tree is referenced.</xs:documentation>
																		</xs:annotation>
																		<xs:complexType>
																			<xs:complexContent>
																				<xs:extension base="EmptyTagConditionType">
																					<xs:attribute name="Padding" default=" ">
																						<xs:annotation>
																							<xs:documentation xml:lang="de" xml:id="de_8846">Padding - Legt das Zeichen fest, mit dem der  Einzelvalue des Tags vor der Connection aufgefüllt wird. Vorgabe ist das Leerzeichen.</xs:documentation>
																							<xs:documentation xml:lang="en" xml:id="en_8846">Padding - Determines the character with which the tag's single value before the Connection is filled up. The default is a space.</xs:documentation>
																						</xs:annotation>
																						<xs:simpleType>
																							<xs:restriction base="xs:string">
																								<xs:maxLength value="1"/>
																							</xs:restriction>
																						</xs:simpleType>
																					</xs:attribute>
																					<xs:attribute name="PadLength" default="0">
																						<xs:annotation>
																							<xs:documentation xml:lang="de" xml:id="de_8847">Dieses Attribut definiert, dass der Einzelvalue des Tags vor der Connection mit dem in Attribut "Padding" definierten Zeichen aufgefüllt wird. Ist der Value schon länger als PadLength, wird kein Padding vorgenommen. Default ist 0. Das Padding erfolgt vor der Zeichenkette.</xs:documentation>
																							<xs:documentation xml:lang="en" xml:id="en_8847">This attribute determines, that the tag's single value before the Connection is filled up with the character defined within the attribute "Padding". In case the value already is longer than PadLength, Padding is not executed. Default is 0. The Padding takes place before the character string.</xs:documentation>
																						</xs:annotation>
																						<xs:simpleType>
																							<xs:restriction base="xs:integer"/>
																						</xs:simpleType>
																					</xs:attribute>
																				</xs:extension>
																			</xs:complexContent>
																		</xs:complexType>
																	</xs:element>
																</xs:sequence>
																<xs:attribute name="Padding" default=" ">
																	<xs:annotation>
																		<xs:documentation xml:lang="de" xml:id="de_8848">Padding - Legt das Zeichen fest, mit dem der Ergebniswert nach der Connection aufgefüllt wird. Vorgabe ist das Leerzeichen.</xs:documentation>
																		<xs:documentation xml:lang="en" xml:id="en_8848">Padding - Determines the character with which the result value after the Connection is filled up. Default is a space.</xs:documentation>
																	</xs:annotation>
																	<xs:simpleType>
																		<xs:restriction base="xs:string">
																			<xs:maxLength value="1"/>
																		</xs:restriction>
																	</xs:simpleType>
																</xs:attribute>
																<xs:attribute name="PadLength" default="0">
																	<xs:annotation>
																		<xs:documentation xml:lang="de" xml:id="de_8849">Dieses Attribut definiert, dass der Ergebniswert nach der Connection mit dem in Attribut "Padding" definierten Zeichen aufgefüllt wird. Ist der Parameter schon länger als PadLength, wird kein Padding vorgenommen. Default ist 0. Das Padding erfolgt vor der Zeichenkette.</xs:documentation>
																		<xs:documentation xml:lang="en" xml:id="en_8849">This attribute determines, that the result value after the Connection is filled up with the character defined within the attribute "Padding". In case the value already is longer than PadLength, Padding is not executed. Default is 0. The Padding takes place before the character string.</xs:documentation>
																	</xs:annotation>
																	<xs:simpleType>
																		<xs:restriction base="xs:integer">
																			<xs:minInclusive value="0"/>
																		</xs:restriction>
																	</xs:simpleType>
																</xs:attribute>
															</xs:complexType>
														</xs:element>
														<xs:element name="Average">
															<xs:annotation>
																<xs:documentation xml:lang="de" xml:id="de_128">Dieses Element definiert, dass zwischen den Values der referenzierten Tags und ggf. einem Preis ein Mittelwert ermittelt wird und der so entstehende Mittelwert zur Sortierung herangezogen wird. Die Elemente müssen dabei zueinander passen. Dass heißt, das Element 'Price' kann immer nur mit Tags des TagTypes "Price" auftreten. Und Tags des TagType="Numeric" können nur mit anderen Tags des TagType="Numeric" auftreten. 
Das erste ChildElement (laut XML-Order) des Elementes "Average" gibt den geforderten TagType vor. Kommen danach Elemente oder Tags, die nicht zum geforderten TagType passen, so werden diese nicht in die Bildung des Mittelwertes einbezogen. In der Umsetzung reicht nicht, dass der Wert = 0 gesetzt wird, da ansonsten der Mittelwert beeinflusst wird.</xs:documentation>
																<xs:documentation xml:lang="en" xml:id="en_128">This element defines that a mean value is determined within the values of the tags referenced, and if necessary also the prices, and the resulting mean value is to be used for sorting. The elements must be compatible. That is, the element 'Price' can only occur within the "Price" tag types. And tags of the TagType="Numeric" can only appear with other tags of the TagType="Numeric". The first child element (according to XML order) of the "Average" element specifies the required TagType. Elements or tags that do not match the required TagType are not included in the calculation of the mean value. The value cannot be set to 0 as this will affect the calculation of the mean value.</xs:documentation>
															</xs:annotation>
															<xs:complexType>
																<xs:sequence maxOccurs="unbounded">
																	<xs:choice>
																		<xs:element name="Price" type="SortPriceType">
																			<xs:annotation>
																				<xs:documentation xml:lang="de" xml:id="de_129">Dieses Element definiert ein Tag, welches zur Sortierung herangezogen wird und Bestandteil einer Mittelwertbildung ist.  Zur Berechnung des Sortierungspreises werden nur die PriceItems herangezogen, die bezogen auf die Platzierung der GroupDefinition an einem Ancestor-Knoten oder einem Descendant-Knoten hängen und für das gerade betrachtete Angebot gültig sind.</xs:documentation>
																				<xs:documentation xml:lang="en" xml:id="en_129">This element defines a tag which is used for sorting and is a component in the formation of a mean value. To calculate the sorting price, only PriceItems attached to an ancestor node or descendant node within the GroupDefinition list, and those valid for the offer currently being viewed, are used.</xs:documentation>
																			</xs:annotation>
																		</xs:element>
																		<xs:element name="Tag" type="EmptyTagConditionType">
																			<xs:annotation>
																				<xs:documentation xml:lang="de" xml:id="de_130">Dieses Element definiert ein Tag, welches zur Sortierung herangezogen wird und Bestandteil einer Mittelwertbildung ist. Die Attribute des Tags definieren, welches Tag im XML-Baum referenziert wird. </xs:documentation>
																				<xs:documentation xml:lang="en" xml:id="en_130">This element defines a tag that is used for sorting and is a component in the formation of an mean value. The attributes of the tag define which tag in the XML tree is referenced.</xs:documentation>
																			</xs:annotation>
																		</xs:element>
																	</xs:choice>
																</xs:sequence>
															</xs:complexType>
														</xs:element>
													</xs:choice>
													<xs:attribute name="Order" type="OrderEnum" default="Ascending">
														<xs:annotation>
															<xs:documentation xml:lang="de" xml:id="de_132">Dieses Attribut gibt an, ob ein Sort-Element aufsteigend  oder absteigend sortiert werden soll.</xs:documentation>
															<xs:documentation xml:lang="en" xml:id="en_132">This attribute specifies whether a sort element is to be sorted in ascending or descending order.</xs:documentation>
														</xs:annotation>
													</xs:attribute>
												</xs:complexType>
											</xs:element>
										</xs:sequence>
									</xs:complexType>
								</xs:element>
							</xs:sequence>
							<xs:attribute name="Name" type="NameType" use="required">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_133">Dieses Attribut definiert, mit welchem
										Namen die GroupDefinition in einem GroupFilter referenziert
										werden kann.</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_133">This attribute defines the names that can be used to reference the GroupDefinition in a GroupFilter.</xs:documentation>
								</xs:annotation>
							</xs:attribute>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GenericTagType">
		<xs:choice>
			<xs:element name="SortedCandidateGroup" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8850">Die SortedCandidateGroup definiert eine Gruppierung von Angebots-Kandidaten, die in eine bestimmte Reihenfolge gebracht werden. Jedes Angebot erhält als GenericTag-Value seine eigene Position innerhalb der sortierten Angebotsgruppe. Die Auswertung der Funktion findet erst nach der Auswertung der Verfügbarkeit und nach Abschluss der Preisberechnung statt. Bis dahin gilt der Value der Funktion als "Undefined". Eine GenericTag-Bedingung auf ein GenericTag darf nur innerhalb von Product benutzt werden. In allen anderen Fällen wird die Bedingung automatisch als "Undefined" ausgewertet.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8850">The SortedCandidateGroup defines a group of offer candidates that shall be brought to a specific order. Each offer is assigned its position within the sorted offer group as GenericTag-Value. The evaluation of the function takes place only after the availability  check and after the price calculation is completed. Until then the value of the function is set as "Undefined". A GenericTag-condition on a GenericTag may only be used within Product. In all other cases the condition automatically is interpreted as "Undefined".</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="GroupedByEqual" internal:otdsversion="1.9 2.0">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_487">Die Angaben in GroupedByEqual definieren, über welche Parameter die Angebote gruppiert werden. 
Mit CandidateInstance-Elementen definiert man welche Unterkomponenten identisch sein müssen.		
Mit Tag-Elementen definiert man, dass die Gruppe nur aus Offerkandidaten besteht, bei denen diese Tags identische Values besitzen.
Der CheckIn- und CheckOuttermin der gruppierten Offerkandidaten muss auch übereinstimmen.
Seid Version 2.0 können die betrachteten CheckIn- und CheckOuttermine der referenzierten Unterkomponenten explizit definiert werden. 
Die häufigste Verwendung wird sein, dass eine Gruppierung der Returnflüge über Abflughafen, Zielflughafen, Termin und Dauer erfolgt.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_487">The entries in GroupedByEqual define by what parameters the offers should be grouped. By CandidateInstance elements you define, which subcomponents need to be identical. 
								
By Tag elements you define, that the group contains only from those offer candidates, which have the same tag value at the indicated tags. 
Also the CheckIn and CheckOut date of the grouped offer candidates need to be identical.
Since version 2.0 it is possible to explicitly define which CheckIn- und CheckOut dates need to be considered. 
The most common use is that return flights are grouped by departure airport, destination airport, departure date and time, and duration.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence maxOccurs="unbounded">
									<xs:choice>
										<xs:element name="CandidateInstance">
											<xs:annotation>
												<xs:documentation xml:lang="de" xml:id="de_8851">Die Angebote werden gruppiert, so dass alle Angebotskandidaten der Gruppe identische durch CandidateInstance/@Source definierte Unterkomponenten besitzen.
Die Rahmenparameter bzgl. CheckIn- und CheckOut-Terminen müssen ohenhin identisch sein.</xs:documentation>
												<xs:documentation xml:lang="en" xml:id="en_8851">The offers are grouped in a way, that all offer candidates of the group have identical sub-components defined by the CandidateInstance/@Source. The framing parameters regarding CheckIn- and CheckOut-dates have to be identical anyway.</xs:documentation>
											</xs:annotation>
											<xs:complexType>
												<xs:attribute name="Source" type="SourceAttributeType" use="required">
													<xs:annotation>
														<xs:documentation xml:lang="de" xml:id="de_8852">Dieses Attribut definiert eine Referenz auf bestimmte Candidate Instance.</xs:documentation>
														<xs:documentation xml:lang="en" xml:id="en_8852">This attribute defines a reference to a certain Candidate Instance.</xs:documentation>
													</xs:annotation>
												</xs:attribute>
											</xs:complexType>
										</xs:element>
										<xs:element name="Airport">
											<xs:annotation>
												<xs:documentation xml:lang="de" xml:id="de_8853">Die Angebote werden gruppiert, so dass Angebotskandidaten der Gruppe identische Values bzgl. des hier definierten Airports besitzen.</xs:documentation>
												<xs:documentation xml:lang="en" xml:id="en_8853">The offers are grouped in a way, that the offer candidates of the groups have identical values regarding the airport defined here.</xs:documentation>
											</xs:annotation>
											<xs:complexType>
												<xs:attribute name="Source" type="SourceAttributeType" use="required">
													<xs:annotation>
														<xs:documentation xml:lang="de" xml:id="de_8854">Dieses Attribut definiert eine Referenz auf eine bestimmte Candidate Instance, in der der Airport betrachtet werden soll.</xs:documentation>
														<xs:documentation xml:lang="en" xml:id="en_8854">This attribute defines a reference to a certain Candidate Instance, in which the airport is subject.</xs:documentation>
													</xs:annotation>
												</xs:attribute>
												<xs:attribute name="AirportType" type="AirportTypeEnum" use="required">
													<xs:annotation>
														<xs:documentation xml:lang="de" xml:id="de_8855">Dieses Attribut definiert, welcher Airporttype betrachtet werden soll.</xs:documentation>
														<xs:documentation xml:lang="en" xml:id="en_8855">This attribute defines which airport type shall be considered.</xs:documentation>
													</xs:annotation>
												</xs:attribute>
											</xs:complexType>
										</xs:element>
										<xs:element name="Tag" type="EmptyTagGroupedByEqualType">
											<xs:annotation>
												<xs:documentation xml:lang="de" xml:id="de_488">Dieses Element adressiert ein bestimmtes Tag innerhalb des Angebotskontextes. Die Gruppierung erfolgt über das hier referenzierte Tag. Das bedeutet, alle Elemente einer Gruppe haben bzgl. des hier adressierten Tags den gleichen Tag-Value.
Sonderfall: Sollte die Adressierung des Tags bzgl. Source nicht eindeutig sein, so erfolgt die Gruppierung über identische in XML-DocumentOrder sortierte Tag-Tuple. 
</xs:documentation>
												<xs:documentation xml:lang="en" xml:id="en_488">This element addresses a certain tag within the offer context. The grouping is done via the tag referenced here. That means that all elements of a group referring to the tag addressed here have the same tag value.
Special case: If the addressing of the tag is not distinct relating to Source, the grouping will take place via identical tag-tuples sorted in XML DocumentOrder.</xs:documentation>
											</xs:annotation>
										</xs:element>
										<xs:element name="GroupStartDate" type="GroupStartDateType" minOccurs="0" internal:otdsversion="2.0">
											<xs:annotation>
												<xs:documentation xml:lang="de" xml:id="de_8856">Dieses Element definiert ein vom Defaultverhalten abweichendes StartDate der Gruppierung. Der Default richtet sich nach den beschriebenen Defaults der in diesem Element enthaltenen Attribute.</xs:documentation>
												<xs:documentation xml:lang="en" xml:id="en_8856">This element defines a StartDate of the grouping that deviates from the default behavior. The default complies with the described defaults of the attributes contained in this element.</xs:documentation>
											</xs:annotation>
										</xs:element>
										<xs:element name="GroupEndDate" type="GroupEndDateType" minOccurs="0" internal:otdsversion="2.0">
											<xs:annotation>
												<xs:documentation xml:lang="de" xml:id="de_8857">Dieses Element definiert ein vom Defaultverhalten abweichendes EndDate der Gruppierung. Der Default richtet sich nach den beschriebenen Defaults der in diesem Element enthaltenen Attribute.</xs:documentation>
												<xs:documentation xml:lang="en" xml:id="en_8857">This element defines a EndDate of the grouping that deviates from the default behavior. The default complies with the described defaults of the attributes contained in this element.</xs:documentation>
											</xs:annotation>
										</xs:element>
									</xs:choice>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="Value">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Position">
										<xs:complexType>
											<xs:sequence>
												<xs:element name="Sequence">
													<xs:annotation>
														<xs:documentation xml:lang="de" xml:id="de_490">Unter diesem Element wird die
												Reihenfolge der einzelnen Elemente der Gruppe definiert. Die Reihenfolge der Sort-Elemente im
												XML geben auch die Rangfolge der Abarbeitung der Sortierkriterien an. So kann man nach mehreren
												Kriterien nacheinander aufwärts oder abwärts sortieren, wie man es zum Beispiel aus MS-Excel kennt.</xs:documentation>
														<xs:documentation xml:lang="en" xml:id="en_490">The order of individual elements in a group is defined under this element. The order of the sort elements in the XML also indicates the processing rank order of the sort criteria. They can be filtered in ascending or descending order by various criteria, as you may already know from Microsoft Excel.</xs:documentation>
													</xs:annotation>
													<xs:complexType>
														<xs:sequence>
															<xs:element name="Sort" maxOccurs="unbounded">
																<xs:annotation>
																	<xs:documentation xml:lang="de" xml:id="de_491">Jedes Sort Element enthält eine Anzahl von Kriterien, nach denen aufwärts oder abwärts sortiert werden soll. Es wird zuerst nach dem ersten Sort-Element sortiert, danach bei Gleichheit nach dem nächsten Sort-Element. Das Attribut "Order" gibt an, ob aufwärts oder abwärts sortiert werden soll. Mit "Sum" und "Average" können einzelne Sortierkriterien auch vor der Sortierung zusammengefasst werden.</xs:documentation>
																	<xs:documentation xml:lang="en" xml:id="en_491">Each Sort element contains a number of criteria by which you can sort in ascending or descending order. First of all it will be sorted by the first Sort element, then by the next element if the first element is the same value. The "Order" attribute indicates whether the elements are to be sorted in ascending or descending order. With "Add" and "Average" individual sort criteria can also be added before the sorting takes place.</xs:documentation>
																</xs:annotation>
																<xs:complexType>
																	<xs:choice>
																		<xs:element name="Sum" internal:otdsversion="1.9">
																			<xs:annotation>
																				<xs:documentation xml:lang="de" xml:id="de_511">In diesem Element können mehrere Elemente zu einer Summe zusammengeführt werden. Die Elemente müssen dabei zueinander passen. Dass heißt, das Element 'Price' kann immer nur mit Tags des TagTypes "Price" auftreten. Und Tags des TagType="Numeric" können nur mit anderen Tags des TagType="Numeric" auftreten. Das erste ChildElement (laut XML-Order) des Elementes "Sum" gibt den geforderten TagType vor. Kommen danach Elemente oder Tags, die nicht zum geforderten TagType passen, so werden diese in die Summe mit dem Wert 0 integriert.</xs:documentation>
																				<xs:documentation xml:lang="en" xml:id="en_511">In this element, a number of elements are combined to form a sum. The elements must be compatible. That is, the element 'Price' can only occur with tags of the TagType "Price". And tags of the TagType="Numeric" can only occur with other tags of the TagType="Numeric". The first ChildElement (according to XML order) of the element "Sum" determines the required TagType. 
Following elements or tags that do not match the required TagType, will be integrated into the sum with the value 0.</xs:documentation>
																			</xs:annotation>
																			<xs:complexType>
																				<xs:sequence maxOccurs="unbounded">
																					<xs:choice>
																						<xs:element name="Price" type="SortPriceType">
																							<xs:annotation>
																								<xs:documentation xml:lang="de" xml:id="de_492">Dieses Element referenziert eine Menge von PriceItems. Zur Berechnung der Summe, die zur Sortierung benutzt wird, werden nur die PriceItems herangezogen, die bezogen auf die Platzierung der GroupDefinition an einem Ancestor-Knoten oder einem Descendant-Knoten hängen und für das gerade betrachtete Angebot gültig sind. Über die Source kann die Verwendung von PriceItems auf bestimmte Komponenten oder SubKomponenten eingeschränkt werden. Dazu wurde extra eingeführt, dass die Source auch Descendants und Ancestors referenzieren kann. Schauen Sie dazu in der Doku unter dem Begriff "Source-Hierarchy".</xs:documentation>
																								<xs:documentation xml:lang="en" xml:id="en_492">This element defines a number of PriceItems. For the calculation of the sum, which is used for sorting only PriceItems attached to an ancestor node or descendant node within the GroupDefinition list, and those valid for the offer currently being viewed, are used. Via Source the use of PriceItems can be limited for specific Components or SubComponents. For doing so the possibility for Source to reference descendants and ancestors has been introduced. 
For more details please refer to the documentation and look for "Source-Hierarchy".</xs:documentation>
																							</xs:annotation>
																						</xs:element>
																						<xs:element name="Tag" type="EmptyTagConditionType">
																							<xs:annotation>
																								<xs:documentation xml:lang="de" xml:id="de_493">Dieses Element referenziert ein Tag oder eine Menge von Tags, welche zur Sortierung herangezogen werden und Bestandteil einer Summenbildung sind. In der Summe sind nur Tags der Typen Numeric oder Price erlaubt. String-Tags führen zu ungültigen Ergebnissen der Summe. Die Attribute des Tags definieren, welche Tags im XML-Baum referenziert werden. </xs:documentation>
																								<xs:documentation xml:lang="en" xml:id="en_493">This element references a tag or several tags, which is/are used for sorting and forms a component of a sum. Within the sum only the tags Numeric or Price are permitted. String-tags lead to invalid results of the sum. The attributes of the tag define which tags in the XML tree are referenced.</xs:documentation>
																							</xs:annotation>
																						</xs:element>
																					</xs:choice>
																				</xs:sequence>
																			</xs:complexType>
																		</xs:element>
																		<xs:element name="Concatenate" internal:otdsversion="1.9">
																			<xs:annotation>
																				<xs:documentation xml:lang="de" xml:id="de_494">Dieses Element definiert, dass mehrere Tags des TagTypes ="String" zu einem String zusammengeführt werden und dann eine lexikalische Sortierung nach diesem String erfolgt. Alle Elemente müssen dem TagType="String" entsprechen. Die Values der referenzierten Tags werden in der unter Element "Concatenate" aufgeführten XML-Order aneinandergefügt.
Entspricht ein Tag nicht dem TagType="String", so wird es mit dem Wert "" (leerer String) in die Zeichenkette eingefügt. Werden bzgl. einer Tag-Referenz mehrere Tags im Angebotsbaum gefunden, so bestimmt die XML-Order des Angebotsbaum die Reihenfolge, in der die Tag-Values aneinandergefügt werden. 
Es gilt die folgende generell in OTDS festgelegte Definition für Zeichenketten-Sortierungen: Zeichenketten werden grundsätzlich mit dem linken Zeichen beginnend Zeichen für Zeichen sortiert, wobei das erste Zeichen die höchste Priorität besitzt. Die Sortierung folgt den ASCII-Values der Zeichen und entspricht damit folgender aufsteigenden Liste: - . 0 1 2 3 usw. A B C usw. _ a b c usw. |
												~</xs:documentation>
																				<xs:documentation xml:lang="en" xml:id="en_494">This element defines that multiple tags of the tag type = "String" will merge into a single string and then be sorted lexically. All elements must have the tag type ="String". The values ​​of the referenced tags are combined in the XML order listed in the "Concatenate" element. 
If the tag does not correspond to the TagType="String"  it will be inserted into the string with the value "" (empty string). If referring to a tag reference several tags are being found in the offer tree, the XML order of the offer tree determines the order in which the tag values are being combined. The following definition generally established in OTDS for character string sorting applies: 
Character strings are generally sorted character by character, beginning with the character on the left, whereby the first character has the highest priority. The sorting follows the ASCII values of characters and corresponds to the following list in ascending order: - . 0 1 2 3 etc. A B C etc. _ a b c etc. |
												~</xs:documentation>
																			</xs:annotation>
																			<xs:complexType>
																				<xs:sequence maxOccurs="unbounded">
																					<xs:element name="Tag">
																						<xs:annotation>
																							<xs:documentation xml:lang="de" xml:id="de_495">Dieses Element definiert ein 						Tag, welches zur Sortierung herangezogen wird und Bestandteil einer zusammengesetzten Zeichenkette ist. Die Attribute des Tags definieren, welches Tag im XML-Baum referenziert wird. </xs:documentation>
																							<xs:documentation xml:lang="en" xml:id="en_495">This element defines a tag which is used for sorting and is component of a composed character string. The attributes of the tag define which tag in the XML tree is referenced.</xs:documentation>
																						</xs:annotation>
																						<xs:complexType>
																							<xs:complexContent>
																								<xs:extension base="EmptyTagConditionType">
																									<xs:attribute name="Padding" default=" ">
																										<xs:annotation>
																											<xs:documentation xml:lang="de" xml:id="de_8858">Padding - Legt das Zeichen fest, mit dem der  Einzelvalue des Tags vor der Connection aufgefüllt wird. Vorgabe ist das Leerzeichen.</xs:documentation>
																											<xs:documentation xml:lang="en" xml:id="en_8858">Padding - Determines the character with which the tag's single value before the Connection is filled up. Default is a space.</xs:documentation>
																										</xs:annotation>
																										<xs:simpleType>
																											<xs:restriction base="xs:string">
																												<xs:maxLength value="1"/>
																											</xs:restriction>
																										</xs:simpleType>
																									</xs:attribute>
																									<xs:attribute name="PadLength" default="0">
																										<xs:annotation>
																											<xs:documentation xml:lang="de" xml:id="de_8859">Dieses Attribut definiert, dass der Einzelvalue des Tags vor der Connection mit dem in Attribut "Padding" definierten Zeichen aufgefüllt wird. Ist der Value schon länger als PadLength, wird kein Padding vorgenommen. Default ist 0. Das Padding erfolgt vor der Zeichenkette.</xs:documentation>
																											<xs:documentation xml:lang="en" xml:id="en_8859">This attribute determines, that the tag's single value before the Connection is filled up with the character defined within the attribute "Padding". In case the value already is longer than PadLength, Padding is not executed. Default is 0. The Padding takes place before the character string.</xs:documentation>
																										</xs:annotation>
																										<xs:simpleType>
																											<xs:restriction base="xs:integer"/>
																										</xs:simpleType>
																									</xs:attribute>
																								</xs:extension>
																							</xs:complexContent>
																						</xs:complexType>
																					</xs:element>
																				</xs:sequence>
																				<xs:attribute name="Padding" default=" ">
																					<xs:annotation>
																						<xs:documentation xml:lang="de" xml:id="de_8860">Padding - Legt das Zeichen fest, mit dem der Ergebniswert nach der Connection aufgefüllt wird. Vorgabe ist das Leerzeichen.</xs:documentation>
																						<xs:documentation xml:lang="en" xml:id="en_8860">Padding - Determines the character with which the result value after the Connection is filled up. Default is a space.</xs:documentation>
																					</xs:annotation>
																					<xs:simpleType>
																						<xs:restriction base="xs:string">
																							<xs:maxLength value="1"/>
																						</xs:restriction>
																					</xs:simpleType>
																				</xs:attribute>
																				<xs:attribute name="PadLength" default="0">
																					<xs:annotation>
																						<xs:documentation xml:lang="de" xml:id="de_8861">Dieses Attribut definiert, dass der Ergebniswert nach der Connection mit dem in Attribut "Padding" definierten Zeichen aufgefüllt wird. Ist der Parameter schon länger als PadLength, wird kein Padding vorgenommen. Default ist 0. Das Padding erfolgt vor der Zeichenkette.</xs:documentation>
																						<xs:documentation xml:lang="en" xml:id="en_8861">This attribute determines, that the result value after the Connection is filled up with the character defined within the attribute "Padding". In case the value already is longer than PadLength, Padding is not executed. Default is 0. The Padding takes place before the character string.</xs:documentation>
																					</xs:annotation>
																					<xs:simpleType>
																						<xs:restriction base="xs:integer">
																							<xs:minInclusive value="0"/>
																						</xs:restriction>
																					</xs:simpleType>
																				</xs:attribute>
																			</xs:complexType>
																		</xs:element>
																		<xs:element name="Average" internal:otdsversion="1.9">
																			<xs:annotation>
																				<xs:documentation xml:lang="de" xml:id="de_496">Dieses Element definiert, dass zwischen den Values der referenzierten Tags und ggf. einem Preis ein Mittelwert ermittelt wird und der so entstehende Mittelwert zur Sortierung herangezogen wird. Die Elemente müssen dabei zueinander passen. Dass heißt, das Element 'Price' kann immer nur mit Tags des TagTypes "Price" auftreten. Und Tags des TagType="Numeric" können nur mit anderen Tags des TagType="Numeric" auftreten. Das erste ChildElement (laut XML-Order) des Elementes "Average" gibt den geforderten TagType vor. Kommen danach Elemente oder Tags, die nicht zum geforderten TagType passen, so werden diese nicht in die Bildung des Mittelwertes einbezogen. In der Umsetzung reicht nicht, dass der Wert = 0 gesetzt wird, da ansonsten der Mittelwert beeinflusst wird.</xs:documentation>
																				<xs:documentation xml:lang="en" xml:id="en_496">This element defines that a mean
value is determined within the values of the tags referenced, and if necessary also the prices, and the resulting mean value is to be used for sorting. The elements must be compatible. That is, the element 'Price' can only occur within the "Price" tag types. And tags of the TagType="Numeric" can only appear with other tags of the TagType="Numeric". The first child element (according to XML order) of the "Average" element specifies the required TagType. Elements or tags that do not match the required TagType are not included in the calculation of the mean value. The value cannot be set to 0 as this will affect the calculation of the mean value.</xs:documentation>
																			</xs:annotation>
																			<xs:complexType>
																				<xs:sequence maxOccurs="unbounded">
																					<xs:choice>
																						<xs:element name="Price" type="SortPriceType">
																							<xs:annotation>
																								<xs:documentation xml:lang="de" xml:id="de_497">Dieses Element definiert ein Tag, welches zur Sortierung herangezogen wird und Bestandteil einer Mittelwertbildung ist. Zur Berechnung des Sortierungspreises werden nur die PriceItems herangezogen, die bezogen auf die Platzierung der GroupDefinition an einem Ancestor-Knoten oder einem Descendant-Knoten hängen und für das gerade betrachtete Angebot gültig sind.</xs:documentation>
																								<xs:documentation xml:lang="en" xml:id="en_497">This element defines a tag which is used for sorting and is a component in the formation of a mean value. To calculate the sorting price, only PriceItems attached to an ancestor node or descendant node within the GroupDefinition list, and those valid for the offer currently being viewed, are used.</xs:documentation>
																							</xs:annotation>
																						</xs:element>
																						<xs:element name="Tag" type="EmptyTagConditionType">
																							<xs:annotation>
																								<xs:documentation xml:lang="de" xml:id="de_498">Dieses Element definiert ein Tag, welches zur Sortierung herangezogen wird und Bestandteil einer Mittelwertbildung ist. 
Die Attribute des Tags definieren, welches Tag im XML-Baum referenziert wird. </xs:documentation>
																								<xs:documentation xml:lang="en" xml:id="en_498">This element defines a tag which is used for sorting and is component of building a mean value. The attributes of the tag define which tag in the XML tree is referenced.</xs:documentation>
																							</xs:annotation>
																						</xs:element>
																					</xs:choice>
																				</xs:sequence>
																			</xs:complexType>
																		</xs:element>
																	</xs:choice>
																	<xs:attribute name="Order" type="OrderEnum" default="Ascending">
																		<xs:annotation>
																			<xs:documentation xml:lang="de" xml:id="de_499">Dieses Attribut gibt an, ob ein Sort-Element aufsteigend  oder absteigend sortiert werden soll.</xs:documentation>
																			<xs:documentation xml:lang="en" xml:id="en_499">This attribute specifies whether a sort element is to be sorted in ascending or descending order.</xs:documentation>
																		</xs:annotation>
																	</xs:attribute>
																</xs:complexType>
															</xs:element>
														</xs:sequence>
													</xs:complexType>
												</xs:element>
											</xs:sequence>
										</xs:complexType>
									</xs:element>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:choice>
		<xs:attributeGroup ref="TagAttributeGroup"/>
	</xs:complexType>
	<xs:complexType name="SortPriceType">
		<xs:sequence>
			<xs:element name="ConsideredPriceItems" type="ConsideredPriceItemsType" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8862">Beschränkt die zu berücksichtigenden PriceItems auf bestimmte Menge von PriceItems 
eines bestimmten Types und/oder mit bestimmten PriceTags oder PriceClasses. Je Element "ConsideredPriceItems" wird eine Menge von PriceItems definiert.
Bei mehrfacher Angabe des Elementes werden die einzelnen Mengen ver-ODER-ert.
Es findet keine Duplizierung von PriceItems statt. 
Falls ConsideredPriceItems kein Unterelement enthält, so werden alle PriceItems gemäß der Angaben in den Attributen "Source" und "ConsideredPriceItemType" berücksichtigt.

Die Definition der Ergebnismenge eines Elementes "ConsideredPriceItems" erfolgt in der folgenden Reihenfolge: 
1. Auswahl der PriceItems gemäß der Attribute "Source" und "ConsideredPriceItemType"	
2. Einschränkung der Auswahl der PreisItems auf bestimmte PriceClasses und PriceTags. Bei der Angabe mehrerer Unterelemente werden die einzelnen Einschränkungen bzgl. Tags und Classes ver-UND-et.
3. Ergänzung der IncludedDescendants. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8862">Restricts the PriceItems that need to be considered to a specific numer of PriceItems of a specific type and/or with specific PriceTags or PriceClasses. For each element "ConsideredPriceItems" a numer of PriceItems is defined. If the element is indicated several times the single numbers are connected with OR. 
There is no duplication of PriceItems.
In the case that ConsideredPriceItems contains no sub-element, all PriceItems are considered according to the information in the attributes "Source" and "ConsideredPriceItemType".
The definition of the result set of an element "ConsideredPriceItems" takes place in the following order:
1. selection of the PriceItems according to the attributes "Source" and "ConsideredPriceItemType".
2. Restriction of the selection of PriceItems to specific PriceClasses and PriceTags. When more than one sub-element is stated, the restrictions regarding Tags and Classes are connected with AND.
3. Complementation of the IncludedDescendants.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="EmptyPriceTagReferenceType">
		<xs:simpleContent>
			<xs:extension base="EmptyElementType">
				<xs:attributeGroup ref="SourceAttributeGroup"/>
				<xs:attributeGroup ref="TagAttributeGroup"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="ApplyToPriceTagsType">
		<xs:simpleContent>
			<xs:extension base="PriceTagsApplyType">
				<xs:attribute name="Include" type="IncludeAttributeEnum">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8863">Mit Include="ApplyDescendants" können weitere PriceItems inkludiert werden, die von den adressierten PriceItems angewendet werden. So kann man bestimmte PercentPriceItems zuordnen und zusätzlich alle PriceItems inkludieren, die sich über ApplyTo und AppliedBy auf dieses PriceItem beziehen. Dieses Attribut berücksichtigt nur eine Apply-Hierarchie!
Sollte ein Bezug auf ein generisches Abolute hergestellt werden, so wird hierbei dessen Include nicht mit berücksichtigt.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8863">Include="ApplyDescendants" allows to include further PriceItems which are applied by the addressed PriceItems. By doing so specific PercentPriceItems can be assigned. In addition all PriceItems can be included that refer to this specific PriceItem via ApplyTo and AppliedBy. This attribute only considers one apply hierarchy!
If a reference to a generic absolute is being established, its Include will not be considered.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="ConsideredPriceTagsReferenceType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_8864">Der TagConditionType definiert die Bedingung an bestimmte Tags inklusive Angabe der Class, Location und Werte des Tags. Tags sind Wertepaare, die an definierten Knotenpunkten angegeben werden können. Dadurch kann man Einfluss nehmen auf die
Angebotserstellung und auch auf die Preisberechnung.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_8864">The TagConditionType determines the condition on specific tags including the indication of the Class, Location and Values of the tag.
Tags are pairs of values that can be indicated at defined node points. In doing so one can influence the offer building as well as the price calculation.</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="BaseTagTypeList">
				<xs:attributeGroup ref="TagAttributeGroup"/>
				<xs:attributeGroup ref="TagReferenceAttributeGroup"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="NeighbourComponentCorrectionType">
		<xs:complexContent>
			<xs:extension base="SimpleUpdateNodeType">
				<xs:sequence>
					<xs:element name="CheckInDateOffset" type="CheckInOutOffsetType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_279">Mit diesem Element wird definiert, welche Überschneidung das Ende der vorhergehenden Komponente mit dem Anfang dieser Komponente hat. Der Offset ist abhängig vom angrenzenden Komponententyp. Dieser wird durch das Attribut "Component" definiert. Der Endtermin der vorhergehenden Komponente bestimmt sich aus dem Anfangstermin dieser Komponente und dem CheckInOffset. Falls CheckInOffset nicht gesetzt ist, so gilt der Defaultwert, also CheckInOffset=0. Aktuell kennen wir dieses Szenario nur bei Flügen und vorhergehenden Unterkünften. Bei sehr früh morgens abfliegenden Flügen aus dem Zielgebiet kann es sein, dass ggf. eine Nacht früher aus dem Hotel ausgecheckt werden muss.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_279">This element is used to define the overlap of the end of the previous component and the start of the current component. The offset depends on the adjacent component type. This is defined by the "ComponentType" attribute. The end date of the
previous component is determined by the start date of this component + the CheckInOffset. If CheckInOffset is not set, then a default value will be used, thus CheckInOffset = 0. Currently this scenario is known only for flights and preceding accommodation. With very early morning flights departing from the destination, it may be necessary to check out a night earlier from the hotel. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="CheckOutDateOffset" type="CheckInOutOffsetType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_280">Mit diesem Element wird definiert, welche Überschneidung der Anfang der angrenzenden nachfolgenden Komponente mit dem Ende dieser Komponente hat. Der Offset ist abhängig vom angrenzenden Komponententyp. Dieser wird durch das Attribut "Component" definiert. Der Anfangstermin der angrenzenden Komponente bestimmt sich aus dem Endtermin dieser Komponente und dem CheckOutOffset. Falls CheckOutOffset nicht gesetzt ist, so gilt der Defaultwert, also CheckOutOffset=0. Aktuell kennen wir dieses Szenario nur bei Flügen und nachfolgenden Unterkünften. Bei sehr früh morgens im Zielgebiet ankommenden Flügen kann es vorkommen, dass ggf. eine Nacht früher im Hotel eingecheckt werden muss.
</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_280">This element is used to define an overlap between the beginning of the adjacent component and the end of the current component. The offset depends on the adjacent component type. This is defined by the "ComponentType" attribute. The start date of the adjacent component is determined by the closing date of this component + the CheckOutOffset. If CheckOutOffset is not set, then a default value will be used. Thus CheckOutOffset=0. Currently, we know of this scenario only in relation to flights and subsequent accommodation. With very early morning flights arriving in the destination, it may be necessary to check in a night earlier to the hotel. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Condition" minOccurs="0" internal:otdsversion="2.0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_358">In diesem Element werden die Regeln zur Verwendung der NeigbourComponentCorrection definiert. 
Bedingungen mit ExecutionOrder="AfterCombinatorics" oder "Last" werden als undefined ausgewertet. Es findet keine erneute Auswertung zu einem späteren Zeitpunkt statt. Die Auswertung der Impact-Bedingungen erfolgt so, als wenn die ganze Condition durch ein "NonImpact"-Element umschlossen wäre.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_358">In this element the rules for applying the NeigbourComponentCorrection are defined. Conditions with ExecutionOrder="AfterCombinatorics" or "Last" are evaluated as undefined. There will be no other evalutation at any later time. The evaluation of the Impact conditions takes places as if the entire Condition was embedded within a "NonImpact"-element.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="ConditionType"/>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IncludeAppliedDescendantsType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_8865">Ist dieses Element angegeben, werden zu den in PriceItemCollection definierten PriceItems auch deren Descendants ergänzt. Descendants sind in dem Zusammenhang alle PriceItems, die durch ApplyTo und AppliedBy der PriceItemCollection-PriceItems adressiert werden. So kann man in der Collection bestimmte PercentPriceItems auswählen und zusätzlich alle PriceItems inkludieren, die sich über ApplyTo und AppliedBy auf dieses PriceItem beziehen. Die Auswahl der Descendants lässt sich wiederum durch den PriceItemFilter separat einschränken. Bei der Auswahl der Descendants wird nur Apply-Hierarchie berücksichtigt! 
Sollte ein Bezug auf ein generisches Absolute hergestellt werden, so wird hierbei dessen Include nicht mitberücksichtigt.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_8865">In case this element is indicated, the descendants of PriceItems defined in PriceItemCollection 
are complemented to those. Descendants in this respect are all PriceItems that can be addressed by ApplyTo and AppliedBy of the  PriceItemCollection-PriceItems. Hence one can choose specific PercentPriceItems in the collection and additionally include all PriceItems that refer to this PriceItem via ApplyTo and AppliedBy. The selection of the descendants can be in turn restricted separately by the PriceItemFilter. For the selection of the descendants only the Apply hierarchy is considered! 
If a reference to a generic Absolute is constructed, its Include will not be considered.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:group ref="PriceItemFilterGroup" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8866">Ist keine PriceItemFilterGroup angegeben, so findet keine Einschränkung der PriceItems statt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8866">If no PriceItemFilterGroup is indicated, there will be no restriction of the PriceItems.</xs:documentation>
				</xs:annotation>
			</xs:group>
		</xs:sequence>
	</xs:complexType>
	<!--Begin of  property definition-->
	<xs:complexType name="PropertiesWithoutNodeType">
		<xs:group ref="PropertiesWithoutNodeGroup"/>
	</xs:complexType>
	<xs:group name="PropertiesWithoutNodeGroup">
		<xs:sequence>
			<xs:element name="PropertyGroup" type="PropertyGroupType" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:group>
	<xs:complexType name="PropertiesType">
		<xs:complexContent>
			<xs:extension base="OptionalMultipleSimpleUpdateNodeType">
				<xs:group ref="PropertiesWithoutNodeGroup"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PropertyGroupType">
		<xs:sequence>
			<xs:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_138">An dieser Stelle können Elemente und Strukturen aus Namespaces zu Eigenschaften integriert werden. Es sind nur die in OTDS definierten Namespaces an dieser Stelle zugelassen. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_138">At this point, elements and structures consisting of Namespaces can be integrated into properties. Only Namespaces defined in OTDS are permitted at this stage.</xs:documentation>
				</xs:annotation>
			</xs:any>
			<xs:element name="OtdsUnboundedProperties" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_139">Unter diesem Element können Elemente und Strukturen aus Namespaces zu Eigenschaften integriert werden. Hier sollten nur Namespaces verwendet werden, die OTDS nicht bekannt sind. Die Auswertung der integrierten Elemente ist nur in Absprache mit dem Datenlieferanten vorgesehen und erlaubt eine individuelle Interpretation von individuellen Inhalten. Eine Validierung aller Elemente unterhalb dieses Knotens ist im Rahmen von OTDS nicht vorgesehen. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_139">Under this element, structures and elements of Namespaces can be integrated into properties. Only Namespaces may be used here that are not known to OTDS. The evaluation of the integrated elements is only in agreement with the data suppliers and allows for individual interpretation of individual content. A validation of all elements below this node is not provided in the context of OTDS.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_140">An dieser Stelle können beliebige Elemente und Strukturen aus Namespaces zu Eigenschaften integriert werden. Hier sollten nur Namespaces verwendet werden, die OTDS nicht bekannt sind. Die Auswertung der integrierten Elemente ist nur in Absprache mit dem Datenlieferanten vorgesehen und erlaubt eine individuelle Interpretation von individuellen Inhalten. Eine Validierung aller Elemente unterhalb dieses Knotens ist im Rahmen von OTDS nicht vorgesehen. </xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_140">At this point, any structures and elements from Namespaces are integrated into properties. Only Namespaces may be used here that are not known to OTDS. The evaluation of the integrated elements is only in agreement with the data suppliers and allows for individual interpretation of individual content. A validation of all elements below this node is not provided in the context of OTDS.</xs:documentation>
							</xs:annotation>
						</xs:any>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="MarketingBrandName" type="LanguageTextType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_141">Enthält den MarketingBrandNamen, unter dem das Angebot verkauft werden soll. In den meisten Fällen entspricht dies dem Veranstaltenamen des Veranstalters. In spezifischen Fällen wird ein Angebot aber unter einer separaten MarketingBrand vertrieben. Beispiel FTI und XFTI. Die Definition des MarketingBrandNames erfolgt in der Regel innerhalb der Brand oder innerhalb des Products. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_141">Contains the MarketingBrandName under which the offer shall be sold. In most cases this name equals the tour operator name of the operator. In specific cases however an offer might be distributed under a separate MarketingBrand, for example FTI and XFTI. The definition of the MarketingBrandNames in general takes place within the Brand or within the Product.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MarketingBrandCode" type="xs:string" minOccurs="0" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8867">Enthält ein Kürzel, welches die MarketingBrand des Angebotes definiert. In den meisten Fällen entspricht der MarketingBrandCode dem Buchungscode des Veranstalters. In spezifischen Fällen wird ein Angebot aber unter einer separaten MarketingBrand vertrieben und trotzdem mit dem Buchungscode des Veranstalters gebucht. Beispiel FTI und XFTI. Die Definition des MarketingBrandCodes erfolgt in der Regel innerhalb der Brand oder innerhalb des Products. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8867">Contains an abbreviation/acronym, which defines the MarketingBrand of the offer. In most cases the MarketingBrand equals the booking code of the tour operator. In specific cases however an offer might be distributed with under a separate MarketingBrand yet at the same time be booked with the booking code of the operator, for example FTI and XFTI. The definition of the MarketingBrand in general takes place within the Brand or within the Product.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AccommodationCity" type="LanguageTextType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8868">Stadt, in der die Unterkunft / das Hotel liegt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8868">Town or city in which the accommodation/hotel is located.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AccommodationCityInfo" type="ContentInfoType" minOccurs="0" internal:otdsversion="2.0"/>
			<xs:element name="AccommodationType" type="AccommodationTypeEnum" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_142">Typ der Unterkunft: 
z.B. Hotel, Club, HolidayPark, HolidayFlat, CaravanSite, Other etc. 
</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_142">Type of accommodation:
e.g. Hotel, Club, HolidayPark, HolidayFlat, CaravanSite, Other, etc.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:group ref="AccommodationPropertyGroup" minOccurs="0"/>
			<xs:element name="AccommodationLocations" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_143">Lage des Objekts: z.B.  DirectBeach, NearBeach, Mountains, SurroundedByNature etc. (Liste mit Space getrennt)</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_143">Location of the establishment:
e.g. DirectBeach, NearBeach, Mountains, SurroundedByNature etc.
etc.
(List separated with space)</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="AccommodationLocationEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="AccommodationAddress" type="AddressType" minOccurs="0"/>
			<xs:element name="AccommodationCatchmentRailwayStations" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_144">Das Element RailwayStation listet alle Bahnhöfe im Zielgebiet auf, über welche das Hotel angefahren werden kann.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_144">The RailwayStation element lists all stations in the target area from which the hotel can be reached.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RailwayStation" type="RailwayStationType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="UnitName" type="LanguageTextType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_145">In dem Attribut Name wird der Unitname in Volltext zur Auszeichnung der Unit angegeben. Der Text sollte kurz sein und ist juristisch bindend. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_145">In the Name attribute the unit name is given in full text to label the unit.
		        The text should be short and is legally binding.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UnitInfo" type="ContentInfoType" minOccurs="0" internal:otdsversion="2.0"/>
			<xs:element name="UnitType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_146">Art der Unit/Unterkunft: 
- Double
- Apartment
- Studio
- Bungalow
- Triple
- Suite
- Other. 
Seit Version 1.1 können in diesem Element auch mehrere UnitTypes durch "Space" getrennt angegeben werden. Die Unit erfüllt damit alle der angegebenen Eigenschaften.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_146">Type of unit / accommodation:
Double
Apartment
Studio
Bungalow
Triple
Suite
Other

Since version 1.1 several UnitTypes can be entered in this element, separated by a space. The unit meets all of the specified properties.
As with other elements which are implemented as a list, in Version V2.0 the element will be renamed in the plural. Thus "UnitType" will become "UnitTypes".</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="UnitTypeEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="UnitFacilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_147">Ausstattungsmerkmale der Unit/Unterkunft</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_147">Facilities of the
						unit/accommodation</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="UnitFacilitiesEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="UnitBedType" minOccurs="0" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_148">Art der Betten in der Unit/Unterkunft</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_148">Types of bed in the
						unit/accommodation</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="UnitBedTypeEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="UnitBuildingType" type="UnitBuildingTypeEnum" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_149">Typ des Hauptgebäudes der Unterkunft</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_149">Type of main building in the accommodation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BoardName" type="LanguageTextType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_150">Unter dem Element Name wird die vollständige Bezeichnung der Verpflegung definiert.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_150">Under the Name element, the full description of
		        the board is defined.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BoardInfo" type="ContentInfoType" minOccurs="0" internal:otdsversion="2.0"/>
			<xs:element name="BoardType" type="BoardTypeEnum" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_151">Art der Verpflegung: 
- SelfCatering
- Breakfast
- HalfBoard
- HalfBoardPlus
- FullBoard
- FullBoardPlus
- AllInclusive
- AllInclusivePlus </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_151">Type of catering:
- SelfCatering
- Breakfast
- HalfBoard
- HalfBoardPlus
- FullBoard
- FullBoardPlus
- AllInclusive
- AllInclusivePlus</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BoardProperties" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_152">Besondere Ausführungen der Verpflegung: 
- Diet
- Vegetarian
- Kosher </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_152">Special board requirements:
- Diet
- Vegetarian
- Kosher</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="BoardPropertiesEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="AddonName" type="LanguageTextType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_153">Unter diesem Element wird die vollständige Bezeichnung des Addons definiert.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_153">Under this element, the full description of the add-ons is defined.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AddonInfo" type="ContentInfoType" minOccurs="0" internal:otdsversion="2.0"/>
			<xs:element name="AddonServiceType" minOccurs="0">
				<xs:complexType>
					<xs:choice>
						<xs:element name="Insurance" type="InsuranceEnum" minOccurs="0" internal:otdsversion="1.9"/>
						<xs:element name="CarRental" type="CarRentalEnum" minOccurs="0"/>
						<xs:element name="WellnessArrangement" type="WellnessArrangementEnum" minOccurs="0"/>
						<xs:element name="SportsArrangement" type="SportsArrangementEnum" minOccurs="0"/>
						<xs:element name="TransferArrangement" type="TransferArrangementEnum" minOccurs="0"/>
						<xs:element name="GolfArrangement" type="GolfArrangementEnum" minOccurs="0"/>
						<xs:element name="DivingArrangement" type="DivingArrangementEnum" minOccurs="0"/>
						<xs:element name="TourArrangement" type="TourArrangementEnum" minOccurs="0"/>
						<xs:element name="HotelArrangement" type="HotelArrangementEnum" minOccurs="0"/>
						<xs:element name="CityArrangement" type="CityArrangementEnum" minOccurs="0"/>
						<xs:element name="BoardArrangement" type="BoardArrangementEnum" minOccurs="0"/>
						<xs:element name="FlightSeatArrangement" type="FlightSeatArrangementEnum" minOccurs="0"/>
					</xs:choice>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddonServiceName" type="LanguageTextType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_154">Unter diesem Element wird die vollständige Bezeichnung des Service definiert.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_154">Under this element, the full description of the service is defined.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AddonServiceInfo" type="ContentInfoType" minOccurs="0" internal:otdsversion="2.0"/>
			<xs:element name="AddonServiceFeatureName" type="LanguageTextType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_155">Unter diesem Element wird die vollständige Bezeichnung der ServiceFeatures definiert.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_155">Under this element, the full description of the ServiceFeatures is defined.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AddonServiceFeatureInfo" type="ContentInfoType" minOccurs="0" internal:otdsversion="2.0"/>
			<xs:element name="AddonCatchmentRailwayStations" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_156">Das Element RailwayStation listet alle Bahnhöfe im Zielgebiet auf, über welche das Hotel angefahren werden kann.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_156">The RailwayStation element lists all stations in the target area from which the hotel can be reached.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RailwayStation" type="RailwayStationType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GeneralIncludedServices" minOccurs="0" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_157">Inkludierte Zusatzleistung können in allen folgenden Properties Zweigen aufgeführt werden.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_157">Add-ons can be included in all of the following Properties branches.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="GeneralIncludedService" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="1.9.1 2.0">
							<xs:complexType>
								<xs:simpleContent>
									<xs:extension base="GeneralIncludedServiceEnum">
										<xs:attribute ref="xml:lang" use="optional" default="de">
											<xs:annotation>
												<xs:documentation xml:lang="de" xml:id="de_9075">In diesem Attribut wird die Sprache nach XML 1.0 innerhalb des Elements angegeben.</xs:documentation>
												<xs:documentation xml:lang="en" xml:id="en_9075">In this attribute the language according to XML 1.0 is indicated within the element.</xs:documentation>
											</xs:annotation>
										</xs:attribute>
										<xs:attribute name="ShortServiceAnnotation" type="ShortServiceAnnotationType"/>
									</xs:extension>
								</xs:simpleContent>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="MandatoryServicesPaidAtLocation" minOccurs="0" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_158">Zusatzleistungen, die obligatorischer Bestandteil des Angebotes sind und zusätzliche Kosten vor Ort verursachen. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_158">Add-ons that incur additional charges to be paid locally.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="MandatoryServicePaidAtLocation" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="1.9.1 2.0">
							<xs:complexType>
								<xs:simpleContent>
									<xs:extension base="MandatoryServicePaidAtLocationEnum">
										<xs:attribute ref="xml:lang" use="optional" default="de">
											<xs:annotation>
												<xs:documentation xml:lang="de" xml:id="de_9076">In diesem Attribut wird die Sprache nach XML 1.0 innerhalb des Elements angegeben.</xs:documentation>
												<xs:documentation xml:lang="en" xml:id="en_9076">I In this attribute the language according to XML 1.0 is indicated within the element.</xs:documentation>
											</xs:annotation>
										</xs:attribute>
										<xs:attribute name="ShortServiceAnnotation" type="ShortServiceAnnotationType" default="None"/>
									</xs:extension>
								</xs:simpleContent>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="FlightBookingClassBaggageAllowances" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_159">In diesem Element werden die Gepäckbestimmungen abgebildet.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_159">In this element, the baggage policy is indicated.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="BaggageAllowance" type="BaggageType" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_160">Definition der Gepäckbestimmungen</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_160">Definition of the baggage policy</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="FlightRoutes" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_161">Beschreibt die Details zur Flugroute. Eine Route definiert dabei entweder ein Segment oder auch eine Zusammenfassung mehrere Segmente. Letztenendes hängt es von der verfügbaren Informationstiefe des Datenlieferanten ab.
Zu beachten: die Routen müssen entsprechend ihrer zeitlichen Reihenfolge des Flugereignis aufgeführt werden, unabhängig davon, ob die Abflugzeiten bekannt sind.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_161">Description of details of the flight route. A route can be defined either as a segment or as a summary of a number of segments. Ultimately this depends on the depth of information made available by the data provider. Note that the routes must be specified in temporal order, irrespective of whether the departure times are known.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="FlightRoute" type="RouteType" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_162">Spezifizierung aller notwendigen Informationen zur Beschreibung der Flug-Route und der Rahmenparameter, wie die Daten zu Abflug und Ankunft (Airport, DateOffset, Time, Terminal), zum Operating und Marketing Carrier (Carrier, Flugnummer), Flugtyp (Main, Feeder, Wrapper), Kabinenklasse (FlightCabinClass), Gesamtreisedauer (ElapsedFlyingTime), Fluggerät (Equipment), StopOvers und Technische Stops.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_162">Specification of all necessary informations to describe the flight route and its parameters, such as the data for departure and arrival (Airport, DateOffset, Time, Terminal), data regarding the Operating and Marketing Carrier (Carrier, Flightnumber), Type of Flight (Main, Feeder, Wrapper), Cabinenclass (FlightCabinClass), Total Flying Time (ElapsedFlyingTime), AirplaneType/Equipment (Equipment), StopOvers and Technical Stops.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="FlightCabinClass" type="FlightCabinClassEnum" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_163">Spezifizierung der Buchungsklasse (z.B. Economy, PremiumEconomy, Business, First)</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_163">Specification of the booking class (e.g. Economy, PremiumEconomy, Business, First)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PriceType" type="PriceTypeEnum" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_164">Spezifizierung eines PriceItems für die Anzeige in Datenbrowsern. Dieser Wert wird ausdrücklich nicht innerhalb der Preisberechung berücksichtigt. (z.B. Base, Board, EarlyBird, ExtraDay, StayPay, ChildReduction, DurationReduction, BoardUpgrade, ChildPrice, OccupancyReduction etc.) Eine vollständige Liste finden Sie in der Technischen Dokumentation.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_164">Specification of PriceItems to be displayed in the browser.
This value is explicitly not included in the price calculation.
(e.g. Base, Board, EarlyBird, ExtraDay, StayPay, ChildReduction, DurationReduction, BoardUpgrade, ChildPrice, OccupancyReduction, etc.)
For the complete list see the technical documentation.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TextInformation" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_165">In diesem Zweig werden buchungsrelevante Nachrichten definiert. Das Attribut "Confirm" gibt an, ob die Nachricht bestätigt werden muss, bevor gebucht werden kann.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_165">In this branch booking-relevant messages are defined. The attribute "Confirm" indicates whether the message must be confirmed before it can be booked.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Text" type="LanguageTextType" maxOccurs="unbounded" internal:otdsversion="2.0"/>
					</xs:sequence>
					<xs:attribute name="ConfirmBeforeBooking" type="IntBooleanType" default="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_166">Dieses Element definiert, ob eine Nachricht vom Kunden bestätigt werden muss, bevor das Angebot gebucht werden kann. ConfirmBeforeBooking=1 besagt, dass eine Bestätigung erforderlich ist. Der Defaultwert ist 0.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_166">This element defines whether a message has to be confirmed by the customer before the offer can be booked.
ConfirmBeforeBooking=1, indicates a confirmation is required.
The default value is 0.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="Display" type="DisplayEnum" default="Search">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_167">Dieses Attribut gibt an, wo die Textinformation angezeigt werden soll.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_167">This attribute specifies where the text information is to be displayed.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element name="Figures" minOccurs="0" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_168">Dieses Element gruppiert weitere Eigenschaften einer Komponente.
Hier werden z.B. Entfernungen zum Strand oder die Anzahl der Schlafzimmer definiert.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_168">This element groups additional properties of a component.
Here, for example, the distance to the beach or the number of bedrooms can be specified.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Figure" type="FigureType" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_169">Das Element Figure beinhaltet alle Eigenschaften, die zusammen mit einer Wertangabe eine Komponente näher beschreiben. Hier werden z.B. Entfernungen zum Strand oder die Anzahl der Schlafzimmer definiert.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_169">The Figure element incorporates all properties that, together with an indication of the value, describe a component in greater detail. Here, for example, the distance to the beach or the number of bedrooms can be specified.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddonCarRentalProperties" type="CarRentalPropertiesType" minOccurs="0" internal:otdsversion="1.9"/>
			<xs:element name="Condition" type="ConditionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_170">Spezifizierung des Preisbestandteils, die keine impliziten Regeln enthalten: (z.B. Base, Board, EarlyBird, ExtraDay, StayPay, ChildReduction, DurationReduction, BoardUpgrade, ChildPrice, OccupancyReduction etc.) Eine vollständige Liste finden Sie in der Technischen Dokumentation.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_170">Specification of the price components, which contain no implicit rules:
(e.g. Base, Board, EarlyBird, ExtraDay, StayPay, ChildReduction, DurationReduction, BoardUpgrade, ChildPrice, OccupancyReduction, etc.)
For the complete list see the technical documentation.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="Priority" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_171">Dieses Attribut bestimmt die Priority der PropertyGroup im Zusammenhang der Auswertung mit anderen PropertyGroups. PropertyGroups mit höherer Priority überschreiben die mit der kleineren Priority.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_171">This attribute specifies the priority of the PropertyGroup in relation to the evaluation of other PropertyGroups. PropertyGroups with a higher priority override ones with a lower priority.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ContentInfoType" internal:otdsversion="2.0">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_9077">nicht-buchbare Zusatzinformationen wie Referenzen, Langtexte und Medialinks</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_9077">non-bookable addon information like references, long descriptions, and media links</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Reference" type="ReferenceTagType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="StructuredText" type="StructuredTextType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="MediaContent" type="ContentLinkType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ReferenceTagType" internal:otdsversion="2.0">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_9066">Das Element Reference beinhaltet alle Verweise, die sich auf externe Referenzsysteme beziehen. Hier werden z.B. Giata-ID eines Hotels oder die Geonames-ID eines Ortes referenziert.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_9066">The element Reference contains all references referring to externa reference systems. Here for example the Giata-ID of a hotels or the Geonames-ID of a destination is referenced.</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="ReferenceSystem" type="xs:string">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_9067">Die folgenden Referenzsysteme können aktuell verwendet werden: 
- Giata (https://www.giata.com/de/multicodes/) 
- Geonames (http://www.geonames.org/export/codes.html). 
Eine vollständige Liste finden Sie in der Technischen Dokumentation.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_9067">Currently the following reference systems may be used: 
- Giata (https://www.giata.com/de/multicodes/) 
- Geonames (http://www.geonames.org/export/codes.html). 
A complete list may be found in the Technical Documentation.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="ReferenceType" type="xs:string">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_9068">In Abhängigkeit vom Referenzsystem wird hiermit der Typ der Referenz festgelegt. Es handelt sich hierbei meist um eine ID zur eindeutigen Identifikation von Hotels, Schiffe etc. oder von Orten, Ortsteilen oder POI etc. Eine vollständige Liste finden Sie in der Technischen Dokumentation.
            </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_9068">In dependency to the reference system the type of the reference is defined here. This will be in most cases an ID for the unambiguous identification of hotels, ships etc. or of cities, districts, or POI etc. A complete list may be found in the Technical Documentation.
            </xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="LanguageTextType" internal:otdsversion="2.0">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_9088">Text mit Sprachangabe, z.B. für Deutsch xml:lang="de"</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_9088">Text with indication of the language, e.g. for German: xml:lang="de"</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute ref="xml:lang" use="optional" default="de">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_9069">In diesem Attribut wird die Sprache nach XML 1.0 innerhalb des Elements angegeben.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_9069">In this attribute the language according to XML 1.0 is indicated within the element.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StructuredTextType" internal:otdsversion="2.0">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_9070">Strukturierter Text auf Basis eines vereinfachten DocBook-Subsets</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_9070">Structured text based on a simplified DocBook-Subset</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="info" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_9071">Informationen über Copyright, Anbieter etc.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_9071">Information about Copyright, supplier etc.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="section" minOccurs="1" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_9072">Abschnitt mit struktiertem Text</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_9072">Section with structured text</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute ref="xml:lang" use="optional" default="de">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_9073">In diesem Attribut wird die Sprache nach XML 1.0 innerhalb des Elements angegeben.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_9073">With this attribute the language according to XML 1.0 in indicated within the element.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ContentLinkType" internal:otdsversion="2.0">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_9074">Auflistung verschiedener Media-Content-Links für den jeweiligen Objektknoten z.B. AccommodationName </xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_9074">Listing of different media content links for the corresponding object node, e.g. AccommodationName </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="mediaobject" minOccurs="1" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_9079">Auflistung der Mediaobjekte wie z.B. Bilder, Videos, Texte etc. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_9079">Listinf of the media objects like pictures, videos, texts etc. </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="AddressType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_172">Vollständige Adresse der Unterkunft / des Hotels.
(Adresse, Land, Tel., Fax, Email, Homepage)</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_172">Full address of the accommodation / hotel.
(Address, Country, Tel., Fax, Email, Homepage)</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="Street" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_173">Strasse und Hausnummer der Unterkunft / des
						Hotels</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_173">Street and house number of the accommodation / hotel</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ZipCode" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_174">Postleitzahl / ZipCode </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_174">Post code / ZipCode</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="City" type="LanguageTextType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_175">Imm Element City wird die Stadt
						hinterlegt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_175">In the City element, the city is specified.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Country" type="LanguageTextType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_176">In dem Element Country wird das Land ausgeschrieben hinterlegt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_176">In the Country element the country is specified
						(no abbreviation or lettercode).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Phone" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_177">In dem Element Phone wird die Telefonnummer
						inkl. Landesvorwahl hinterlegt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_177">In the Phone element the phone number, including the country code, is specified.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Fax" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_178">In dem Element Fax wird die Faxnummer inkl.
						Landesvorwahl hinterlegt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_178">In the Fax element the fax number, including the country code, is specified.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Mail" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_179">In dem Element Mail wird die Haupt-Emailadresse hinterlegt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_179">In the Mail element the main email address is specified.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Homepage" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_180">In dem Element Homepage wird die Homepage-URL
						hinterlegt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_180">In the Homepage element the homepage URL is
						specified.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="GeoInfo" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_181">In dem Element GeoInfos werden die
						Geo-Koordinaten der Unterkunft hinterlegt. Damit können Systeme das Hotel
						auf einer Weltkarte entsprechend anzeigen. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_181">In the GeoInfos element the geographical coordinates of the accommodation are specified. This allows systems to show the hotel on a world map.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Region" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_182">Das Element Region gibt die Regionszuordnung des Hotels an.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_182">The Region element specifies the region in which the hotel is situated.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:attribute name="Code" type="xs:string" use="required">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_183">Abkürzung der Region</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_183">Abbreviation for the region</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute name="Name" type="xs:string" use="required">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_184">Name der Region</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_184">Name of the region</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute name="Description" type="xs:string">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_185">Beschreibung der Region</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_185">Description of the region</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute ref="xml:lang" use="optional" default="de">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_9080">In diesem Attribut wird die Sprache nach XML 1.0 innerhalb des Elements angegeben.</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_9080">In this attribute the language according to XML 1.0 is indicated within the element.</xs:documentation>
									</xs:annotation>
								</xs:attribute>
							</xs:complexType>
						</xs:element>
						<xs:element name="Country" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_186">Das Element Land gibt die Landeszuordnung des Hotels an.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_186">The Land element specifies the map reference for the hotel.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:attribute name="Code" type="ISO3166CountryType" use="required">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_187">Beinhaltet den ISO-3166 Ländercode. Der Wert ist auf 2 Zeichen begrenzt und ist verpflichtend. 
Länderkürzel nach ISO-3166 Alpha-2: 
DE Deutschland </xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_187">Including the ISO-3166 country code. This value is limited to 2 characters and is mandatory.
Country codes according to ISO-3166 alpha-2:
DE Germany</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute name="Name" type="xs:string" use="required">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_188">Name vom Country</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_188">Name of country</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute name="Description" type="xs:string">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_189">Beschreibung vom Country</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_189">Description of country</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute ref="xml:lang" use="optional" default="de">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_9081">In diesem Attribut wird die Sprache nach XML 1.0 innerhalb des Elements angegeben.</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_9081">In this attribute the language according to XML 1.0 is indicated within the element.</xs:documentation>
									</xs:annotation>
								</xs:attribute>
							</xs:complexType>
						</xs:element>
						<xs:element name="Destination" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_190">Das Element Destination gibt die Zielgebietszuordnung des Hotels an.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_190">The Destination element specifies the geographic area of the hotel.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:attribute name="Code" type="xs:string" use="required">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_191">Code der Destination</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_191">Code of the destination</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute name="Name" type="xs:string" use="required">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_192">Name der Destination</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_192">Name of the destination</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute name="Description" type="xs:string">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_193">Beschreibung der Destination</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="en_193">Description of the destination</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute ref="xml:lang" use="optional" default="de">
									<xs:annotation>
										<xs:documentation xml:lang="de" xml:id="de_9082">In diesem Attribut wird die Sprache nach XML 1.0 innerhalb des Elements angegeben.</xs:documentation>
										<xs:documentation xml:lang="en" xml:id="den_90802">In this attribute the language according to XML 1.0 is indicated within the element.</xs:documentation>
									</xs:annotation>
								</xs:attribute>
							</xs:complexType>
						</xs:element>
						<xs:element name="GeoCode" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_194">In dem Element GeoCode können die Längen- und Breitengerade angegeben werden, wo sich die Unterkunft befindet. Damit kann eine geo-referenzierte Kartendarstellung der Ergebnisse durchgeführt werden.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_194">In the GeoCode element latitude and longitude are used to define the location of the accommodation. Thus, a geo-locative map display is produced.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Latitude" type="OWGS84Latitude">
										<xs:annotation>
											<xs:documentation xml:lang="de" xml:id="de_195">Das Element Latitude gibt die	geographische Breite dezimal an.</xs:documentation>
											<xs:documentation xml:lang="en" xml:id="en_195">The Latitude element specifies the latitude in decimal form.</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="Longitude" type="OWGS84Longitude">
										<xs:annotation>
											<xs:documentation xml:lang="de" xml:id="de_196">Das Element Longitude gibt die geographsiche Länge dezimal an.</xs:documentation>
											<xs:documentation xml:lang="en" xml:id="en_196">The Longitude element specifies the longitude in decimal form.</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="Accuracy" type="xs:unsignedInt">
										<xs:annotation>
											<xs:documentation xml:lang="de" xml:id="de_197">In dem Element Accuracy (Genauigkeit) kann eine Entfernung in km bezogen auf die Koordinate angegeben werden. Zum Beispiel bei Glückshotels, aber ggf. auch bei Rundreisen, um diese auf Karten suchbar zu machen.</xs:documentation>
											<xs:documentation xml:lang="en" xml:id="en_197">In the Accuracy element a relative distance in kilometers can be stated to the specified coordinate. For example with budget hotels. Even round trips can be made searchable on maps.</xs:documentation>
										</xs:annotation>
									</xs:element>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="RailwayStationType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_198">In dem Element RailwayStation wird ein Bahnhof definiert.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_198">In the RailwayStation element the railway station is specified.</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="Code" type="RailwayStationCodeType">
				<xs:annotation> 
					<xs:documentation xml:lang="de" xml:id="de_199">Das Attribut Code gibt den Code des Bahnhofes an. Das Referenzsystem ist unter Systemreferenz festgelegt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_199">The Code attribute specifies the station code. The reference system is defined under System Reference.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Name" type="LanguageTextType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_200">Das Attribute Name gibt den Namen des Bahnhofes an.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_200">The Name attribute states the name of the train
						station.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:all>
	</xs:complexType>
	<xs:complexType name="AccommodationInternetAccessType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_500">Möglichkeiten des Internetzugangs in der Unterkunft</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_500">Options for accessing internet in accommodation</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="EmptyTagType">
				<xs:attribute name="InternetAccessLocation" type="InternetAccessLocationEnum">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8869">Verschiedene Orte des Internanschlusses im Hotel</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8869">Various locations of the internet access in a hotel</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="InternetAccessCharge" type="InternetAccessChargeEnum">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8870">Kosten für Internetanschluss im Hotel</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8870">Charges for internet access in a hotel</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="InternetAccessType" type="InternetAccessTypeEnum">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8872">Zugangsart des Internetanschlusses</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8872">type of access to the internet</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:group name="AccommodationCategoryGroup">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_201">Kategorie der Unterkunft (Offizielle und Veranstalterkategorie).</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_201">Accommodation category (official and tour operator category).</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="AccommodationOfficialCategory" type="AccommodationCategory" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_202">Offizielle Kategorie der Unterkunft</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_202">Official category of the accommodation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AccommodationOperatorCategory" type="AccommodationCategory" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_203">Vom Veranstalter vergebene Kategorie</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_203">Category provided by the tour operator</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<xs:group name="AccommodationPropertyGroup">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_204">Name, Eigenschaften und Ausstattungsmerkmale der Unterbringung.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_204">Name, properties and characteristics of the accommodation.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="AccommodationName" type="LanguageTextType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_205">Offizieller Name der Unterkunft/des Hotels</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_205">The official name of the accommodation / hotel</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AccommodationInfo" type="ContentInfoType" minOccurs="0" internal:otdsversion="2.0"/>
			<xs:group ref="AccommodationCategoryGroup" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_3268">Kategorie der Unterkunft (Offizielle und Veranstalterkategorie).</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_3268">Category of the accommodation (official and tour operator category).</xs:documentation>
				</xs:annotation>
			</xs:group>
			<xs:element name="AccommodationChain" type="xs:unsignedInt" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_206">Zugehörigkeit einer Unterkunft zu einer Kette oder Kooperation: Die Zuordnung findet über eine Hotelketten-ID statt. Eine Referenzliste finden Sie in der Dokumentation im Anhang unter Referenzlisten / Ketten-Kooperationen.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_206">Chain or affiliation/cooperation the accommodation is part of:
The attribution is carried out according to hotel chain ID. A list of references can be found in the documentation notes under reference lists / chain collaborations.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AccommodationGeneralFacilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_207">Allgemeine Ausstattungsvarianten, Merkmale und Eigenschaften der Unterkunft</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_207">General variations of furnishings and amenities, the features and characteristics of the accommodation.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="AccommodationGeneralFacilitiesEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="AccommodationFamilyFacilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_208">Besondere Einrichtungen für Familien und Kinder</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_208">Special facilities for families and children</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="AccommodationFamilyFacilitiesEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="AccommodationSportsFacilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_209">Sporteinrichtungen und -angebote</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_209">Sport facilities and offers</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="AccommodationSportsFacilitiesEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="AccommodationWellnessFacilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_210">Wellnessmöglichkeiten und -angebote</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_210">Spa facilities and offers</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="AccommodationWellnessFacilitiesEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="AccommodationSeniorFacilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_211">Angebote für Senioren</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_211">Offers for senior citizens</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="AccommodationSeniorFacilitiesEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="AccomodationTargetgroups" minOccurs="0" internal:otdsversion="1.9.1">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_501">Angebote für bestimmte Zielgruppen</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_501">Offers for special target groups</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="AccommodationTargetgroupEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="AccommodationInternetAccess" type="AccommodationInternetAccessType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="1.9.1">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_502">Internetangebot im Hotel</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_502">Accessing internet in accommodation/hotel</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<xs:complexType name="ConsideredPriceItemsType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_8873">Beschränkt die zu berücksichtigenden PriceItems auf bestimmte PriceItems eines bestimmten Types und/oder mit bestimmten PriceTags. Die Auswahl erfolgt in der folgenden Reihenfolge:
1. Auswahl der PriceItems gemäß PriceFilter 
2. ggf. Ergänzung der IncludedDescendants. 
Bei mehrfacher Angabe des Elementes besteht die finale Menge der PriceItems aus einem Merge der PriceItems der einzelnen ConsideredPriceItems-Auswertungen. Es findet keine Duplizierung von PriceItems statt. Falls ConsideredPriceItems kein Element enthält, so werden alle PriceItems
gemäß der Angaben in den Attributen "Source" und "ConsideredPriceItemType" berücksichtigt.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_8873">Restricts the PriceItems that need to be considered to specific PriceItems of a specific type and/or with specific PriceTags. The selection takes place in the following order: 
1. selection of the PriceItems according to the PriceFilter 
2. if applicable complement of the IncludedDescendants. 
If the element is indicated several times the final amount of PriceItems consists from a merge of PriceItems of the single ConsideredPriceItems evaluation. There will be no duplication of PriceItems. If ConsideredPriceItems contain no element, all PriceItems will be considered according to the values in the attributes "Source" and 
"ConsideredPriceItemType".</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:group ref="PriceItemFilterGroup" minOccurs="0"/>
			<xs:element name="IncludeAppliedDescendants" type="IncludeAppliedDescendantsType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8874">Ist dieses Element angegeben, werden zu den in PriceItemCollection definierten PriceItems auch deren Descendants ergänzt. Descendants sind in dem Zusammenhang alle PriceItems, die durch ApplyTo und AppliedBy der PriceItemCollection-PriceItems adressiert werden. So kann man in der Collection bestimmte PercentPriceItems auswählen und zusätzlich alle PriceItems inkludieren, die sich über ApplyTo und AppliedBy auf dieses PriceItem beziehen. 
Die Auswahl der Descendants lässt sich wiederum durch den PriceItemFilter separat einschränken. Bei der Auswahl der Descendants wird nur Apply-Hierarchie berücksichtigt! Sollte ein Bezug auf ein generisches Absolute hergestellt werden, so wird hierbei dessen Include nicht mitberücksichtigt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8874">In case this element is indicated, the descendants of PriceItems defined in PriceItemCollection 
are complemented to those. Descendants in this respect are all PriceItems that can be addressed by ApplyTo and AppliedBy of the PriceItemCollection-PriceItems. Hence one can choose specific PercentPriceItems in the collection and additionally include all PriceItems that refer to this PriceItem via ApplyTo and AppliedBy. 
The selection of the descendants can be in turn restricted separately by the PriceItemFilter. For the selection of the descendants only the Apply hierarchy is considered! If a reference to a generic Absolute is constructed, its Include will not be considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="ComponentAttributeGroup">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8875">Das Attribut Component gibt an, auf welche Komponente sich dieses PriceItem bezieht. Durch die explizite Angabe einer Komponente ist es möglich, dass ein Percent-PriceItem sich auf ein absolutes PriceItem einer anderen Komponente bezieht. Das Attribut Source stellt eine Erweiterung zum Attribut dar. Wird gleichzeitig das Attribut 'Component' und das Attribut 'Source' angegeben, so wird nur die Source ausgewertet. Werden beide Attribute nicht angegeben, wird für das Attribut 'Component' der Wert 'ThisComponent' angenommen.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8875">The attribute Component indicates, which component this PriceItem refers to. By explicitly indicating a component it is possible to have a Percent-PriceItem refer to an absolute PriceItemof a different component. The attribute Source is an increment of the attribute. If both attribute 'Component' and 'Source' are indicated at the same time, only Source will be evaluated. If both attributes are not indicated, the value 'ThisComponent' is assumed for the attribute 'Component'.</xs:documentation>
			</xs:annotation>
		</xs:attributeGroup>
		<xs:attribute name="ConsideredPriceItemType" type="ConsideredPriceItemTypeEnum" default="All">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8876">Dieses Element definiert, welche Art PriceItems berücksichtigt werden. Es kann eine durch Space getrennte Liste von Values angegeben werden. Folgende Values sind möglich:
- Absolutes: Es werden nur absolute PriceItems berücksichtigt.
- Percents: Es werden nur Percent-PriceItems berücksichtigt.
- All: Es werden alle PriceItems berücksichtigt.
- GenericAbsolute
Default = "All"</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8876">This element defines which kind of PriceItems will be considered. A list of values separated by space can be indicated. The following values may be used:
- Absolutes: only absolute PriceItems are considered.
- Percents: only Percent-PriceItems are considered.
- All: all PriceItems are considered.
- GenericAbsolute
Default = "All"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:group name="PriceItemFilterGroup">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded">
				<xs:element name="ConsideredPriceTags" type="ConsideredPriceTagsReferenceType">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8877">Diese Elemente definieren, dass nur PriceItems berücksichtigt werden, die eines der aufgeführten PriceTags beinhalten.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8877">These elements define, that only those PriceItems will be considered, that include one of the listed PriceTags.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="NotConsideredPriceTags" type="ConsideredPriceTagsReferenceType">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8878">>Diese Elemente definieren, dass nur PriceItems berücksichtigt werden, die keines der aufgeführten PriceTags beinhalten.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8878">>These elements define, that only those PriceItems will be considered, that include none of the listed PriceTags.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:group ref="ConsideredPriceItemsGroup">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_452">Hier werden die PriceItems definiert bzw. ausgeschlossen, welche zur Beurteilung des Preisindizes herangezogen werden.  Jedes Element "ConsideredPriceItemClasses" bzw. "NotConsideredPriceItemClasses" wird in seinem Component-Kontext ausgewertet. Die Ergebnismenge der gültigen PriceItems ist die Vereinigungsmenge der Einzelauswertungen. Dabei werden keine PriceItems vervielfältigt.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_452">This is used to define or exclude the PriceItems that are used to evaluate the PriceIndices. Each element "ConsideredPriceItemClasses" respectively "NotConsideredPriceItemClasses" is evaluated in its component context. The result set of the valid PriceItems is the set union of the single evaluations. No PriceItems will be duplicated.</xs:documentation>
					</xs:annotation>
				</xs:group>
			</xs:choice>
		</xs:sequence>
	</xs:group>
	<xs:group name="AllocationBaseGroup">
		<xs:sequence>
			<xs:element name="DayBase">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_383">Basisdauer der Reise. Wird "x" angegeben, wird immer die vorhandene Dauer zugrunde gelegt. Der "Value" wird durch die Anzahl der Tage geteilt und gleichmässig auf jeden Tag verteilt. Wird "1" angegeben, wird das PriceItem pro Tag angewendet. Bei einer Zahl größer als 1 wird diese Dauer mit der tatsächlichen Dauer verrechnet. "7" bedeutet also, das PriceItem ist wöchentlich: Der "Value" wird durch 7 geteilt und auf jeden Tag angewendet. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_383">Basic duration of the trip. If "x" is specified, the existing duration is taken as the basis. The "value" is divided by the number of days and allocated equally to each day. If "1" is specified, the PriceItem per day is applied. For a number greater than one, this duration is allocated the actual duration. "7" therefore means that the PriceItem is weekly: The "value" is divided by 7 and applied to each day.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="PriceImpactBaseValueType">
							<xs:attribute name="Source" type="SourceAttributeType" default="ThisComponent">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_384">Dieses Attribut definiert aufgrund der Komponente, welchen Tagen der Absolutpreis zugewiesen wird. Mögliche Werte sind: - ThisComponent - Accommodation - ReturnFlight - Outbound - Inbound - OnewayFlight - Addon - Product. Mit "Product" definiert man die Tage der Gesamtreise. Default ist "ThisComponent".</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_384">Based on the component, this attribute
										defines the days to which the absolute price is allocated.
										Possible values are: - ThisComponent - Accommodation -
										ReturnFlight - Outbound - Inbound - OnewayFlight - Addon -
										Product "Product" defines the days of the total trip.
										"ThisComponent" is the default setting.</xs:documentation>
								</xs:annotation>
							</xs:attribute>
							<xs:attribute name="IntervalType" type="IntervalTypeEnum" default="Stay">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_385">Dieses Attribut definiert aufgrund des DayTypes, welchen Tagen genau der Absolutpreis zugewiesen wird. Mögliche Werte: 
- Stay: Alle "Stay"-Tage. 
- CheckInOut: Das Intervall von CheckIn bis CheckOut inklusive CheckIn und CheckOut. 
Default ist "Stay".</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_385">Based on the DayType, this attribute defines the exact days to which the absolute price is allocated. Potential values: 
- Stay: All "Stay" days. 
- CheckInOut: The interval from CheckIn to CheckOut including CheckIn and CheckOut. 
"Stay" is the default.</xs:documentation>
								</xs:annotation>
							</xs:attribute>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="PersonBase" type="PriceImpactBaseValueType"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="AllocationBaseConditionGroup">
		<xs:sequence>
			<xs:element name="DayBase" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8879">Ist dieses Element angegeben, so werden nur die mit Source und IntervalType definierten Tage bei der Auswertung betrachtet. Ist das Element "PersonBase" nicht angegeben, so gilt die Condition für einen betrachteten Tag als erfüllt, wenn an diesem Tag für wenigstens 1 Person die Condition erfüllt ist.
Falls das Element "PersonBase" angegeben ist, so werden alle Kostenknoten einzeln betrachtet und gemäß des Evaluationmodes ausgewertet. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8879">If this element is indicated, only those days defined by Source and IntervalType will be considered in the evaluation. In case the element "PersonBase" is not indicated, the Condition for a specific day is regarded as fulfilled, if on this day the condition is fulfilled for at least one person.
If the element "PersonBase" is indicated, all cost nodes are considered separately and evaluated according to the evaluation mode. </xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="EmptyElementType">
							<xs:attribute name="Source" type="SourceAttributeType" default="ThisComponent">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_8880">Hier können über einen Bezug zu einer Komponent-Instanz bestimmte Tage addressiert werden. Der Default ist "ThisComponent". </xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_8880">Here specific days can be addressed via a reference to a component instance. The default is "ThisComponent". </xs:documentation>
								</xs:annotation>
							</xs:attribute>
							<xs:attribute name="IntervalType" type="IntervalTypeEnum" default="Stay">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_8881">Mit diesem Attribut können über einen bestimmten  IntervalType bestimmte Tage addressiert werden. Mögliche Werte sind:
- Stay
- CheckInOut</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_8881">With the help of this attribute specitic days may be addressed via a specific IntervalType. The following values are allowed:
- Stay
- CheckInOut</xs:documentation>
								</xs:annotation>
							</xs:attribute>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="PersonBase" type="EmptyElementType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8882">Ist dieses Element angegeben, so werden die Personen betrachtet und gemäß dem angegebenen EvaluationMode ausgewertet. Ist das Element "DayBase" nicht angegeben, so gilt die Condition für eine betrachtete Person als erfüllt, wenn für diese Person wenigstens an einem Tag die Condition erfüllt ist.

Falls das Element "DayBase" angegeben ist, so werden alle Kostenknoten (ggf. eingeschränkt durch Source und IntervalType) einzeln betrachtet und gemäß des Evaluationmodes ausgewertet. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8882">If this element is indicated, the persons are considered and evaluated according to the EvaluationMode indicated. If the element "DayBase" is not indicated, the condition for the considered person is regarded as fulfilled, if the condition is fulfilled for this person at least on one day.

If the element "DayBase" is indicated, all cost nodes (if necessary restricted by Source and IntervalType) are considered separately and evaluated according to the evaluation mode.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<!-- Base Types and Elements -->
	<xs:complexType name="DayAllocationType">
		<xs:complexContent>
			<xs:extension base="SimpleUpdateNodeType">
				<xs:sequence>
					<xs:element name="DayAllocationStart" type="DayAllocationStartType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_212">Diese Element definiert den Anfang des DayAllocationIntervalls einer DayAllocation-Ebene. Standardmäßig besteht ein Produkt nur aus einer DayAllocationEbene, deren Anfang der erste Tag der Reise ist. Die explizite Angabe eines "DayAllocationStart" ist dafür nicht notwendig. 
Wenn aber einem Tag gleichzeitig mehrere Komponenten zugewiesen werden, dann entstehen mehrere DayAllocation-Ebenen. Dies kann zum Beispiel bei Addons der Fall sein. In diesem Fall muss explizit ein "DayAllocationStart" angegeben werden, der den Start des Addons definiert. Die DayAllocation-Ebenen unterscheiden sich dabei durch den Wert des Attributs "DayAllocationLevel". 
Im Zusammenhang mit optionalen Addons wird das Addon in Bezug auf bereits fertig allozierte Produkte definiert. Hierbei muss ein DayAllocationStart angegeben werden, der Bezug auf das fertig allozierte Produkt nimmt. Ist kein DayAllocationStart Element für das DayAllocationLevel=0 angegeben, so wird ein Default-Element erzeugt, welches die Attribute mit den vorgegebenen Defaultwerten enthält. 
Mehr Details finden sich in den Beschreibungen der Attribute und auch in der "Thematischen Dokumentation" im Kapitel "DayAllocation".</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_212">This element defines the beginning of the DayAllocationInterval at the DayAllocationLevel. By default, a product has only one DayAllocationLevel, whose beginning is the first day of the trip. The explicit indication of a "DayAllocationStart" is not necessary.
If a single day is assigned more than one component at the same time it will result in multiple DayAllocationLevels. This may for example be the case in relation to add-ons. In this case, an explicit "DayAllocationStart" must be specified that defines the start of the add-on. The DayAllocation levels differ from each other according to the value of the "DayAllocationLevel" attribute.
In conjunction with other optional add-ons the add-on will be defined in relation to the product already allocated. Here, a DayAllocationStart must be specified, which refers to the finished allocated product.
Where no DayAllocationStart element is specified for the DayAllocationLevel=0, a default element is generated, which contains the specified default values of the attributes.
A more detailed description of the attributes can be found in the "Thematic documentation" in the chapter "Day Allocation".</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DayAllocationEnd" type="DayAllocationEndType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_213">Diese Element definiert das Ende des DayAllocationIntervalls eines DayAllocation-Ebene. Standardmäßig besteht ein Produkt nur aus einer DayAllocationEbene, deren Ende der erste Tag der Reise ist. Die explizite Angabe eines "DayAllocationEnd" ist dafür nicht notwendig. Wenn aber einem Tag gleichzeitig mehrere Komponenten zugewiesen werden, dann entstehen mehrere DayAllocation-Ebenen. Dies kann zum Beispiel bei Addons der Fall sein. In diesem Fall muss explizit ein "DayAllocationEnd" angegeben werden, der das Ende des Addons definiert. Die DayAllocation-Ebenen unterscheiden sich dabei durch den Wert des 	Attributs "DayAllocationLevel". Im Zusammenhang mit optionalen Addons wird das Addon in Bezug auf bereits fertig allozierte Produkte definiert. Hierbei muss ein DayAllocationEnd angegeben werden, der Bezug auf das fertig allozierte Produkt nimmt. Ist kein DayAllocationEnd-Element für das DayAllocationLevel=0 angegeben, so wird ein Default-Element erzeugt, welches die Attribute mit den vorgegebenen Defaultwerten enthält. Mehr Details finden sich in den Beschreibungen der Attribute und auch in der "Thematischen Dokumentation" im Kapitel "DayAllocation". </xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_213">This element defines the end of the DayAllocationIntervals of a DayAllocation level. By default, a product has a single DayAllocationInterval which ends on the first day of the trip. The explicit indication of a "DayAllocationEnd" is not required.

If a single day is assigned more than one component simultaneously, multiple DayAllocation levels will be created. This may for example be the case for add-ons. In this instance, where an explicit "DayAllocationEnd" is specified, it defines the end of any additional days. The DayAllocation levels differ from each other according to the value of the "DayAllocationLevel" attribute.
In conjunction with other optional add-ons the add-on will be defined in relation to the product already allocated. Here, a DayAllocationEnd must be specified and refers to the complete allocated product.
Where no DayAllocationEnd element for the DayAllocationLevel=0 is given, a default element is generated, which contains the attributes of the specified default values.
A more detailed description of the attributes can be found in the "Thematic documentation" in the chapter "Day Allocation".</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SimpleNodeIataAirportCodeListType">
		<xs:simpleContent>
			<xs:restriction base="SimpleAtomicUpdateNodeType">
				<xs:simpleType>
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_214">Eine Liste von IATA-Airport-Codes.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_214">A list of IATA airport codes.</xs:documentation>
					</xs:annotation>
					<xs:list itemType="IataAirportCodeType"/>
				</xs:simpleType>
			</xs:restriction>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="SimpleNodeIataAirportCodeType">
		<xs:simpleContent>
			<xs:restriction base="SimpleAtomicUpdateNodeType">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:pattern value="[A-Z]{3}"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:restriction>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="CheckOutDateOffsetType">
		<xs:simpleContent>
			<xs:restriction base="SimpleAtomicUpdateNodeType">
				<xs:simpleType>
					<xs:restriction base="xs:int"/>
				</xs:simpleType>
			</xs:restriction>
		</xs:simpleContent>
	</xs:complexType>
	<xs:group name="DistributorIdentificationGroup">
		<xs:sequence>
			<xs:element name="CrsSystem" type="CrsSystemEnum"/>
			<xs:element name="AgencyCode" type="xs:string"/>
			<xs:element name="BrandCode" type="xs:string"/>
		</xs:sequence>
	</xs:group>
	<xs:complexType name="ResellerType">
		<xs:choice>
			<xs:element name="ResellerType" type="ResellerTypeEnum">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_3273">Dieses Element definiert einen generellen Resellertypen. 
Mögliche Werte sind:
- PackageMixReseller
- PureReseller
PackageMixReseller sind Reseller, die Produkte des Lieferanten nutzen, um diese zusammen mit anderen Komponenten als Paket zu verkaufen. Im Gegensatz dazu verkaufen die PureReseller die Einzelkomponenten des Lieferanten als eigenständiges Produkt weiter.
 </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_3273">This element defines a general reseller type. Possible values are:
- PackageMixReseller
- PureReseller
PackageMixReseller are Reseller who use products of a supplier in order to combine them with other components and sell them as a package. The PureReseller on the contrary sell the single components of the supplier as an independent product.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:group ref="DistributorIdentificationGroup"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ParameterSetType">
		<xs:complexContent>
			<xs:extension base="MultipleSimpleUpdateNodeType">
				<xs:choice>
					<xs:group ref="DistributorIdentificationGroup"/>
					<xs:element name="SalesChannel" type="SalesChannelEnum">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_8883">Dieses Element definiert den GlobalValue für einen bestimmten SalesChannel. Die möglichen Werte sind:
- OnlineTravelAgency (Vermarktung der Angebote über Webseiten)
- TravelAgency (Vermarktung der Angebote über Reisebüros)
- Intern (Innerbetriebliche Vermarktung der Reisen) </xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_8883">This element defines the GlobalValue for a specific SalesChannel. The following values may be used:
- OnlineTravelAgency (Selling of travel via webpages)
- TravelAgency (Selling of travel via travel agencies)
- Intern (Selling of travel intra-companies)</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DistributionChannel" type="DistributionChannelEnum">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_8884">Dieses Element definiert den GlobalValue für einen bestimmten DistributionChannel:
- Bewotec (Vermarktung der Angebote über den Distributor "Bewotec")
- TravelTainment (Vermarktung der Angebote über den Distributor "Traveltainment")
- Traffics (Vermarktung der Angebote über den Distributor "Traffics")
- Schmetterling (Vermarktung der Angebote über den Distributor "Schmetterling")</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_8884">This element defines the GlobalValue for a specific DistributionChannel:
- Bewotec (Selling via distributor "Bewotec")
- TravelTainment (Selling via distributor "Traveltainment")
- Traffics (Selling via distributor "Traffics")
- Schmetterling (Selling via distributor "Schmetterling")</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="SalesMarket" type="ISO3166CountryType" internal:otdsversion="1.9">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_8885">Dieses Element definiert den GlobalValue für einen bestimmten Markt, welcher einem Land entspricht. Die Währung folgt der Definition gemäß der ISO3166 Norm für Länder.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_8885">This element defines the GlobalValue for a specific market, which represents a country. The currency is defined according to ISO3166 norm for countries.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Currency" type="ISO4217CurrencyType" internal:otdsversion="1.9.2">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_8886">Dieses Element definiert den GlobalValue für eine bestimmte Währung. Die Währung folgt der  Definition gemäß der ISO4217 Norm für Währungen.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_8886">This element defines the GlobalValue for a specific currency. The currency is defined according to ISO4217 norm for currencies.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="FeatureContext" type="FeatureContextEnum" internal:otdsversion="2.0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_8887">Mit diesem Parameterset kann man einen GlobalValue definieren, der nur dann aktiv wird, wenn dieses FeatureContext gewünscht ist. Die Verarbeitung mit einem spezifisches FeatureContext kann zu einem anderen Ergebnis führen als ohne den FeatureContext.
Derzeit gibt es nur einen FeatureContext "City-Pair-Production".
Mit diesem Feature erhalten Sie bei Flügen oder Pauschalangeboten genau einen Flug pro CityPair, Termin und Dauer, welcher mit einem spezifischen CityPairCode (z.B. DUSPMI) gebucht wird. Der Datenlieferant ist dafür verantwortlich, dass die Verwendung des GlobalValues zu der gewünschten Verarbeitung führt.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_8887">This set of parameters serves to define a GlobalValue that only is activated when this specific FeautureContext is desired. The processing with a specific FeatureContext can lead to a different result than without the FeautureContext.
At present there is only one FeatureContext "City-Pair-Production". By this feature for flights or packaged travel offers exactly one flight per CityPair, date and duration is returned. This flight must be booked with a specific CityPairCode (ie. DUSPMI). The provider of the data is responsible that the use of GlobalValues leads to the processing results desired.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Reseller" type="ResellerType" internal:otdsversion="2.0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_8888">Dieses Element definiert den GlobalValue für einen bestimmten Reseller, der durch die Angabe der Kombination aus CRS-System, AgencyCode und BrandCode eindeutig identifiziert wird.

Wiederverkäufer sind den Distributoren sehr ähnlich. Im Unterschied zu den Distributoren bucht der Wiederverkäufer z.B. einen Flug auf seinen Namen beim Lieferanten und bietet dann diesen Flug dem Endkunden zu Kauf an. 
Der Vermittler hingegen vermittelt die Flugbuchung nur. Die Buchung selbst wird beim Vermittler vom Endkunden direkt beim Lieferanten durchgeführt. 
Mit dem Wiederverkäufer-Kontext kann also gesteuert werden, dass bestimmte Produkte ggf. nicht oder nur für Wiederverkäufer oder auch spezielle Wiederverkäufer zur Verfügung gestellt werden. Oder der Lieferant kann auch die Preiskalkulation diesbzgl. beeinflussen. 
Ein bestimmter Wiederverkäufer wird durch die Angabe der Kombination aus CRS-System, AgencyCode und BrandCode eindeutig identifiziert. Optional kann man aber auch die Gruppe der Wiederverkäufer an sich über den ResellerType adressieren.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_8888">This element defines the GlobalValue for a specific reseller, which is explicitly identified by the combined information of CRS-System, AgencyCode and BrandCode.
	
Reseller are very similar to the Distributors. As opposed to Distributors though a Reseller books e.g. a flight with the supplier in his name and then offers this flight for the endconsumer to buy. 
The Intermediary only acts as a broker. With an Intermediary, the booking itself is placed at the supplier by the endconsumer himself.
With the help of the Reseller Context it can be defined, that certain products are not or are only available for Resellers or specific Resellers. The supplier may also influence the price calculation that way.
A certain Reseller may be unambiguously identified by the combination of CRS-system, AgencyCode, and BrandCode. As an option, it is also possible to address the entire group of Reseller via the ResellerType.
</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:attributeGroup name="TagAttributeGroup">
		<xs:attribute name="Class" type="TokenType" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_402">Mit diesem Attribut kann man das Tag weiter spezifizieren, auf dessen Knoten sich der Inhalt bezieht.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_402">With this attribute, it is possible to further specify the tag, to whose node the content refers to.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="TagValueType" type="TagValueTypeEnum" default="String">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_403">Dieses Attribut gibt an, von welchem Typ der Value des Tags ist. Es gibt drei unterschiedliche Typen: 
- String, 
- Numeric, 
- Price. 
Der Typ gibt an, in welcher Form Conditions mit dem Tag gebildet werden können und wie diese zu interpretieren sind. Ist kein TagType gesetzt, dann nimmt der TagType den Defaultwert = "String" an. </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_403">This attribute indicates which type the Value of the tag is. There are three different types: 
- String, 
- Numeric, 
- Price. 
The type indicates in what form Conditions can be constructed with the tag and how these are to be interpreted. If no TagType is specified, the TagType takes the default value = "String".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="SourceAttributeGroup">
		<xs:attribute name="Source" type="SourceAttributeType" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_215">Dieses Attribut dient der Identifizierung einer Unterkomponente bzw. eines Zielknotens im OTDS-XML-Baum bezogen auf das aktuell betrachtete Angebot. Die Adressierung der Unterkomponenten findet über eine festgelegte Struktur von in sich verschachtelten Unterkomponenten statt. Die Verschachtelung wird über eine definierte Punktnotation dargestellt und muss den im "SourceAttributeType" aufgeführten Enumerations folgen. Nur innerhalb der Rules kann ggf. von den im "SourceAttributeType" aufgeführten Enums der allgemeine Komponentenname durch den in den Rules spezifisch genannten	Komponentennamen ersetzt werden. Wobei die entsprechenden Unterkomponenten wieder unbedingt der Punktnotation folgen müssen.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_215">This attribute serves to identify a sub-component and a target node in the OTDS XML tree based on the currently observed offer. The addressing of subcomponents takes place through a fixed structure containing these encapsulated subcomponents. The encapsulation is represented by a defined dot notation and must follow the enumerations under "SourceAttributeType".
Only according to the rules can the "SourceAttributeType" enumerations for the general component names be replaced by specific component names mentioned in the rules. Whereby the respective subcomponents again must follow the dot notation.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="ComponentAttributeGroup">
		<xs:attribute name="Component" type="ComponentAttributeType" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_266">Dieses Attribut gibt den Type einer Komponente an. Folgende Typen stehen zur Auswahl: 
- Accommodation 
- Flight 
- Addon
- ThisComponent
Mit der Source kann man die Addressierung noch feiner auflösen.
Wird gleichzeitig das Attribut 'Component' und das Attribut 'Source' angegeben, so wird nur die Source ausgewertet. Werden beide Attribute nicht angegeben, wird für das Attribut 'Component' der Wert 'ThisComponent' angenommen.
					</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_266">This attribute specifies the type of a component. In the case of a CombiComponent, type refers to the first component indicated. The following types are available: 
- Accommodation
- Flight
- Add-on
- ThisComponent.
With the help of Source the addressing can be refined further. If the attribute 'Component' and the attribute 'Source' are indicated at the same time, only Source is being evaluated. If both attributes are not indicated, the value 'ThisComponent' is assumed for the attribute 'Component'.
					</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Source" type="SourceAttributeType" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8889">Mit der Source kann man die Adressierung noch feiner auflösen als mit dem Attribute 'Component'.
Wird gleichzeitig das Attribut 'Component' und das Attribut 'Source' angegeben, so wird nur die Source ausgewertet. Werden beide Attribute nicht angegeben, wird für das Attribut 'Component der Wert 'ThisComponent' angenommen.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8889">With the Source the addressing can be dismantled even further than with the attribute 'Component'.
If both attributes 'Component' and 'Source' are indicated at the same time, only 'Source' will be evaluated. If none of the attributes are indicated, for tha attribut 'Component' the value 'ThisComponent' is presumed.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="ConditionAttributeGroup">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_216">Attributsgruppe zur Referenzierung einer Komponente bzw. Unterkomponente</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_216">Attribute group for referencing a component or subcomponent</xs:documentation>
		</xs:annotation>
		<xs:attribute name="DayAllocation" type="DayAllocationEnum">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_217">Dieses Attribut definiert die Zuweisung im Falle, dass die Werte im Attribut "Source" auf mehrere Komponenten verweisen. Das kann zum Beispiel vorkommen, wenn man ein Produkt definiert, welches zusammengesetzte Flüge über CombiComponents verwenden soll. Die Adressierung über Source kann nur den Flug im Allgemeinen ansprechen. Der Flug besteht aber in dem Falle aus mehreren Einzelkomponenten. Die Adressierung über "Source" wäre nicht eindeutig möglich. 
Mögliche Werte sind: 
- First: Nur die zeitlich erste Komponente wird bzgl. der Bedingung ausgewertet. Die zeitliche Reihenfolge entspricht der Sortierung des Attributs "DayAllocationIndex" der entsprechenden Komponenten. 
- Last: Nur die zeitlich letzte Komponente wird bzgl. der Bedingung ausgewertet. Die zeitliche Reihenfolge entspricht der Sortierung des Attributs
"DayAllocationIndex" der entsprechenden Komponenten. 
- All: Alle Komponenten werden bzgl. der Bedingung ausgewertet. Die Bedingung ist nur erfüllt, wenn alle Komponenten die Bedingung erfüllen. Wenn das Attribut nicht gefüllt ist, wird ein Standard verwendet, der von der verwendeten Condition abhängt. 
Der Default ist "All", wenn nicht eine der folgenden Bedingungen erfüllt ist:
- Die Condition enthält den DayType="CheckIn", dann ist der Default von DayAllocation="First"
- Die Condition enthält den DayType="CheckOut", dann ist der Default von DayAllocation="Last"
- Bei allen Auswertungen welche sich auf "DepartureAirport" beziehen, wird der Default von DayAllocation="First" (Airports Bedingung, MatchEqual, etc.)
- Bei allen Auswertungen welche sich auf "ArrivalAirport" beziehen, wird der Default von DayAllocation="Last" (Airports Bedingung, MatchEqual, etc.)
- Bei BookingDateOffset-Bedingungen wird der Default von DayAllocation="First"
</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_217">This attribute defines the allocation where the values ​​in the attribute "Source" refer to more than one component. This can occur, for example, if a product that should use composite flights via CombiComponents is defined. The addressing through "Source" can refer only to the flight in general. The flight, in this case however, consists of several individual components. The addressing through "source" would explicitly not be
possible. 
Possible values are: 
- First: Only the temporal first component is evaluated according to this condition. The chronological sequence follows the order of the "DayAllocationIndex" attributes of the corresponding components.
- Last: Only the temporal last component is evaluated according to this condition. The chronological sequence follows the order of the "DayAllocationIndex"
attributes of the corresponding components. 
- All: All components are evaluated according to the condition. The condition is met only if all components meet the condition. If the attribute is not defined, a standard value is used, which is dependant on the relevant condition. 					
The Default is "All" if the condition is not one of the following:
- If the Condition contains the DayType="CheckIn", the Default is DayAllocation="First"
- If the Condition contains ths DayType="CheckOut", the Default is DayAllocation="Last"
- For all evaluations which refer to "DepartureAirport", the Default is DayAllocation="First" (Airports Condition, MatchEqual, etc.)
- For all evaluations which refer to "ArrivalAirport", the Default is DayAllocation="Last" (Airports Condition, MatchEqual, etc.)
- The BookingDateOffset-Condition has the Default DayAllocation="First"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="EvaluationMode" type="EvaluationModeEnum" default="Any">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_218">Dieses Attribut definiert die Interpretation der Auswertung im Falle, dass die Werte im Attribut 'Source' auch nach Auswertung der DayAllocation auf mehrere Komponenten verweisen. Das kann passieren, wenn gleiche Komponenten zur gleichen Zeit stattfinden, also eine Überschneidung in der DayAllocation haben. Beispiel sind hier Addons, die sich häufig überschneiden können. 
Mögliche Werte sind: 
- Any: Wenn dieser Wert gesetzt ist, wird die Bedingung wahr, sobald eine der adressierten Komponenten die Bedingung erfüllt. 
- All: Wenn dieser Wert gesetzt ist, wird die Bedingung nur wahr, wenn	alle adressierten Komponenten die Bedingung erfüllen. 
Wenn das Attribut nicht gefüllt ist, wird als Standard "Any" verwendet. </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_218">This attribute defines the interpretation of the analysis in the event that the values ​​in the attribute "Source" also refer to several components after the DayAllocation evaluation. This can happen if the same components take place at the same time and thus overlap with the DayAllocation. Add-ons are an example of this, as they can often overlap.
Possible values are:
- Any: If this value is specified, the condition is met if any of the components addressed satisfies the condition.
- All: If this value is specified, the condition is met only if all components meet the condition addressed.
If the attribute is not filled, the default "Any" is used.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="TagReferenceAttributeGroup">
		<xs:attribute name="Offset" type="xs:unsignedInt">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8890">Gibt die Position an, ab der der Body des Tag-Elementes verglichen werden soll. (Default ist Position 0 - dies entspricht dem ersten Zeichen.)</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8890">Determines the position, from which on the body of the tag element shall be compared. (Default is position 0 - this corresponds to the first character.)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Length" type="xs:unsignedInt">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8891">Gibt die Anzahl der Zeichen an, die im Body des Tag-Elementes verglichen werden sollen. Ist das Attribut nicht besetzt, so wird immer der Body des TagElementes bis zum Ende der Zeichenkette verglichen.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8891">Determines the number of characters, which shall be compared in the body of the tag element. If the attribute is not filled, always the body of the TagElement is compared until the end of the character string.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="SizeType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_219">Typ zur Abbildung von Maßen, z.B. max. Größe Gepäckstücke</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_219">Type for indicating measurements, e.g. max. luggage size</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Length" type="FloatWithUnitType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_220">In diesem Element steht die Länge</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_220">This element states the length</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Width" type="FloatWithUnitType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_221">In diesem Element steht die Breite</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_221">This element states the width</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Depth" type="FloatWithUnitType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_222">In diesem Element steht die Tiefe</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_222">This element states the depth</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:simpleType name="OWGS84Latitude">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_223">
				<summary>Dieser optionale Typ zeigt den Breitengrad eines Objektes an. Gültige Werte sind von -90.0 bis 90.0. Da diese Informationsangabe
optional ist, kann der Wert auch leer bleiben ("", ohne Zeichen).</summary>
			</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_223">
				<summary>This optional type can take the latitude of an object. Valid values are from -90.0 to 90.0. As this information is optional, the value can be empty (string of length zero).</summary>
			</xs:documentation>
		</xs:annotation>
		<xs:union>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:length value="0"/>
				</xs:restriction>
			</xs:simpleType>
			<xs:simpleType>
				<xs:restriction base="xs:decimal">
					<xs:minInclusive value="-90.0"/>
					<xs:maxInclusive value="90.0"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="OWGS84Longitude">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_224">
				<summary>Dieser optionale Typ zeigt den Längengrad eines Objektes an. Gültige Werte sind -180.0 bis 180.0. Da diese Informationsangabe optional ist, kann der Wert auch leer bleiben ("", ohne Zeichen).</summary>
			</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_224">
				<summary>This optional type can take the longitude of an object. Valid values are from -180.0 to 180.0. As this information is optional, the value can be empty (string of length zero).</summary>
			</xs:documentation>
		</xs:annotation>
		<xs:union>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:length value="0"/>
				</xs:restriction>
			</xs:simpleType>
			<xs:simpleType>
				<xs:restriction base="xs:decimal">
					<xs:minInclusive value="-180.0"/>
					<xs:maxInclusive value="180.0"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="NameType">
		<xs:restriction base="xs:string">
			<xs:pattern value="[A-Za-z0-9]+"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="MonetaryValue">
		<xs:restriction base="xs:decimal"/>
	</xs:simpleType>
	<xs:simpleType name="AccommodationCategory">
		<xs:restriction base="xs:string">
			<xs:pattern value="\s*(7(\.0)?|[0-6](\.[05])?)\s*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="RailwayStationCodeType">
		<xs:restriction base="xs:string">
			<xs:pattern value="[A-Z]{3}"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IataAirportCodeType">
		<xs:restriction base="xs:string">
			<xs:pattern value="[A-Z]{3}"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IataAirlineCodeType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_8892">Typ für IATA Airline Codes ("IATA Zweiletter-Code", siehe http://www.iata.org/services/pages/codes.aspx )
          </xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_8892">Type for IATA Airline Codes ("IATA two character designator code", see http://www.iata.org/services/pages/codes.aspx )
          </xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<!-- [A-Z0-9]{2} will be activated in Version 2.0-->
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TokenType">
		<xs:restriction base="xs:string">
			<xs:minLength value="1"/>
			<xs:maxLength value="128"/>
			<xs:pattern value="[\S]+"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ISO3166CountryType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_225">Beinhaltet den ISO-3166 Ländercode. Der Wert ist
				auf zwei Zeichen begrenzt und ist verpflichtend. Länderkürzel nach ISO-3166 Alpha-2:
				DE Deutschland </xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_225">States the ISO-3166 country code. This value is
				limited to two characters and is mandatory. Country codes according to ISO-3166
				alpha-2: DE Germany</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="[A-Z]{2}"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ISO4217CurrencyType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_533">Beinhaltet den ISO-3166 Ländercode. Der Wert ist
				auf zwei Zeichen begrenzt und ist verpflichtend. Länderkürzel nach ISO-3166 Alpha-2:
				DE Deutschland </xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_533">States the ISO-3166 country code. This value is
				limited to two characters and is mandatory. Country codes according to ISO-3166
				alpha-2: DE Germany</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="[A-Z]{3}"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DateListType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_226">Eine Liste von Datumsangaben</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_226">A list specifying dates</xs:documentation>
		</xs:annotation>
		<xs:list itemType="xs:date"/>
	</xs:simpleType>
	<xs:simpleType name="IntegerListType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_227">Eine Liste von Integerzahlen, durch Space
				getrennt.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_227">A list of integers separated by spaces.</xs:documentation>
		</xs:annotation>
		<xs:list itemType="xs:int"/>
	</xs:simpleType>
	<xs:simpleType name="NonZeroIntegerListType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_9005">Eine Liste von Integerzahlen ohne Null, durch Space
        getrennt.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_9005">A list of integers without zero separated by spaces.</xs:documentation>
		</xs:annotation>
		<xs:restriction>
			<xs:simpleType>
				<xs:list>
					<xs:simpleType>
						<xs:restriction base="NonZeroIntegerType"/>
					</xs:simpleType>
				</xs:list>
			</xs:simpleType>
			<xs:minLength value="1"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="NonZeroIntegerType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de">Eine Integerzahl ohne Null</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en">An integer without zero</xs:documentation>
		</xs:annotation>
		<xs:restriction>
			<xs:simpleType>
				<xs:union>
					<xs:simpleType>
						<xs:restriction base="xs:int">
							<xs:minExclusive value="0"/>
						</xs:restriction>
					</xs:simpleType>
					<xs:simpleType>
						<xs:restriction base="xs:int">
							<xs:maxExclusive value="0"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:union>
			</xs:simpleType>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ProductFeaturesAttributeListType">
		<xs:list itemType="ProductFeatureAttributeEnum"/>
	</xs:simpleType>
	<xs:simpleType name="ProductFeatureAttributeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CityPairProduction"/>
			<xs:enumeration value="AlternativeFlights"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PersonGenderEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Female"/>
			<xs:enumeration value="Male"/>
			<xs:enumeration value="Undefined"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TagValueTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="String"/>
			<xs:enumeration value="Numeric"/>
			<xs:enumeration value="Price"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="OrderEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Ascending"/>
			<xs:enumeration value="Descending"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="SimpleAtomicUpdateNodeType">
		<xs:simpleContent>
			<xs:extension base="xs:anySimpleType">
				<xs:attribute name="UpdateMode" type="SimpleUpdateModeEnum" default="New"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="SimpleUpdateNodeType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_228">Der SimpleUpdateNodeType kennzeichnet alle Knoten, die updatebar sind, deren Kindelemente aber nur alle zusammen upgedatet werden können. Jeder Knoten, der diesen Type oder einer Ableitung von diesem Type entspricht, besitzt diese Eigenschaft. Entscheidend dafür ist das integrierte Attribut "UpdateMode", welches im SimpleUpdateNodeType die Werte "New" oder "Delete" annehmen kann.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_228">The SimpleUpdateNodeType identifies all nodes that can be updated, thus child elements can be included in the update. Each node that corresponds to this type, or to a derivation of this type, possesses this property. The decisive factor is the built-in attribute "UpdateMode" which can take the values "New" or "Delete" ​​in SimpleUpdateNodeType.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="UpdateMode" type="SimpleUpdateModeEnum" default="New">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_229">Dieses Attribut definiert, wie bei Update-Datenlieferungen mit dem über Key eindeutig benannten Knoten und seinen Kindelementen verfahren werden soll. Die möglichen Werte haben folgende Bedeutung: 
- New: Der gesamte Knoten inkl. aller Kindelemente wird durch die Datenlieferung ersetzt. Falls ein Element nicht existiert, wird es erzeugt. Dies ist der Default-Wert! 
- Delete: Der aktuelle Knoten und alle Kindelemente werden gelöscht. </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_229">This attribute defines how to deal with update data deliveries with nodes and their child elements that were uniquely named via Key. The possible values are as follows: 
- New: The entire node, including all child elements, will be replaced by the update. If an element does not exist, it is created. This is the default value. 
- Delete: The current node and all child elements are deleted.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="CompositeUpdateNodeType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_230">Der CompositeUpdateNodeType kennzeichnet alle Knoten, die updatebar sind und deren Kindelemente auch einzeln upgedated werden können. Jeder Knoten, der diesen Type oder einer Ableitung von diesem Type entspricht, besitzt diese Eigenschaft. Entscheidend dafür ist das integrierte Attribut "UpdateMode", welches im SimpleUpdateNodeType die Werte "New", "Merge" oder "Delete" annehmen kann.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_230">The CompositeUpdateNodeType identifies all nodes that can be updated and their child elements that can be updated individually. Each node of this type or derivative of this type has this property. The decisive factor is the built-in attribute "UpdateMode" which can take the values "New", "Merge" or "Delete" ​​in SimpleUpdateNodeType.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="UpdateMode" type="CompositeUpdateModeEnum" default="New">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_231">Dieses Attribut definiert, wie bei Update-Datenlieferungen mit dem über Key eindeutig benannten Knoten und seinen Kindelementen verfahren werden soll. Die möglichen Werte haben folgende Bedeutung: 
- New: Der gesamte Knoten inkl. aller Kindelemente wird durch die Datenlieferung ersetzt. Falls ein Element nicht existiert, wird es erzeugt. Dies ist der Default-Wert! 
- Merge: Es werden nur die gelieferten Kindelemente aktualisiert, alle anderen Kindelemente bleiben unberührt. 
- Delete: Der aktuelle Knoten und alle Kindelemente werden gelöscht. </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_231">This attribute defines how update data deliveries with nodes and their child elements that were uniquely named via Key should behave. The possible values are as follows: 
- New: The entire node, including all child elements, will be replaced by the update. If an element does not exist, it is created. This is the default value.
- Merge: Only the specified child elements are updated, all other child elements are unaffected. 
- Delete: The current node and all child elements are deleted.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="MultipleCompositeUpdateNodeType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_232">Dieser Type definiert CompositeUpdateNodes, die multiple auftreten können. Zur eindeutigen Adressierung brauchen diese Knoten einen bzgl. des übergeordneten Knotens eindeutigen Schlüssel, welcher im Attribute "Key" hinterlegt werden kann. Es handelt sich um eine Ableitung des CompositeUpdateNodeTypes.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_232">This type defines CompositeUpdateNodes that can occur multiple times. To give each node a unique address, it require a unique key referring to the parent node, which can be stored in the attribute "Key". It is a derivative of the CompositeUpdateNodeTypes.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CompositeUpdateNodeType">
				<xs:attribute name="Key" type="KeyType" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_233">In diesem Attribut muss ein für dieses Level eindeutiger Key hinterlegt werden, so dass mit diesem bei späteren Updatelieferung dieser Knoten eindeutig identifiziert werden kann. </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_233">There must be a key unique to this level stored in this attribute, so that later updates of these nodes can be uniquely identified.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MultipleCompositeUpdateNodeWithTagsType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_234">Dieser Type definiert CompositeUpdateNodes, die multiple auftreten können und an denen auch noch Tags platziert werden können. Es handelt sich um eine Ableitung des MultipleCompositeUpdateNodeTypes.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_234">This type defines CompositeUpdateNodes, which can occur in multiples and also accept tags. It is a derivative of the MultipleCompositeUpdateNodeTypes.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MultipleCompositeUpdateNodeType">
				<xs:sequence>
					<xs:element name="Tags" type="TagsType" minOccurs="0" internal:otdsversion="2.0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ProductMultipleCompositeUpdateNodeWithTagsType">
		<xs:complexContent>
			<xs:extension base="MultipleCompositeUpdateNodeType">
				<xs:sequence>
					<xs:element name="Tags" type="TagsType" minOccurs="0" internal:otdsversion="2.0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MultipleSimpleUpdateNodeType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_235">Dieser Type definiert SimpleUpdateNodes, die multiple auftreten können. Zur eindeutigen Adressierung brauchen diese Knoten einen bzgl. des übergeordneten Knotens eindeutigen Schlüssel, welcher im Attribute "Key" hinterlegt werden kann. Es handelt sich um eine Ableitung des SimpleUpdateNodeTypes.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_235">This type defines SimpleUpdateNodes, which can occur multiple times. To give each node a unique address, it require a unique key referring to the parent node, which can be stored in the attribute "Key". It is a derivative of SimpleUpdateNodeTypes.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SimpleUpdateNodeType">
				<xs:attribute name="Key" type="KeyType" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_1">In diesem Attribut muss ein für dieses Level eindeutiger Key hinterlegt werden, so dass mit diesem bei späteren Updatelieferung dieser Knoten eindeutig identifiziert werden kann. </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_1">There must be a key unique to this level stored in this attribute, so that later updates of these nodes can be uniquely identified.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OptionalMultipleSimpleUpdateNodeType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_2">Dieser Type definiert SimpleUpdateNodes, die multiple auftreten können. Zur eindeutigen Adressierung brauchen diese Knoten einen bzgl. des übergeordneten Knoten eindeutigen Schlüssel, welcher im Attribute "Key" hinterlegt werden kann. Es handelt sich um eine Ableitung des SimpleUpdateNodeTypes.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_2">This type defines SimpleUpdateNodes, which can occur multiple times. To give each node a unique address, it require a unique key referring to the parent node, which can be stored in the attribute "Key". It is a derivative of SimpleUpdateNodeTypes.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SimpleUpdateNodeType">
				<xs:attribute name="Key" type="KeyType" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_236">In diesem Attribut muss ein für dieses Level
							eindeutiger Key hinterlegt werden, so dass mit diesem bei späteren
							Updatelieferung dieser Knoten eindeutig identifiziert werden kann. In
							Versionen kleiner als 1.9 ist dieser Key nicht enthalten und wird von
							der Verarbeitung durch Key="Default" ersetzt.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_236">There must be a key unique to this level
							stored in this attribute, so that later updates of these nodes can be
							uniquely identified. In versions older than v1.9 this key is not
							existing and is replaced by the key="default" by the
							processing.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="SimpleUpdateModeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="New"/>
			<xs:enumeration value="Delete"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CompositeUpdateModeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="New"/>
			<xs:enumeration value="Delete"/>
			<xs:enumeration value="Merge"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ConditionalTagType">
		<xs:sequence>
			<xs:element name="Tag" type="TagType"/>
			<xs:element name="Condition" type="ConditionType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:simpleType name="KeyType">
		<xs:restriction base="xs:string">
			<xs:pattern value="[A-Za-z0-9\.\-_|\+]+"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EmptyElementType">
		<xs:restriction base="xs:string">
			<xs:maxLength value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="BaseTagType">
		<xs:union>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:length value="0"/>
				</xs:restriction>
			</xs:simpleType>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:pattern value="[\S]+"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="EmptyTagType">
		<xs:restriction base="xs:string">
			<xs:maxLength value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EmptyKeyType">
		<xs:restriction base="xs:string">
			<xs:maxLength value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EmptySortPriceType">
		<xs:restriction base="xs:string">
			<xs:maxLength value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EmptyPreferenceType">
		<xs:restriction base="xs:string">
			<xs:maxLength value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="BaseTagTypeList">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_237">Eine Liste von Tags</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_237">A list of tags</xs:documentation>
		</xs:annotation>
		<xs:list itemType="BaseTagType"/>
	</xs:simpleType>
	<xs:simpleType name="KeyTypeList">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_238">Eine Liste von Keys</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_238">A list of keys</xs:documentation>
		</xs:annotation>
		<xs:restriction>
			<xs:simpleType>
				<xs:list itemType="KeyType"/>
			</xs:simpleType>
			<xs:minLength value="1"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IdentifierType">
		<xs:restriction base="KeyType"/>
	</xs:simpleType>
	<xs:simpleType name="PersonAgeType">
		<xs:restriction base="xs:unsignedInt"/>
	</xs:simpleType>
	<xs:simpleType name="PriceItemClassTypeList">
		<xs:restriction>
			<xs:simpleType>
				<xs:list itemType="TokenType"/>
			</xs:simpleType>
			<xs:minLength value="1"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="BaggageType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_239">Definition der Gepäckbestimmungen</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_239">Definition of the baggage policy</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Pieces" type="xs:positiveInteger" minOccurs="0" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_240">Anzahl erlaubter Gepäckstücke</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_240">Size of baggage allowance</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Weight" type="FloatWithUnitType" minOccurs="0" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_241">Maximalgewicht je Gepäckstück in der im Element "Unit" angegebenen Einheit</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_241">The maximum weight per item of luggage is specified in the "Unit" element</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Size" type="SizeType" minOccurs="0" internal:otdsversion="1.9"/>
		</xs:sequence>
		<xs:attribute name="BaggageType" type="BaggageTypeEnum" default="Checked">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_242">Dieses Attribut definiert, ob die gelieferten
					Bedingungen für das Handgepäck (Cabin) oder das aufzugebene Gepäck (Checked)
					gelten.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_242">This attribute defines whether the conditions apply to hand luggage (Cabin) and luggage stowed in the hold (Checked).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="RouteType">
		<xs:sequence>
			<xs:element name="Departure" type="RouteNodeType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_243">Abflugbezogene Eigenschaften der Route.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_243">Departure-related features of the route.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Arrival" type="RouteNodeType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_244">Ankunftsbezogene Eigenschaften der Route.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_244">Arrival-related features of the route.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Operating" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_245">Hier können bekannte Operating Carrier und Flugnummern für den Flug hinterlegt werden.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_245">The name of the operating carrier and the flight number are specified here if known.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Carrier" type="CarrierType" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_246">Der Operating Carrier des Segments.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_246">The operating carrier of the segment.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="FlightNumber" type="xs:string" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_247">Flugnummer des Operating Carriers des Segments.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_247">The flight number of the operating carrier of the segment.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="Marketing" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_248">Hier können bekannte Marketing Carrier und Flugnummern für den Flug hinterlegt werden</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_248">The known marketing carrier and flight number can be stated here.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Carrier" type="CarrierType" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_249">Marketing Carrier des Segments.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_249">The marketing carrier of the segment.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="FlightNumber" type="xs:string" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_250">Flugnummer des Marketing-Carriers des Segments.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_250">The flight number(s) of the marketing carrier(s) for the segment.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="FlightType" type="FlightTypeEnum" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_251">Typ des Fluges (main; feeder,wrapper)</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_251">Type of flight (main; feeder, wrapper)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FlightCabinClass" type="FlightCabinClassEnum" minOccurs="0" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_252">Spezifierung der Kabinenklasse (z.B. Economy, PremiumEconomy, Business, First)</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_252">Specification of the booking class (e.g. Economy, PremiumEconomy, Business, First)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ElapsedFlyingTime" type="xs:positiveInteger" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_253">Gesamtreisedauer des Flugs über alle Segmente und Zwischenstopps. Die Gesamtreisedauer wird in Minuten angegeben. Diese Eigenschaft steht bei flacher oder segmentweiser Angabe des Flugs zur Verfügung.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_253">Total duration of the flight across all segments and stopovers. The total duration is specified in minutes. This attribute is for the flat or segmental specification of flight details.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Equipment" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_254">Flugzeug-Typ. (z.B. A380). Weil es innerhalb der Route bei Stopps zu Flugzeugwechseln kommen kann, sind mehrere Flugzeugtypen erlaubt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_254">Aeroplane-Type. (e.g. A380). Since there may be stops en route to change aircraft, several aircraft types may be specified.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StopOvers" type="xs:unsignedInt" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8960">Anzahl Stops innerhalb dieser Route. Technical Stops werden nicht hier, sondern im Element "TechnicalStopOvers" aufgeführt.
Das Weglassen dieses Elementes bedeutet, dass der Lieferant keine Aussage über die Anzahl der Stops machen kann. 
"Direct-Flights" und "NonStop-Flights" dürfen keine StopOvers haben.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8960">The number of stops en route. Technical stops are not indicated here, but rather in the element "TechnicalStopOvers". Leaving out the element means that the supplier can not make a statement about the number of stops.
					"Direct-Flights" and "NonStop-Flights" cannot have StopOvers.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TechnicalStopOvers" type="xs:unsignedInt" minOccurs="0" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_255">Definiert die Anzahl der technischen Stops auf dieser Route. Ein technischer Stop liegt dann vor, wenn die Aufenthaltszeit kleiner als 60 Minuten ist und sowohl Flugzeug als auch Flugnummer und auch der Carrier nicht gewechselt werden.
Das Weglassen dieses Elementes bedeutet, dass der Lieferant keine Aussage über die Anzahl der technischen Stops machen kann.
 "Direct-Flights" dürfen einen technischen Stop haben. "NonStop-Flights" dürfen keinen technischen Stop haben.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_255">Defines the number of technical stops en route. A technical stops is defined as a stop with ground time less than 60 minutes. Neither airplane nor flight number nor carrier change after the stop. 
					Leaving out the element means that the supplier cannot make a statement about the number of technical stops.
					"Direct-Flights" may include a technical stop. "NonStop-Flights" cannot include a technical stop.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="RouteNodeType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_256">Eigenschaften eines Ab- oder Ankunftsknotens innerhalb eines Flugsegments.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_256">The properties of a departure or arrival node within a flight segment.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Airport" type="IataAirportCodeType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_257">An- und Abflughafen des Knotens, angegeben als IATA Airport Code bzw. als IATA MetropolitanAirportCode. Spezialfall: wenn der Code sowohl einen konkreten Flughafen als auch eine Flughafengruppe (MAA - Metropolitan Airport Code) identifiziert, wird nur der konkrete Flughafen 
berücksichtigt. 

Um die Definition der Airport-Codes seitens IATA zu überprüfen, nutzen Sie bitte den Link:  
http://www.iata.org/publications/Pages/code-search.aspx

Eine nicht zwingend vollständige und nicht zwingend korrekte Liste der IATA-Airport-Codes finden Sie unter: 
https://de.wikipedia.org/wiki/Liste_der_IATA-Flughafen-Codes

Eine nicht zwingend vollständige und nicht zwingend korrekte Liste der MAA-Codes finden Sie unter: 
http://wikitravel.org/en/Metropolitan_Area_Airport_Codes</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_257">Departure and arrival airports of the node, supplied as IATA Airport Code or IATA MAA Code. Special case: 
						if the code identifies both, a real airport and a group of airports (MAA - Metropolitan Airport Code), only the real airport is considered.
					    For information about the IATA airport code definition see: 
					    http://www.iata.org/publications/Pages/code-search.aspx
					    
					    You will find a list of the concrete airport codes that is not garanteed to be complete or correct here:
					    https://de.wikipedia.org/wiki/Liste_der_IATA-Flughafen-Codes
					    
					    You will find a list of the MAA-Codes  that is not garanteed to be complete or correct here: 
					    http://wikitravel.org/en/Metropolitan_Area_Airport_Codes</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DateOffset" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_258">Vom Abflugtermin des Flugs aus betrachtetes Offset zur relativen Beschreibung des Ab- oder Ankunftstermins eines Knotens. Durch die relative Angabe von Terminen können Fluggruppen unabhängig von konkreten Terminen beschrieben werden.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_258">Offset, relative to the departure date of the flight, used to describe the departure or arrival date of a node. The relative indication of dates allows flight groups to be described independently of concrete dates.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Time" type="FlightTimeType" minOccurs="0" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_259">Abflug- oder Ankunftszeit eines Flugs. Diese Zeit wird immer in der Lokalzeit des geographischen Kontext angegeben. Im Falle der Abflugzeit ist der geographische Kontext der Abflughafen. Im Falle der Ankunftszeit ist der geographische Kontext der Zielflughafen. 
Für die genauere Spezifizierung der Zeit im Kontext einer Zeitumstellung sollte seit Version 2.0 zusätzlich das Attribut 'UTCOffsetOfTimeZone' angegeben werden.

Es wird empfohlen den UTCOffsetOfTimeZone 2 Tage vor und nach einer Zeitumstellung generell anzugeben, da laut Verarbeitungsmodell die Berechnung von Zeitunterschieden den UTCOffsetOfTimeZone nur dann benutzt, wenn alle Zeitangaben einen UTCOffsetOfTimeZone gesetzt haben.

Sobald eine Zeitangabe ohne UTCOffsetOfTimeZone angegeben ist, so werden alle UTCOffsetOfTimeZone bei der Berechnung ignoriert.
</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_259">Departure or arrival time of a flight.This time always is indicated in the local time of the geographic context. In the case of the departure time the geographic context is the departure airport. In the case of the arrival time the geographic context is the arrival airport. For a more precise specification of the time in the context of a time shift the attribute 'UTCOffsetOfTimeZone' should since version 2.0 also be indicated.
					It is recommended to generally indicate the 'UTCOffsetOfTimeZone' two days before and after a time shift, as according to the processing modell the calculation of time differences only uses the UTCOffsetOfTimeZone if all time indications carry the UTCOffsetOfTimeZone.
					As soon as a time indication carries no UTCOffsetOfTimeZone, all UTCOffsetOfTimeZone will be ignored for the calculation.					
					 </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Terminal" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_260">Abflug- oder Ankunftsterminal eines Flugs.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_260">Departure or arrival terminal of a flight.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="FlightTimeType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_261">Beschreibt eine Zeiteigenschaft, z.B. Abflugzeit,
				oder Ankunftszeit</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_261">Describes a temporal property, e.g. departure or arrival time</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="OtdsTimeType">
				<xs:attribute name="UTCOffsetOfTimeZone" type="UTCOffsetType" internal:otdsversion="2.0">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_262">Das Attribut 'UTCOffsetOfTimeZone' wird lediglich dazu benutzt, die angegebene Zeit im Element "Time" im Falle einer Zeitumstellung genauer zu spezifizieren.
Zur Verdeutlichung: die LocalTime - UTCOffsetOfTimeZone ergibt immer die UTC-Time.

Das UTCOffsetOfTimeZone enthält die Stunden und Minuten Verschiebung zur UTC-Zeit von der Zeitzone, auf die sich die lokale Zeitangabe in LocalTime bezieht. Die Angabe erfolgt im Format [+|-hh:mm].

Durch die entsprechend passende Wahl des UTCOffsetOfTimeZone wird festgelegt, ob die im Element LocalTime angegebene Zeit eine lokale Zeit vor oder nach einer Zeitumstellung ist. Das UTCOffsetOfTimeZone soll damit gewährleisten, dass die Berechnung von Zeitunterschieden auch über eine Zeitumstellung hinaus zu eindeutigen Ergebnissen führt.

Es wird empfohlen, den UTCOffsetOfTimeZone 2 Tage vor und nach einer Zeitumstellung generell zu liefern, da laut Verarbeitungsmodell die Berechnung von Zeitunterschieden den UTCOffsetOfTimeZone nur dann benutzt, wenn alle Zeitangaben einen UTCOffsetOfTimeZone gesetzt haben.

Sobald eine Zeitangabe ohne UTCOffsetOfTimeZone angegeben ist, so werden alle UTCOffsetOfTimeZone bei der Berechnung ignoriert.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_262">The attribute 'UTCOffsetOfTimeZone* is solely used for precisely specifying the given time in the element "Time" in case of a time shift. For clarification: LocalTime - UTCOffsetOfTimeZone always equals the UTC-Time.

The UTCOffsetOfTimeZone contains the hours and minutes describing the difference to the UTC-time of that time zone the local time indication in LocalTime refers to. The indication follows the format [+|-hh:mm].

By choosing the right UTCOffsetOfTimeZone it is specified, if the time stated in the element LocalTime is a local time before or after a time shift. The UTCOffsetOfTimeZone thus is to ensure, that a calculation of time differences leads to unambiguous results even in case of a time shift.

It is recommended to generally include the UTCOffsetOfTimeZone 2 days before and after a time shift, as according to the processing modell the calculation of time differences only uses the UTCOffsetOfTimeZone, if all time indication carry a UTCOffsetOfTimeZone.

As soon as one time indication has no UTCOffsetOfTimeZone, alle UTCOffsetOfTimeZone are being ignored for the evaluation.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="CarrierType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_263">In diesem Typen werden die Eigenschaften eines
				Carriers abgebildet.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_263">In this type, the attributes of a carrier are shown.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Identifier" type="IataAirlineCodeType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_264">Konkreter Carrier-Code entsprechend der IATA 2-letter Airline Code definition. Codes bzw. Airlines können unter diesem Link gesucht werden:

http://www.iata.org/publications/Pages/code-search.aspx 

Eine nicht zwingend vollständige und nicht zwingend korrekte Liste der Codes und Airlines findet sich unter:

https://de.wikipedia.org/wiki/Liste_der_IATA-Airline-Codes
</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_264">Specific carrier code according to the IATA 2-letter airline code definition. Codes respectively airlines may be searched using this link:

http://www.iata.org/publications/Pages/code-search.aspx 

A not necessarily complete nor necessarily correct list of codes and airlines can be found here:

https://en.wikipedia.org/wiki/Airline_codes
</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:simpleType name="FlightTypeEnum">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_265">Typ eines Flugsegments</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_265">Type of a flight segment</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Main"/>
			<xs:enumeration value="Feeder"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IntBooleanType">
		<xs:restriction base="xs:int">
			<xs:pattern value="[0-1]"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IncludeAttributeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="AppliedChildren"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ShortServiceAnnotationType">
		<xs:restriction base="xs:string">
			<xs:minLength value="1"/>
			<xs:maxLength value="50"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="UTCOffsetType">
		<xs:restriction base="xs:string">
			<xs:pattern value="[+-]([01][0-9]|2[0-3]):[0-5][0-9]"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="OtdsTimeType">
		<xs:restriction base="xs:string">
			<xs:pattern value="([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="FigureType">
		<xs:sequence>
			<xs:choice>
				<xs:element name="LocationDistance" type="DistanceLocationEnum" minOccurs="0" internal:otdsversion="1.9">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_478">In diesem Element stehen die Orte zur Auswahl,
							für die eine Distanzangabe möglich ist. Folgende Orte für Distanzangaben
							stehen zur Auswahl: - Beach (Strand) / Entfernungsangabe in Metern -
							CityCenter (Stadtzentrum) / Entfernungsangabe in Kilometern - Shopping
							(nächste Einkaufsmöglichkeit) / Entfernungsangabe in Metern - Airport
							(Flughafen) / Entfernungsangabe in Kilometern - PublicTransport
							(öffentliche Verkehrsmittel) / Entfernungsangabe in Metern - SkiLift
							(Skilift) / Entfernungsangabe in Metern - GolfCourse (Golfplatz) /
							Entfernungsangabe in Metern - Lake (See) / Entfernungsangabe in Metern </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_478">This element displays locations for which a distance entry is possible. The following places can be selected to have distance entries:
- Beach / distance to be entered in metres
- CityCenter / distance to be entered in kilometres
- Shopping (nearest shopping opportunities) / distance to be entered in metres
- Airport / distance to be entered in kilometres
- PublicTransport / distance to be entered in metres
- SkiLift / distance to be entered in metres
- GolfCourse / distance to be entered in metres
- Lake / distance to be entered in metres</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="Facility" type="FigureFacilitiesEnum" minOccurs="0" internal:otdsversion="1.9">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_479">Im Element Facilities stehen vor allem
							Ausstattungsmerkmale zur Verfügung, die näher beschrieben werden können.
							Folgende Informationen können geliefert werden: AmountBedrooms (Anzahl
							Schlafzimmer), UnitSize (Zimmergröße, Ferienhausgröße) / Angabe in
							Quadratmetern, AmountRooms (Anzahl der Zimmer im Hotel), AmountFloors
							(Anzahl Stockwerke), AmountBathrooms (Anzahl
							Badezimmer)</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_479">The Facilities element is primarily used to
							describe the available facilities in more detail. The following
							information can be delivered: AmountBedrooms (amount of bedrooms),
							UnitSize (room size, holiday home size) / to be entered in square
							metres, AmountRooms (amount of rooms in the hotel), AmountFloors (amount
							of floors), AmountBathrooms (amount of bathrooms)</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element name="Value" type="xs:decimal">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_480">In diesem Element wird der Wert zu der in
						LocationDistance oder Facilities gewählten Eigenschaft angegeben. Die
						Einheit, in der dieser Wert geliefert wird, findet sich in der Beschreibung
						von LocationDistance und Facilities.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_480">In this element a value is entered for the selected feature in LocationDistance or Facilities. The unit in which this value should be delivered is written in the description of LocationDistance and Facilities.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="WrapperType">
		<xs:complexContent>
			<xs:extension base="MultipleCompositeUpdateNodeWithTagsType">
				<xs:sequence>
					<xs:element name="Booking" type="BookingType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_538">In diesem Element werden alle Values zusammengefasst, die zum Buchen notwendig sind. Später können über den BookingEntry andere Namespaces ergänzt werden, so das spezifisch für verschiedene Buchungssysteme Values zusammen mit dem dazugehörenden Parameternamen angegeben werden können.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_538">In this element, all values ​​required for booking are combined. Other namespaces can be added to the BookingEntry later, so that values specific to different booking systems are specified along with their corresponding parameter names​​.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Properties" type="PropertiesType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_539">Merkmale und Eigenschaften des AccommodationWrappers</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_539">Features and characteristics of the AccommodationWrapper</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Filter" type="FilterSimpleNodeType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_540">Einschränkungen des AccommodationWrappers</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_540">Restrictions of the AccommodationWrapper</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="PriceItems" type="PriceItemsType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_541">Preisbestandteile des AccommodationWrappers </xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_541">Pricing components of the AccommodationWrapper</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Base Enums -->
	<!-- Start Property Enums -->
	<xs:complexType name="CheckInOutOffsetType">
		<xs:simpleContent>
			<xs:extension base="xs:int">
				<xs:attribute name="Component" type="ComponentAttributeType">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_537">Dieses Attribut gibt den Type einer Komponente
							an. Folgende Typen stehen zur Auswahl: -
							Accommodation, - Flight, - Addon </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_537">This attribute specifies the type of a
							component. In the case of a CombiComponent, type refers to the first
							component indicated. The following types are available: - Accommodation,
							- Flight, - Add-on</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:simpleType name="MatchElementEnum">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_267">In dieser Aufzählung werden die verschiedenen
				Elemente aufgeführt, die beim Matchen benutzt werden können.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_267">In this list the various elements that can be
				used for matching are specified.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="CatchmentAirport"/>
			<xs:enumeration value="DepartureAirport"/>
			<xs:enumeration value="ArrivalAirport"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="BoardTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="None"/>
			<xs:enumeration value="SelfCatering"/>
			<xs:enumeration value="Breakfast"/>
			<xs:enumeration value="HalfBoard"/>
			<xs:enumeration value="HalfBoardPlus"/>
			<xs:enumeration value="FullBoard"/>
			<xs:enumeration value="FullBoardPlus"/>
			<xs:enumeration value="AllInclusive"/>
			<xs:enumeration value="AllInclusivePlus"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="BoardPropertiesEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Diet"/>
			<xs:enumeration value="Vegetarian"/>
			<xs:enumeration value="Kosher"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="UnitTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Single"/>
			<xs:enumeration value="Double"/>
			<xs:enumeration value="Apartment"/>
			<xs:enumeration value="Studio"/>
			<xs:enumeration value="Bungalow"/>
			<xs:enumeration value="Triple"/>
			<xs:enumeration value="Suite"/>
			<xs:enumeration value="Other"/>
			<xs:enumeration value="Family"/>
			<xs:enumeration value="Villa"/>
			<xs:enumeration value="HolidayHome"/>
			<xs:enumeration value="SemidetachedHouse"/>
			<xs:enumeration value="Quad"/>
			<xs:enumeration value="SingleWithChild"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="UnitFacilitiesEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="PremiumSuperior"/>
			<xs:enumeration value="Deluxe"/>
			<xs:enumeration value="SeaView"/>
			<xs:enumeration value="SideSeaView"/>
			<xs:enumeration value="Family"/>
			<xs:enumeration value="Duplex"/>
			<xs:enumeration value="SeaViewSideSeaView"/>
			<xs:enumeration value="PremiumView"/>
			<xs:enumeration value="BalconyTerrace"/>
			<xs:enumeration value="Airconditioning"/>
			<xs:enumeration value="HandicappedAccessible"/>
			<xs:enumeration value="Hairdryer"/>
			<xs:enumeration value="NonSmokerRoom"/>
			<xs:enumeration value="SeparateBedroom"/>
			<xs:enumeration value="MoreSeparateBedrooms"/>
			<xs:enumeration value="PoolView"/>
			<xs:enumeration value="GardenView"/>
			<xs:enumeration value="BathToiletteInCorridor"/>
			<xs:enumeration value="Loft"/>
			<xs:enumeration value="ChargedHeating"/>
			<xs:enumeration value="HourlyHeating"/>
			<xs:enumeration value="BathOnFloor"/>
			<xs:enumeration value="StreetView"/>
			<xs:enumeration value="Basement"/>
			<xs:enumeration value="SharedBathRoom"/>
			<xs:enumeration value="SharedToilette"/>
			<xs:enumeration value="Dishwasher"/>
			<xs:enumeration value="Fireplace"/>
			<xs:enumeration value="PrivatePool"/>
			<xs:enumeration value="TV"/>
			<xs:enumeration value="SatTV"/>
			<xs:enumeration value="PrivateSauna"/>
			<xs:enumeration value="CentralHeating"/>
			<xs:enumeration value="FloorHeating"/>
			<xs:enumeration value="PrivateSolarium"/>
			<xs:enumeration value="LaundryDryer"/>
			<xs:enumeration value="Freezer"/>
			<xs:enumeration value="BathTub"/>
			<xs:enumeration value="Terrace"/>
			<xs:enumeration value="RoofedTerrace"/>
			<xs:enumeration value="PrivateTennisCourt"/>
			<xs:enumeration value="WashingMachine"/>
			<xs:enumeration value="PrivateWhirlpool"/>
			<xs:enumeration value="Shower"/>
			<xs:enumeration value="Balcony"/>
			<xs:enumeration value="TwoBedroomsWithConnectingDoor"/>
			<xs:enumeration value="ShortenedSeaView"/>
			<xs:enumeration value="LakeView"/>
			<xs:enumeration value="GroundFloor"/>
			<xs:enumeration value="UpperFloor"/>
			<xs:enumeration value="RoomSafe"/>
			<xs:enumeration value="Iron"/>
			<xs:enumeration value="PetsAllowed"/>
			<xs:enumeration value="PetsProhibited"/>
			<xs:enumeration value="Minibar"/>
			<xs:enumeration value="CityView"/>
			<xs:enumeration value="MountainView"/>
			<xs:enumeration value="InnercourtView"/>
			<xs:enumeration value="Kitchenette"/>
			<xs:enumeration value="Budget" internal:otdsversion="2.0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AccommodationTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Hotel"/>
			<xs:enumeration value="Club"/>
			<xs:enumeration value="ApartmentHotel"/>
			<xs:enumeration value="HolidayPark"/>
			<xs:enumeration value="Villa"/>
			<xs:enumeration value="HolidayFlat"/>
			<xs:enumeration value="CaravanSite"/>
			<xs:enumeration value="Other"/>
			<xs:enumeration value="BungalowResort"/>
			<xs:enumeration value="Family"/>
			<xs:enumeration value="DetachedHouse"/>
			<xs:enumeration value="RowHouse"/>
			<xs:enumeration value="HolidayHome"/>
			<xs:enumeration value="ElegantAccommodationStyle"/>
			<xs:enumeration value="BoutiqueAccommodationStyle"/>
			<xs:enumeration value="DesignAccommodationStyle"/>
			<xs:enumeration value="HistoricAccommodationStyle"/>
			<xs:enumeration value="RuralAccommodationStyle"/>
			<xs:enumeration value="PalaceHotelStyle"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AccommodationGeneralFacilitiesEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Pool"/>
			<xs:enumeration value="InternetAccess"/>
			<xs:enumeration value="ParkingArea"/>
			<xs:enumeration value="FitnessCenter"/>
			<xs:enumeration value="Wellnessarea"/>
			<xs:enumeration value="IndoorPool"/>
			<xs:enumeration value="Restaurant"/>
			<xs:enumeration value="Reception24_7"/>
			<xs:enumeration value="LaundryService"/>
			<xs:enumeration value="Bar"/>
			<xs:enumeration value="Discothek"/>
			<xs:enumeration value="Shops"/>
			<xs:enumeration value="Airconditioning"/>
			<xs:enumeration value="Garden"/>
			<xs:enumeration value="Hairdresser"/>
			<xs:enumeration value="SunTerrace"/>
			<xs:enumeration value="MeetingRoom"/>
			<xs:enumeration value="TVRoom"/>
			<xs:enumeration value="Lobby"/>
			<xs:enumeration value="RoomService"/>
			<xs:enumeration value="PrivateBeach"/>
			<xs:enumeration value="ArtStudio"/>
			<xs:enumeration value="FreeWIFI"/>
			<xs:enumeration value="Concierge"/>
			<xs:enumeration value="HotelSafe"/>
			<xs:enumeration value="Carport"/>
			<xs:enumeration value="GuardedParkingLot"/>
			<xs:enumeration value="BasementGarage"/>
			<xs:enumeration value="ParkingWithCost"/>
			<xs:enumeration value="FreeParking"/>
			<xs:enumeration value="Garage"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AccommodationFamilyFacilitiesEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="WaterSlide"/>
			<xs:enumeration value="PlayArea"/>
			<xs:enumeration value="Kinderanimation"/>
			<xs:enumeration value="ChildrenEntertainment"/>
			<xs:enumeration value="BabysitterService"/>
			<xs:enumeration value="ChildrenPool"/>
			<xs:enumeration value="FoodForChildren"/>
			<xs:enumeration value="ChildAllowance"/>
			<xs:enumeration value="FamilyRoom"/>
			<xs:enumeration value="PlaneBeach"/>
			<xs:enumeration value="BabyEquipment"/>
			<xs:enumeration value="FamilyExcursion"/>
			<xs:enumeration value="MiniClub"/>
			<xs:enumeration value="SingleWithChild"/>
			<xs:enumeration value="FurnitureForChildren"/>
			<xs:enumeration value="IndoorPlayingArea"/>
			<xs:enumeration value="AquaPark"/>
			<xs:enumeration value="FamilyEntertainment"/>
			<xs:enumeration value="Couples"/>
			<xs:enumeration value="SingleEntertainment"/>
			<xs:enumeration value="BabyCotBeds"/>
			<xs:enumeration value="ChildrenSwimmingSchool"/>
			<xs:enumeration value="ChildrenSportFacilities"/>
			<xs:enumeration value="NonSmookerHotel"/>
			<xs:enumeration value="BuggyRental"/>
			<xs:enumeration value="PoolHeated"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AccommodationSportsFacilitiesEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="FootballGround"/>
			<xs:enumeration value="FitnessRoom"/>
			<xs:enumeration value="OwnDiveCentre"/>
			<xs:enumeration value="TennisCourt"/>
			<xs:enumeration value="GolfCourse"/>
			<xs:enumeration value="BikeRental"/>
			<xs:enumeration value="OwnSurfCentre"/>
			<xs:enumeration value="BeachVolleballCourt"/>
			<xs:enumeration value="WorkoutProgramme"/>
			<xs:enumeration value="ShootingRange"/>
			<xs:enumeration value="OwnSailingCentre"/>
			<xs:enumeration value="MultifunctionLocation"/>
			<xs:enumeration value="FunSportOffers"/>
			<xs:enumeration value="SwimmingPool"/>
			<xs:enumeration value="SportingEntertainment"/>
			<xs:enumeration value="SquashCourt"/>
			<xs:enumeration value="HikingExcursions"/>
			<xs:enumeration value="SportsTournaments"/>
			<xs:enumeration value="ClimbingWallPark"/>
			<xs:enumeration value="BilliardTable"/>
			<xs:enumeration value="WinterSportsFacilities"/>
			<xs:enumeration value="HorsebackRiding"/>
			<xs:enumeration value="BananaBoat"/>
			<xs:enumeration value="Jetski"/>
			<xs:enumeration value="RiverRafting"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AccommodationWellnessFacilitiesEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Sauna"/>
			<xs:enumeration value="WhirlPool"/>
			<xs:enumeration value="Massageangebote"/>
			<xs:enumeration value="Thermalbad"/>
			<xs:enumeration value="BeautyFarm"/>
			<xs:enumeration value="Thalasso"/>
			<xs:enumeration value="Ayurveda"/>
			<xs:enumeration value="Hammam"/>
			<xs:enumeration value="SteamRoom"/>
			<xs:enumeration value="AromaTherapy"/>
			<xs:enumeration value="MedicalWellness"/>
			<xs:enumeration value="RelaxationArea"/>
			<xs:enumeration value="AntiAge"/>
			<xs:enumeration value="Solarium"/>
			<xs:enumeration value="FitnessRoom"/>
			<xs:enumeration value="Shiatsu"/>
			<xs:enumeration value="PlungePool"/>
			<xs:enumeration value="JuiceBar"/>
			<xs:enumeration value="Facial"/>
			<xs:enumeration value="BeautyTreatment"/>
			<xs:enumeration value="ManicurePedicure"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AccommodationSeniorFacilitiesEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="HealthCare"/>
			<xs:enumeration value="Spieleangebote"/>
			<xs:enumeration value="HandicappedAccessible"/>
			<xs:enumeration value="DietCuisine"/>
			<xs:enumeration value="LuggageService"/>
			<xs:enumeration value="CoachExcursions"/>
			<xs:enumeration value="TeaDance"/>
			<xs:enumeration value="TherapeuticBath"/>
			<xs:enumeration value="ShuttleService"/>
			<xs:enumeration value="StaffLanguageSkills"/>
			<xs:enumeration value="Lift"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AccommodationLocationEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="DirectBeach"/>
			<xs:enumeration value="NearBeach"/>
			<xs:enumeration value="Central"/>
			<xs:enumeration value="QuietArea"/>
			<xs:enumeration value="AliveArea"/>
			<xs:enumeration value="CityDestination"/>
			<xs:enumeration value="SurroundedByNature"/>
			<xs:enumeration value="Mountains"/>
			<xs:enumeration value="SkiingArea"/>
			<xs:enumeration value="ThemePark"/>
			<xs:enumeration value="NearAirport"/>
			<xs:enumeration value="SandyBeach"/>
			<xs:enumeration value="ExcursionPossibilities"/>
			<xs:enumeration value="NearShoppingFacilities"/>
			<xs:enumeration value="NearRestaurants"/>
			<xs:enumeration value="Party"/>
			<xs:enumeration value="NearLake"/>
			<xs:enumeration value="SurroundedByGardenPark"/>
			<xs:enumeration value="NearSights"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AccommodationTargetgroupEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="GourmetTravellers"/>
			<xs:enumeration value="Singles"/>
			<xs:enumeration value="LuxuryTravellers"/>
			<xs:enumeration value="Families"/>
			<xs:enumeration value="SeniorTravellers"/>
			<xs:enumeration value="RomanticCouples"/>
			<xs:enumeration value="YoungPeople"/>
			<xs:enumeration value="AdultsOnly"/>
			<xs:enumeration value="Homosexuals"/>
			<xs:enumeration value="AccomodationForCityTravellers"/>
			<xs:enumeration value="AccomodationForCulturalTravellers"/>
			<xs:enumeration value="AccomodationForNatureTravellers"/>
			<xs:enumeration value="WellnessTravellers"/>
			<xs:enumeration value="SportTravellers"/>
			<xs:enumeration value="ShortstayTravellers"/>
			<xs:enumeration value="DogOwner"/>
			<xs:enumeration value="HoneyMooner"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="InternetAccessLocationEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Room"/>
			<xs:enumeration value="Lobby"/>
			<xs:enumeration value="Bar"/>
			<xs:enumeration value="EntireHotel"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="InternetAccessChargeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="WithCharge"/>
			<xs:enumeration value="ForFree"/>
			<xs:enumeration value="NotSpecified"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="InternetAccessTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="WIFI"/>
			<xs:enumeration value="ViaCable"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="GeneralIncludedServiceEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Transfer"/>
			<xs:enumeration value="CheckInTransfer"/>
			<xs:enumeration value="CheckOutTransfer"/>
			<xs:enumeration value="GolfArrangement"/>
			<xs:enumeration value="CarRental"/>
			<xs:enumeration value="WellnessArrangement"/>
			<xs:enumeration value="SportsArrangement"/>
			<xs:enumeration value="Skipass"/>
			<xs:enumeration value="TourArrangement"/>
			<xs:enumeration value="HotelServices"/>
			<xs:enumeration value="GuidedTour"/>
			<xs:enumeration value="OtherServices"/>
			<xs:enumeration value="None"/>
			<xs:enumeration value="Parking"/>
			<xs:enumeration value="CookService"/>
			<xs:enumeration value="LaundryService"/>
			<xs:enumeration value="RollService"/>
			<xs:enumeration value="CleaningService"/>
			<xs:enumeration value="FinalCleanUp"/>
			<xs:enumeration value="RailAndFly"/>
			<xs:enumeration value="SkiLessons"/>
			<xs:enumeration value="SnowboardLessons"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="UnitBuildingTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="NewBuilding"/>
			<xs:enumeration value="OldBuilding"/>
			<xs:enumeration value="Annex"/>
			<xs:enumeration value="SubsidiaryBuilding"/>
			<xs:enumeration value="MainBuilding"/>
			<xs:enumeration value="Dependance"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CarRentalEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="SmallCar"/>
			<xs:enumeration value="CompactCar"/>
			<xs:enumeration value="FamilyCar"/>
			<xs:enumeration value="SuvCar"/>
			<xs:enumeration value="DeluxeCar"/>
			<xs:enumeration value="CampMobile"/>
			<xs:enumeration value="MotorBike"/>
			<xs:enumeration value="CabrioletCar"/>
			<xs:enumeration value="MediumCar"/>
			<xs:enumeration value="Minivan"/>
			<xs:enumeration value="OtherCarType"/>
			<xs:enumeration value="CarInsurance"/>
			<xs:enumeration value="CarFacility"/>
			<xs:enumeration value="CarProductOption"/>
			<xs:enumeration value="AddonPackage"/>
			<xs:enumeration value="OtherRentalCarService"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CarRentalStationTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Airport"/>
			<xs:enumeration value="AirportWithShuttle"/>
			<xs:enumeration value="RentalStation"/>
			<xs:enumeration value="HotelDelivery"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CarRentalProductOptionsEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="TankFullFull"/>
			<xs:enumeration value="TankFullEmptyPrepaid"/>
			<xs:enumeration value="FreeTankOfFuel"/>
			<xs:enumeration value="UnlimitedMileage"/>
			<xs:enumeration value="AdditionalDriver"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CarRentalFacilityEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="AirConditioning"/>
			<xs:enumeration value="Automatic"/>
			<xs:enumeration value="AllWheelDrive"/>
			<xs:enumeration value="NavigationSystem"/>
			<xs:enumeration value="2Doors"/>
			<xs:enumeration value="4DoorsOrMore"/>
			<xs:enumeration value="SnowTires"/>
			<xs:enumeration value="ChildSeat"/>
			<xs:enumeration value="BabySeat"/>
			<xs:enumeration value="Diesel"/>
			<xs:enumeration value="Gas"/>
			<xs:enumeration value="Hybrid"/>
			<xs:enumeration value="ReducedEmission"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CarRentalInsuranceEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CollisionDamageWaiver"/>
			<xs:enumeration value="TheftProtection"/>
			<xs:enumeration value="PersonalAccidentInsurance"/>
			<xs:enumeration value="PersonalAccidentAndLuggageInsurance"/>
			<xs:enumeration value="DamagesGlas"/>
			<xs:enumeration value="DamagesTires"/>
			<xs:enumeration value="DamagesUndercarriage"/>
			<xs:enumeration value="DamagesRoof"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="InsuranceEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="HealthInsurance"/>
			<xs:enumeration value="CancelationInsurance"/>
			<xs:enumeration value="InterceptionInsurance"/>
			<xs:enumeration value="FamilyInsurance"/>
			<xs:enumeration value="LuggageInsurance"/>
			<xs:enumeration value="SportsEquipmentInsurance"/>
			<xs:enumeration value="TransportInsurance"/>
			<xs:enumeration value="Other"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="WellnessArrangementEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="HealthArrangement"/>
			<xs:enumeration value="Massage"/>
			<xs:enumeration value="SaunaSteambath"/>
			<xs:enumeration value="Thalasso"/>
			<xs:enumeration value="Treatments"/>
			<xs:enumeration value="AntiAging"/>
			<xs:enumeration value="BeautyFarm"/>
			<xs:enumeration value="AcuPuncture"/>
			<xs:enumeration value="Other"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SportsArrangementEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Sailing"/>
			<xs:enumeration value="BikeRental"/>
			<xs:enumeration value="BallSports"/>
			<xs:enumeration value="Aerobics"/>
			<xs:enumeration value="SportGym"/>
			<xs:enumeration value="HorseRiding"/>
			<xs:enumeration value="SkiRental"/>
			<xs:enumeration value="WaterSports"/>
			<xs:enumeration value="Surfing"/>
			<xs:enumeration value="Tennis"/>
			<xs:enumeration value="Other"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TransferArrangementEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="HelicopterTransfer"/>
			<xs:enumeration value="PrivateTransfer"/>
			<xs:enumeration value="BoatTransfer"/>
			<xs:enumeration value="BusTransfer"/>
			<xs:enumeration value="TaxiTransfer"/>
			<xs:enumeration value="Other"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="GolfArrangementEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CourseAccess"/>
			<xs:enumeration value="EquipmentRental"/>
			<xs:enumeration value="GolfLesson"/>
			<xs:enumeration value="DrivingRange"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DivingArrangementEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="DivingTour"/>
			<xs:enumeration value="EquipmentRental"/>
			<xs:enumeration value="DivingLesson"/>
			<xs:enumeration value="DivingLicense"/>
			<xs:enumeration value="Other"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TourArrangementEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="BusTour"/>
			<xs:enumeration value="BoatTour"/>
			<xs:enumeration value="AdventureTour"/>
			<xs:enumeration value="PrivateTour"/>
			<xs:enumeration value="Other"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="HotelArrangementEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ButlerService"/>
			<xs:enumeration value="EveryDayCleanService"/>
			<xs:enumeration value="Other"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CityArrangementEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CityPass"/>
			<xs:enumeration value="Tickets"/>
			<xs:enumeration value="Other"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="BoardArrangementEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="GalaDinner"/>
			<xs:enumeration value="FreeSnacks"/>
			<xs:enumeration value="XmasDinner"/>
			<xs:enumeration value="Other"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="FlightSeatArrangementEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="MoreSpace"/>
			<xs:enumeration value="EmergencySeats"/>
			<xs:enumeration value="InfantSeat"/>
			<xs:enumeration value="Other"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="FlightCabinClassEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Economy"/>
			<xs:enumeration value="PremiumEconomy"/>
			<xs:enumeration value="Business"/>
			<xs:enumeration value="First"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- End Property Enums -->
	<xs:simpleType name="OTDSVersionEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="2.0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ShiftEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="None"/>
			<xs:enumeration value="Auto"/>
			<xs:enumeration value="External"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DayReferenceEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CheckIn"/>
			<xs:enumeration value="CheckOut"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IntervalTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Stay"/>
			<xs:enumeration value="CheckInOut"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DateFormatEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="[D01].[M01].[Y0001]"/>
			<xs:enumeration value="[D01][M01][Y01]"/>
			<xs:enumeration value="[D01][M01]"/>
			<xs:enumeration value="[Y0001]-[M01]-[D01]"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AgeTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="DateOfBirth"/>
			<xs:enumeration value="TravelAge"/>
			<xs:enumeration value="BookingAge"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ProductTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="AccommodationOnly"/>
			<xs:enumeration value="OnewayFlightOnly"/>
			<xs:enumeration value="ReturnFlightOnly"/>
			<xs:enumeration value="FlightAccommodation"/>
			<xs:enumeration value="Addon"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="RoleEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ReturnFlight"/>
			<xs:enumeration value="OnewayFlight"/>
			<xs:enumeration value="Outbound"/>
			<xs:enumeration value="Inbound"/>
			<xs:enumeration value="Accommodation"/>
			<xs:enumeration value="Addon"/>
			<xs:enumeration value="AccommodationWrapper"/>
			<xs:enumeration value="FlightWrapper"/>
			<xs:enumeration value="AddonWrapper"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ExecutionOrderEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="BeforeCombinatorics"/>
			<xs:enumeration value="AfterCombinatorics"/>
			<xs:enumeration value="Last"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="GlobalValueEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Subcontractor"/>
			<xs:enumeration value="SalesChannelOnline"/>
			<xs:enumeration value="SalesChannelOffline"/>
			<xs:enumeration value="SalesChannelIntern"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ComponentAttributeType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ThisComponent">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_268">Die Hauptkomponente, in welcher sich die
						aktuelle Komponente befindet.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_268">The main component in which the current
						component is located.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Accommodation"/>
			<xs:enumeration value="OnewayFlight"/>
			<xs:enumeration value="ReturnFlight"/>
			<xs:enumeration value="Flight" internal:otdsversion="2.0"/>
			<xs:enumeration value="Addon"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="BookingReplaceSourceAttributeType">
		<xs:union memberTypes="SourceAttributeType">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="*"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="PriceTypeEnum">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_270">In diesem Element werden die verschiedenen Arten von PriceItems aufgeführt, die keine impliziten Regeln enthalten:
(z.B. Base, Board, EarlyBird, ExtraDay, StayPay, ChildReduction, DurationReduction, ChildPrice, OccupancyReduction etc.) 
Vollständige Liste finden Sie in der Technischen Dokumentation.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_270">In this element, the different types of PriceItems are listed which do not contain implicit rules:
(e.g. Base, Board, EarlyBird, ExtraDay, StayPay, ChildReduction, DurationReduction, ChildPrice, OccupancyReduction etc.)
For the complete list see the technical documentation.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Base"/>
			<xs:enumeration value="Board"/>
			<xs:enumeration value="EarlyBird"/>
			<xs:enumeration value="ExtraDay"/>
			<xs:enumeration value="StayPay"/>
			<xs:enumeration value="ChildReduction"/>
			<xs:enumeration value="DurationReduction"/>
			<xs:enumeration value="ChildPrice"/>
			<xs:enumeration value="OccupancyReduction"/>
			<xs:enumeration value="OccupancySupplement"/>
			<xs:enumeration value="BoardChildReduction"/>
			<xs:enumeration value="BoardSupplement"/>
			<xs:enumeration value="SelfDrivingSupplement"/>
			<xs:enumeration value="GeneralSupplement"/>
			<xs:enumeration value="GeneralDiscount"/>
			<xs:enumeration value="FuelSurcharge"/>
			<xs:enumeration value="AirPassengerDuty"/>
			<xs:enumeration value="AirportSurcharge"/>
			<xs:enumeration value="FlightSupplement"/>
			<xs:enumeration value="FlightTax"/>
			<xs:enumeration value="SecurityCharge"/>
			<xs:enumeration value="FirstMinute"/>
			<xs:enumeration value="LastMinute"/>
			<xs:enumeration value="UltraFirstMinute"/>
			<xs:enumeration value="UltraLastMinute"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="RoundingEnum">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_271">Diese Enumeration gibt die möglichen Modi von Rundungen an.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_271">This enumeration specifies the possible rounding modes.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Normal"/>
			<xs:enumeration value="Up"/>
			<xs:enumeration value="UpEnding"/>
			<xs:enumeration value="Down"/>
			<xs:enumeration value="DownEnding"/>
			<xs:enumeration value="No"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DisplayEnum">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_272">Diese Enumeration beschreibt, wo ein Text
				angezeigt werden soll</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_272">This enumeration describes where a text is to be displayed</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Search"/>
			<xs:enumeration value="Book"/>
			<xs:enumeration value="None"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CrsSystemEnum">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_273">Definiert verschiedene CrsSysteme</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_273">Defines various CrsSystems</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Toma"/>
			<xs:enumeration value="Merlin"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ResellerTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="PackageMixResellers"/>
			<xs:enumeration value="PureResellers"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SalesChannelEnum">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_274">Definiert verschiedene SalesChannel</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_274">Defines various SalesChannels</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="OnlineTravelAgency"/>
			<xs:enumeration value="TravelAgency"/>
			<xs:enumeration value="Intern"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DistributionChannelEnum">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_536">Definiert verschiedene DistributionChannel</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_536">Defines various DistributionChannels</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Bewotec"/>
			<xs:enumeration value="TravelTainment"/>
			<xs:enumeration value="Traffics"/>
			<xs:enumeration value="Schmetterling"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="WeekdayEnum">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_275">Definiert Wochentage (3-stellig):
Mon Tue Wed Thu Fri Sat Sun</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_275">Defines weekdays (3-digit):
Mon Tue Wed Thu Fri Sat Sun</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Mon"/>
			<xs:enumeration value="Tue"/>
			<xs:enumeration value="Wed"/>
			<xs:enumeration value="Thu"/>
			<xs:enumeration value="Fri"/>
			<xs:enumeration value="Sat"/>
			<xs:enumeration value="Sun"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="WeekdayEnumList">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_276">Eine Liste von Wochentagen.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_276">A list of weekdays.</xs:documentation>
		</xs:annotation>
		<xs:list itemType="WeekdayEnum"/>
	</xs:simpleType>
	<xs:simpleType name="NonEmptyWeekdayEnumList">
		<xs:annotation>
			<xs:documentation xml:lang="de">Eine nicht-leere Liste von Wochentagen.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="WeekdayEnumList">
			<xs:minLength value="1"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PersonGenderEnumList">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_277">Eine Liste von Angaben zum Geschlecht der Mitreisenden.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_277">A list of information on the gender of passengers.</xs:documentation>
		</xs:annotation>
		<xs:list itemType="PersonGenderEnum"/>
	</xs:simpleType>
	<xs:simpleType name="IataAirportCodeTypeList">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_278">Eine Liste von Iata-Airport-Codes.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_278">A list of IATA airport codes.</xs:documentation>
		</xs:annotation>
		<xs:list itemType="IataAirportCodeType"/>
	</xs:simpleType>
	<xs:simpleType name="PadOrientationEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Left"/>
			<xs:enumeration value="Right"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AreaEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="GlobalArea"/>
			<xs:enumeration value="ServiceArea"/>
			<xs:enumeration value="PersonArea"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="FieldEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Title"/>
			<xs:enumeration value="Age"/>
			<xs:enumeration value="BrandCode"/>
			<xs:enumeration value="TravelType"/>
			<xs:enumeration value="RequestCode"/>
			<xs:enumeration value="ServiceCode"/>
			<xs:enumeration value="ServiceFeatureCode"/>
			<xs:enumeration value="BoardCode"/>
			<xs:enumeration value="Assignment"/>
			<xs:enumeration value="DateStart"/>
			<xs:enumeration value="DateEnd"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PadConditionEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Always"/>
			<xs:enumeration value="NotFirst"/>
			<xs:enumeration value="NotLast"/>
			<xs:enumeration value="NotAtEnds"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EvaluationBaseEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Person Day"/>
			<xs:enumeration value="Person"/>
			<xs:enumeration value="Day"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AirportTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Departure"/>
			<xs:enumeration value="Arrival"/>
			<xs:enumeration value="Catchment"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DayAllocationEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="First"/>
			<xs:enumeration value="Last"/>
			<xs:enumeration value="All"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EvaluationModeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Any"/>
			<xs:enumeration value="All"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ValueOptionsType">
		<xs:union>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="true|false"/>
					<xs:enumeration value="Numerics"/>
				</xs:restriction>
			</xs:simpleType>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:pattern value="([A-Za-z0-9]+\|)+([A-Za-z0-9]+)"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="ConsideredPriceItemTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Absolute"/>
			<xs:enumeration value="GenericAbsolute"/>
			<xs:enumeration value="Percent"/>
			<xs:enumeration value="All"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="InheritPriceTagsEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ConsideredAbsolutes"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="MatchAvailabilityEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="MatchCount"/>
			<xs:enumeration value="Ignore"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="RoundMethodEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Down"/>
			<xs:enumeration value="Up"/>
			<xs:enumeration value="TowardsZero"/>
			<xs:enumeration value="AwayFromZero"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="FeatureContextEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CityPairProduction"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CompareOperationEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Equal"/>
			<xs:enumeration value="LessThan"/>
			<xs:enumeration value="LessThanOrEqual"/>
			<xs:enumeration value="GreaterThan"/>
			<xs:enumeration value="GreaterThanOrEqual"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AvailabilityStateEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Open"/>
			<xs:enumeration value="Closed"/>
			<xs:enumeration value="Request"/>
			<xs:enumeration value="StopSales"/>
			<xs:enumeration value="Blacklisted"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="LogicalRelationEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="And"/>
			<xs:enumeration value="Or"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AvailabilityStateConditionEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Open"/>
			<xs:enumeration value="Request"/>
		</xs:restriction>
	</xs:simpleType>
	<!--Begin of  rules definition-->
	<xs:complexType name="DayAllocationStartType">
		<xs:attribute name="Source" type="SourceAttributeType" default="Product">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_281">Dieses Attribut referenziert eine bereits allozierte Komponente (diese muss also einen kleineren DayAllocationLevel haben oder aber aus einer ProductComponent stammen). </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_281">This attribute references a component that has already been allocated (it must therefore have a smaller DayAllocationLevel or be derived from a ProductComponent).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DayReference" type="DayReferenceEnum" default="CheckIn">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_282">Dieses Attribut definiert, welches Datum der referenzierten Komponente als StartDatum verwendet werden soll. Dabei wird eine Referenz auf den entsprechenden DayType gesetzt. Folgende Werte sind erlaubt: - CheckIn - CheckOut Standard ist CheckIn.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_282">This attribute defines which the date is to be used as the start date of the referenced component.
This refers to the corresponding DayType.
The following values are permitted:
- CheckIn
- CheckOut

The default is CheckIn.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DayAllocationLevel" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_283">Dieses Attribut gibt das entsprechende DayAllocationLevel an. Default ist 0.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_283">This attribute specifies the corresponding
					DayAllocationLevel. The default is 0.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Offset" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_284">Dieses Attribut definiert einen Offset in Tagen, der zum Startdatum addiert wird.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_284">This attribute defines an Offset in days and is added to the start date.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Shift" type="ShiftEnum" default="None">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_285">Dieses Attribut definiert die automatische Anpassung/Verschiebung des DayAllocationStart. Mögliche Werte sind: 
- None
- Auto 
- External. 
Default ist "None". 
					
Werte abweichend von "None" sind dann notwendig, wenn es sich bei der verwendeten Komponente um eine nicht expandierbare Komponente, also eine Komponente mit einer festen Dauer handelt.
In diesem Falle legt man eine der AllokationsGrenzen fest und setzt die andere auf "Auto". Zusätzlich erlaubt die Angabe des Wertes "External", dass die Wahl des Starttermins von Extern also dem User vorgegeben werden kann.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_285">This attribute defines the automatic adjustment/move of the DayAllocationStart.
Possible values are:
- None
- Auto
- External

The default is "None".

Values ​​other than "None" are required when the component is used as a non-expandable component, i.e. a component with a fixed duration.
In this case, it is used to define one of the allocation limits and sets the other to "Auto".
The value "External" is also allowed and this indicates that the choice of the start date can be set externally, by the user.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="DayAllocationEndType">
		<xs:attribute name="Source" type="SourceAttributeType" default="Product">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_286">Dieses Attribut referenziert eine bereits
					allozierte Komponente (diese muss also einen kleineren DayAllocationLevel haben
					oder aber aus einer ProductComponent stammen). </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_286">This attribute refers to a component that has already been allocated (it must therefore have a smaller DayAllocationLevel or be derived from a ProductComponent.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DayReference" type="DayReferenceEnum" default="CheckOut">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_287">Dieses Attribut definiert, welches Datum der
					referenzierten Komponente als StartDatum verwendet werden soll. Dabei wird eine
					Referenz auf den entsprechenden DayType gesetzt. Folgende Werte sind erlaubt: -
					CheckIn - CheckOut Standard ist CheckOut.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_287">This attribute defines which the date is to be used as the start date of the referenced component.
This refers to the corresponding DayType.
The following values are permitted:
- CheckIn
- CheckOut

The default value is CheckOut.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DayAllocationLevel" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_288">Dieses Attribut gibt das entsprechende
					DayAllocationLevel an. Default ist 0.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_288">This attribute specifies the corresponding
					DayAllocationLevel. The default is 0.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Offset" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_289">Dieses Attribut definiert einen Offset in Tagen, der zum Startdatum addiert wird.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_289">This attribute defines an Offset in days and is added to the start date.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Shift" type="ShiftEnum" default="None">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_290">Diese Attribut definiert die automatische
					Anpassung/Verschiebung des DayAllocationStart. Mögliche Werte sind: - None -
					Auto - External Default ist "None". Werte abweichend von "None" sind dann
					notwendig, wenn es sich bei der verwendeten Komponente um eine nicht
					expandierbare Komponente, also eine Komponente mit einer festen Dauer handelt.
					In diesem Falle legt man eine der AllokationsGrenzen fest und setzt die andere
					auf "Auto". Zusätzlich erlaubt die Angabe des Wertes "External", dass die Wahl
					des Starttermins von Extern also dem User vorgegeben werden
					kann.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_290">This attribute defines the automatic adjustment/move of the DayAllocationStart.
Possible values are:
- None
- Auto
- External

The default is "None".

Values ​​other than "None" are required when the component is used as a non-expandable component, i.e. a component with a fixed duration.
In this case, it is used to define one of the allocation limits and sets the other to "Auto".
The value "External" is also allowed and this indicates that the choice of the start date can be set externally, by the user.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="RulesType">
		<xs:complexContent>
			<xs:extension base="ProductMultipleCompositeUpdateNodeWithTagsType">
				<xs:sequence>
					<xs:element name="Booking" type="BookingType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_291">Diese Buchungsinformationen werden benutzt, um in einer Rule die Buchungsparameter der Einzelkomponenten komplett zu überschreiben. Im Flugbereich wird dies häufig bei der Definition von Flughülsen verwendet, die die Buchungsinformationen der beteiligten Einzelflüge überschreiben.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_291">This booking information is used to completely override the booking parameters of the individual components in a rule. In the context of flights, this is commonly used in defining flight envelopes that override the booking information of the individual flights involved.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Components" type="ComponentsType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_292">In diesem Zweig werden die  Komponenten definiert, die Bestandteil des Produktes sind.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_292">In this branch the components which are part of the product can be defined.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Filter" type="FilterSimpleNodeType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_293">Dieses Element definiert Filterbedingungen, die das Produkt erfüllen muss. Die Filter beziehen sich dabei über das Attribut "Source" auf die unter Components angegebenen Komponenten.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_293">This element defines the filter conditions that must be met by the product. The filter here refers to the attribute "Source" in the components specified under Components.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DayAllocation" type="DayAllocationType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DefineComponentRulesType">
		<xs:complexContent>
			<xs:extension base="MultipleCompositeUpdateNodeType">
				<xs:sequence>
					<xs:element name="Booking" type="BookingType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_296">Diese Buchungsinformationen werden benutzt, um in einer Rule die Buchungsparameter der Einzelkomponenten komplett zu überschreiben. Im Flugbereich wird dies häufig bei der Definition von Flughülsen verwendet, die die Buchungsinformationen der beteiligten Einzelflüge überschreiben.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_296">This booking information is used to completely override the booking parameters of the individual components in a rule. In the context of flights, this is commonly used in defining flight envelopes that override the booking information of the individual flights involved.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Components" type="ComponentsType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_297">In diesem Zweig werden die  Komponenten definiert, die Bestandteil des Produktes sind.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_297">In this branch the components which are part of the product can be defined.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Filter" type="FilterSimpleNodeType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_298">Dieses Element definiert Filterbedingungen, die das Produkt erfüllen muss. Die Filter beziehen sich dabei über das Attribut "Source" auf die unter Components angegebenen Komponenten.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_298">This element defines the filter conditions that must be met by the product. The filter here refers to the attribute "Source" in the components specified under Components.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--Begin of  condition definition-->
	<!--Begin of Condition enums-->
	<xs:simpleType name="DayTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CheckIn">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_300">Ankunftstag</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_300">Day of arrival</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="CheckOut">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_301">Abreisetag</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_301">Day of departure</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Stay">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_302">gesamter Aufenthalt</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_302">Complete duration of stay</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DurationUnitEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Nights"/>
			<xs:enumeration value="Hours"/>
			<xs:enumeration value="Minutes"/>
			<xs:enumeration value="Weeks"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ProductionPreferenceEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CityPairOffers"/>
			<xs:enumeration value="SignificantOffers"/>
		</xs:restriction>
	</xs:simpleType>
	<!--End of Condition enums-->
	<!--Begin of abstract condition types-->
	<xs:complexType name="DateConditionType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_303">Einschränkungen auf ein Datumsintervall oder eine
				Liste von Einzelterminen.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_303">Restrictions on a range of dates or a list of
				individual dates.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BaseDateConditionType">
				<xs:attribute name="DayType" type="DayTypeEnum" default="Stay">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_304">Diese Attribut definiert, auf welche Tage
							einer Reise sich die Date-Bedingung bezieht. - CheckIn bedeutet, die
							Date-Bedingung bezieht sich auf den Start-Termin. - CheckOut bedeutet,
							die Date-Bedingung bezieht sich auf den End-Termin. - Stay bedeutet, die
							Date-Bedingung bezieht sich auf alle Termine ohne den letzten Termin.
							Erstreckt sich eine Komponente nur über einen Tag, so ist dieser Tag
							auch ein "Stay"-Tag. Ursprung von "Stay ist, dass es um alle
							Übernachtungstage geht. In diesem Sinne gehört der Rückreisetermin nicht
							mehr dazu. Stay wird häufig benutzt für Festtagszuschläge, die in der
							Regel nur anfallen, wenn man auch am Festtag vor Ort übernachtet. Preise
							werden in der Regel nur auf Staytage verteilt.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_304">This attribute defines which days of a trip the date condition relates to.
- CheckIn means the date condition relates to the start date.
- CheckOut means the date condition relates to the end date.
- Stay means the date condition applies to all dates excluding the end date. If a component only covers a single day, this day is also a "Stay" day.

"Stay" is based on the total number of nights. For this reason the return date is excluded. Stay is often used for festive surcharges that generally only occur only if one also stays on the holiday day itself. Prices are usually allocated only to Stay days.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BaseDateConditionType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_305">Einschränkungen auf ein Datumsintervall.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_305">Restrictions on a date range.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:sequence>
				<xs:element name="Min" type="xs:date" minOccurs="1" maxOccurs="1">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_306">Dieses Element definiert das kleinste Datum, also die Untergrenze einer Terminspanne. Beispiel: 2012-01-01  definiert alle Termine größer gleich 01.01.2012.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_306">This element defines the earliest date, i.e.
							the lower limit of a range of dates. Example: 2012-01-01 defines all
							dates equal to or later than 01.01.2012.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="Max" type="xs:date" minOccurs="0" maxOccurs="1">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_307">Dieses Element definiert das größte Datum, also die Obergrenze einer Terminspanne. Beispiel: 2012-01-30 definiert alle Termine kleiner gleich 30.01.2012.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_307">This element defines the latest date and thus
							defines the upper limit of a date range. Example: 2012-01-30  defines
							all dates equal to or earlier than 30.01.2012.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:sequence>
				<xs:element name="Max" type="xs:date" minOccurs="1" maxOccurs="1">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_4959">Dieses Element definiert das größte Datum, also die Obergrenze einer Terminspanne. Beispiel: 2016-01-30 definiert alle Termine kleiner gleich 30.01.2016.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_4959">This element defines the largest date, 
							thus the upper limit of a period of time. For example: 2016-01-30 defines
							all dates smaller than or equal to 30.01.2016.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:element name="Dates" type="DateListType" minOccurs="1">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_308">In diesem Element kann eine Liste von Terminen angegeben werden. Wenn der betrachtete Termin mit einem der Termine aus der Liste übereinstimmt, ist die Datumsbedingung erfüllt. Die Termine in der Liste sind durch "Space", also "Leerzeichen" getrennt. Beispiel: 2012-01-01 2012-01-16 2012-02-28</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_308">In this element a list of dates can be specified. When the subject date matches one of the dates from the list, the date condition is met. The dates in the list are separated by spaces.

Example: 2012-01-01 2012-01-16 2012-02-28</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:attributeGroup ref="SourceAttributeGroup"/>
	</xs:complexType>
	<xs:complexType name="BookingDateConditionType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_309">Einschränkungen auf ein Datumsintervall oder eine
				Liste von Einzelterminen.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_309">Restrictions on a range of dates or a list of
individual dates.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BaseDateConditionType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BookingOffsetConditionType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_310">In diesem Element werden Einschränkungen des
				Zeitabstand in Tagen zwischen Buchungstag und CheckIn-Termin
				definiert.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_310">This element indicates restrictions on the time
				interval in days between the booking date and check-in date.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:sequence>
				<xs:element name="Min" type="xs:unsignedInt" minOccurs="1">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_311">Dieses Element beinhaltet den minimalen Zeitabstand in Tagen zwischen Buchungstag und CheckIn-Termin. Hiermit wird "Rolling EarlyBird" abgebildet. Dieser Wert wird für die Berechnung von Frühbucherpreisen benutzt, bei denen die Buchung mindestens eine bestimmte Anzahl von Tagen vor dem CheckIn, also der Anmeldung am Ankunftsort stattfinden muss. </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_311">This element contains the minimum time interval in days between the date of booking and check-in. This is used to indicate "RollingEarlyBird". This value is used for the calculation of early-bird prices, where the booking must occur a specified number of days before check-in, that is the registration at the destination.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="Max" type="xs:unsignedInt" minOccurs="0">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_312">Dieses Element beinhaltet den maximalen Zeitabstand in Tagen zwischen Buchungstag und CheckIn-Termin. Hiermit wird "Rolling EarlyBird" abgebildet. Dieser Wert wird für Berechnung von Frühbucherpreisen benutzt, bei denen die Buchung eine bestimmte Anzahl von Tagen vor dem CheckIn, also der Anmeldung am Ankunftsort stattfinden muss.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_312">This element contains the maximum time interval in days between the date of booking and check-in. This is used to display "RollingEarlyBird". This value is used for the calculation of early-bird prices, where the booking must occur a specified number of days prior to check-in, that is the registration at the destination.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:element name="Max" type="xs:unsignedInt" minOccurs="1">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_4960">Dieses Element beinhaltet den maximalen Zeitabstand in Tagen zwischen Buchungstag und CheckIn-Termin. Hiermit wird "Rolling EarlyBird" abgebildet. Dieser Wert wird für Berechnung von Frühbucherpreisen benutzt, bei denen die Buchung eine bestimmte Anzahl von Tagen vor dem CheckIn, also der Anmeldung am Ankunftsort stattfinden muss.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_4960">This element contains the maximum time lag in days between booking day and check-in date. Herewith the "Rolling EarlyBird" is displayed. This value is used for the calculation of early bird prices, for which the booking must take place a certain number of days prior to the check-in, hence the registration in the destination.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:attributeGroup ref="SourceAttributeGroup"/>
	</xs:complexType>
	<xs:complexType name="DurationStartType">
		<xs:attribute name="Source" type="SourceAttributeType" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8893">Identifiziert die Komponente, deren Checkin- oder
					Checkout-Datum zur Emittlung des Startdatums einer Duration verwendet wird. Wird dieses Attribut nicht geliefert, so wird der Wert aus Duration/@Source benutzt. 

Falls die Auflösung der Source mehrdeutig ist, so wird die Komponente in Abhängigkeit von DayReference referenziert. 

Bei DayReference="CheckIn" wird die logisch erste KomponentenInstanz referenziert. 

Bei DayReference="CheckOut" wird die logisch letzte KomponentenInstanz referenziert. 

Logisch bedeutet, dass es die Reihenfolge ist, die durch das Attribut "DayAllocation" in der Product-Definition festgelegt wird. </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8893">Identifies the component whose checkin or checkout date is
					used in order to determine the start date of a duration. If this attribute is not delivered, the value from Duration/@Source is used.
					In case the break-up of Source is ambiguous, the component will be referenced in dependency to DayReference.
					For DayReference="CheckIn" the logically first ComponentInstance is referenced.
					For DayReference="CheckOut" the logically last ComponentInstance is referenced.
					"Logically" means, that the attribute "DayAllocation" in the Product Definition defines the order.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DayReference" type="DayReferenceEnum" default="CheckIn">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8894">Identifiziert die Art des Datums (Checkin oder
					Checkout) der referenzierten Komponente, welches als Startdatum der Duration
					verwendet werden soll.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8894">Identifies the kind of date (checkin or checkout) of
					the referenced component to be used as a start date of a duration.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Offset" type="xs:integer" default="0">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8895">Diese Anzahl von Tagen ist zum Reisedatum der
					referenzierten Komponente zu addieren, um das Startdatum der Duration zu
					bestimmen. Negative/positive Werte bedeuten ein früheres/späteres Startdatum der
					Duration, verglichen mit dem Reisedatum.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8895">This number of days must be added to the travel date
					of the referenced component in order to obtain the start date of the duration.
					Negative/positive values signify an earlier/later start date or the duration,
					compared to the travel date.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="DurationEndType">
		<xs:attribute name="Source" type="SourceAttributeType" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8896">Identifiziert die Komponente, deren Checkin- oder
					Checkout-Datum zur Emittlung des Endedatums einer Duration verwendet wird. Wird dieses Attribut nicht geliefert, so wird der Wert aus Duration/@Source benutzt.

Falls die Auflösung der Source mehrdeutig ist, so wird die Komponente in Abhängigkeit von DayReference referenziert. 

Bei DayReference="CheckIn" wird die logisch erste KomponentenInstanz referenziert. 

Bei DayReference="CheckOut" wird die logisch letzte KomponentenInstanz referenziert. 

Logisch bedeutet, dass es die Reihenfolge ist, die durch das Attribut "DayAllocation" in der Product-Definition festgelegt wird. </xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8896">Identifies the component whose checkin or checkout date is
					used in order to determine the end date of a duration. If this attribute is not delivered, the value from Duration/@Source is used.
					In case the break-up of Source is ambiguous, the component will be referenced in dependency to DayReference.
					For DayReference="CheckIn" the logically first ComponentInstance is referenced.
					For DayReference="CheckOut" the logically last ComponentInstance is referenced.
					"Logically" means, that the attribute "DayAllocation" in the Product Definition defines the order.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DayReference" type="DayReferenceEnum" default="CheckOut">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8897">Identifiziert die Art des Datums (Checkin oder
					Checkout) der referenzierten Komponente, welches als Endedatum der Duration
					verwendet werden soll.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8897">Identifies the kind of date (checkin or checkout) of
					the referenced component to be used as an end date of a duration.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Offset" type="xs:integer" default="0">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8898">Diese Anzahl von Tagen ist zum Reisedatum der
					referenzierten Komponente zu addieren, um das Endedatum der Duration zu
					bestimmen. Negative/positive Werte bedeuten ein früheres/späteres Endedatum der
					Duration, verglichen mit dem Reisedatum.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8898">This number of days must be added to the travel date
					of the referenced component in order to obtain the end date of the duration.
					Negative/positive values signify an earlier/later end date of the duration,
					compared to the travel date.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="DurationConditionType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_313">In diesem Element ist es möglich, Einschränkungen
				auf Dauern zu definieren.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_313">In this element, it is possible to define restrictions on durations.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DurationStart" type="DurationStartType" minOccurs="0" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8899">Über die Attribute in DurationStart und DurationEnd werden Termine referenziert. Die Dauer ergibt sich aus der Differenz der Termine von DurationEnd-DurationStart.
Es sollte dabei berücksichtigt werden, dass die Termine der jeweiligen Komponenten immer bezogen auf die Lokalzeit der jeweiligen Komponente sind.
Fehlt das Element "DurationStart" oder "DurationEnd", so ergibt sich der zu verwendende Default jeweils aus den im Element definierten/beschriebenen Defaults der Attribute.
</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8899">Via the attribute in DurationStart and DurationEnd dates are being referenced. The duration results from the difference DurationEnd-DurationStart.
One should take into account that the dates of the single components always refer to the local time of the component.
In case the element "DurationStart" or "DurationEnd" is missing, the default that needs to be used reults from the defaults of the attributes defined/described in the element.
</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DurationEnd" type="DurationEndType" minOccurs="0" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8900">Über die Attribute in DurationStart und DurationEnd werden Termine referenziert. Die Dauer ergibt sich aus der Differenz der Termine von DurationEnd-DurationStart.

Es sollte dabei berücksichtigt werden, dass die Termine der jeweiligen Komponenten immer bezogen auf die Lokalzeit der jeweiligen Komponente sind.

Fehlt das Element "DurationStart" oder "DurationEnd", so ergibt sich der zu verwendende Default jeweils aus den im Element definierten/beschriebenen Defaults der Attribute.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8900">Via the attribute in DurationStart and DurationEnd dates are being referenced. The duration results from the difference DurationEnd-DurationStart.
One should take into account that the dates of the single components always refer to the local time of the component.
In case the element "DurationStart" or "DurationEnd" is missing, the default that needs to be used reults from the defaults of the attributes defined/described in the element.
</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:choice>
				<xs:sequence>
					<xs:element name="Min" type="xs:unsignedInt">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_314">Mindestaufenthaltsdauer</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_314">Minimum stay</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Max" type="xs:unsignedInt" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_315">Maximalaufenthaltsdauer</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_315">Maximum stay</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:sequence>
					<xs:element name="Max" type="xs:unsignedInt">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_503">Maximalaufenthaltsdauer</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_503">Maximum stay</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:element name="Durations">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_316">In diesem Element können eine oder mehrere durch Space getrennte Durations definiert werden.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_316">In this element, one or more durations separated by spaces are defined.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:list itemType="xs:unsignedInt"/>
					</xs:simpleType>
				</xs:element>
				<xs:element name="MultiplesOf" type="xs:unsignedInt">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_317">Nur Dauern mit dieser Schrittweite sind erlaubt, 
z.B. bei 7: es sind nur die Dauern 7, 14, 21, 28, ... erlaubt</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_317">Only durations in these increments are allowed,
e.g. in multiples of 7: thus only durations of 7, 14, 21, 28, ... are allowed</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
		</xs:sequence>
		<xs:attributeGroup ref="SourceAttributeGroup"/>
		<xs:attribute name="DurationUnit" type="DurationUnitEnum" default="Nights">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_318">Gibt an, in welcher Einheit die Dauer angegeben
					wird. Standard ist Nights. Falls das Attribut nicht angegeben ist, wird der
					Standard benutzt.

Über die Attribute in DurationStart und DurationEnd werden Termine referenziert. Beim Value "Nights" ergibt sich die Dauer aus der Differenz der Termine von DurationEnd-DurationStart.

Bei Angabe der DurationUnit = "Hours" werden die in Min, Max, Durations, MultiplesOf angegebenen Werte in Stunden angegeben.
Für den Vergleich mit der über DurationStart und DurationEnd ermittelten Dauer in Nächten werden diese Angaben durch 24 geteilt und abgerundet.

Bei Angabe der DurationUnit = "Minutes" sind die in Min, Max, Durations, MultiplesOf angegebenen Werte in Minuten angegeben.
Für den Vergleich mit der über DurationStart und DurationEnd ermittelten Dauer in Nächten werden diese Angaben durch 1440 geteilt und abgerundet.

Bei Angabe der DurationUnit = "Weeks" sind die in Min, Max, Durations, MultiplesOf angegebenen Werte in Wochen angegeben.
Für den Vergleich mit der über DurationStart und DurationEnd ermittelten Dauer in Nächten werden diese Angaben mit 7 multipliziert.

Danach wird mit den ermittelten Werten geprüft, ob die definierte Bedingung erfüllt ist.
</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_318">Indicates in which unit the duration should be entered. Nights is the default. If the attribute is not specified, the default value will be used.
				Via the attributes in DurationStart and DurationEnd dates are referenced, For the value "Nights" the duration results from the difference in time of DurationEnd-DurationStart.
				When indicating the DurationUnit = "Hours", the values for Min, Max, Durations, and MultiplesOf are stated in hours.
				For comparing this value with the duration in number of nights as result of the difference between DurationStart and DurationEnd, the value is devided by 24 and rounded down. 
				When indicating the DurationUnit = "Minutes", the values for Min, Max, Durations, and MultiplesOf are stated in minutes
				For comparing this value with the duration in number of nights as result of the difference between DurationStart and DurationEnd, the value is devided by 1440 and rounded down. 
				When indicating the DurationUnit = "Weeks", the values for Min, Max, Durations, and MultiplesOf are stated in weeks.
				For comparing this value with the duration in number of nights as result of the difference between DurationStart and DurationEnd, the value is multiplied by 7. 
				Afterwards the results serve for verifying if the defined condition is fulfilled. 
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="PersonGendersConditionType">
		<xs:simpleContent>
			<xs:extension base="PersonGenderEnumList">
				<xs:attributeGroup ref="ConditionAttributeGroup"/>
				<xs:attributeGroup ref="SourceAttributeGroup"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="GroupStartDateType">
		<xs:simpleContent>
			<xs:extension base="EmptyElementType">
				<xs:attribute name="Source" type="SourceAttributeType" use="optional">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8901">Identifiziert die Komponente, deren Checkin- oder Checkout-Datum zur Emittlung des Startdatums der Gruppe verwendet wird. 

Ist dieses Attribut nicht angegeben, so gilt der unter CandidateInstance/@Source angegebene Source-Value</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8901">Identifies the component whose checkin or checkout date is
							used in order to determine the start date of a group. 
							If this attribute is not indicated, the Source value stated under CandidateInstance/@Source is valid.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="DayReference" type="DayReferenceEnum" default="CheckIn">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8902">Identifiziert die Art des Datums (Checkin oder Checkout) der referenzierten Komponente, welches als Startdatum der Gruppe verwendet werden soll.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8902">Identifies the kind of date (checkin or checkout) of
							the referenced component to be used as a start date of a group.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="GroupEndDateType">
		<xs:simpleContent>
			<xs:extension base="EmptyElementType">
				<xs:attribute name="Source" type="SourceAttributeType" use="optional">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8903">Identifiziert die Komponente, deren Checkin- oder Checkout-Datum zur Emittlung des Endedatums einer Gruppe verwendet wird.

Ist dieses Attribut nicht angegeben, so gilt der unter CandidateInstance/@Source angegebene Source-Value</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8903">Identifies the component whose checkin or checkout date is
							used in order to determine the end date of a group.
							If this attribute is not indicated, the Source value stated under CandidateInstance/@Source is valid.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="DayReference" type="DayReferenceEnum" default="CheckOut">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8904">Identifiziert die Art des Datums (Checkin oder Checkout) der referenzierten Komponente, welches als Endedatum der Gruppe verwendet werden soll.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8904">Identifies the kind of date (checkin or checkout) of
							the referenced component to be used as an end date of a group.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="WeekdayConditionType">
		<xs:simpleContent>
			<xs:extension base="NonEmptyWeekdayEnumList">
				<xs:attributeGroup ref="SourceAttributeGroup"/>
				<xs:attribute name="DayType" type="DayTypeEnum" default="CheckIn">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_319">Diese Attribut definiert, auf welche Tage einer Reise sich die Date-Bedingung bezieht. - CheckIn bedeutet, die Date-Bedingung bezieht sich auf den Start-Termin. - CheckOut bedeutet, die Date-Bedingung bezieht sich auf den End-Termin. - Stay bedeutet, die Date-Bedingung bezieht sich auf alle Termine ohne den letzten Termin. Ursprung ist, dass es um alle Übernachtungstage geht. In diesem Sinne gehört der Rückreisetermin nicht mehr dazu. Stay wird häufig benutzt für Festtagszuschläge, die in der Regel nur anfallen, wenn man auch am Festtag vor Ort übernachtet.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_319">This attribute defines which days of a trip the date condition relates to.
- CheckIn means the date condition relates to the start date.
- CheckOut means the date condition relates to the end date.
- Stay means the date condition applies to all dates excluding the end date.
This is based on the total number of nights For this reason the return date is excluded. Stay is often used for festive surcharges that generally occur only if one also stays on the holiday day.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="AirportConditionType">
		<xs:simpleContent>
			<xs:extension base="IataAirportCodeTypeList">
				<xs:attributeGroup ref="SourceAttributeGroup"/>
				<xs:attribute name="AirportType" type="AirportTypeEnum" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_320">Dieses Attribut gibt den namen des Elementes an, mit dem die Flughäfen der Bedingung verglichen werden. Das Element muss ein KindElement der durch das Attribut "Source" definierten Unterkomponente sein. </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_320">This attribute specifies the name of the element, which is to be compared to the condition's airport. This element must be a child element defined by a sub-component of the "Source" attribute.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="AgeConditionType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_323">In diesem Element werden Einschränkungen auf das
				Alter definiert.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_323">This element defines age
				restrictions.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Min" type="xs:unsignedInt" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_324">Mindestalter des Reiseteilnehmers</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_324">Minimum age of the passenger</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Max" type="xs:unsignedInt" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_325">Maximales Alter des Reiseteilnehmers</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_325">Maximum age of the passenger</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MinDateOfBirth" type="xs:date" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_326">Minimales Geburtsdatum des Reiseteilnehmers</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_326">Earliest birth date of the passenger</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaxDateOfBirth" type="xs:date" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_327">Maximales Geburtsdatum des Reiseteilnehmers</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_327">Latest birth date of the passenger</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="ConditionAttributeGroup"/>
		<xs:attributeGroup ref="SourceAttributeGroup"/>
	</xs:complexType>
	<xs:complexType name="TagConditionType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_328">Der TagConditionType definiert die Bedingung an
				bestimmte Tags inklusive Angabe der Class, Location und Werte des Tags. Tags sind
				Wertepaare, die an definierten Knotenpunkten angegeben werden können. Dadurch kann
				man Einfluss nehmen auf die Angebotserstellung und auch auf die
				Preisberechnung.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_328">The TagConditionType defines the condition of
				certain tags, as well as specifying the class, location and value of the tag. Tags
				are pairs of values ​​that can be specified at defined nodes. This allows you to
				influence the preparation of the offer and also the pricing.</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="BaseTagTypeList">
				<xs:attributeGroup ref="ConditionAttributeGroup"/>
				<xs:attributeGroup ref="SourceAttributeGroup"/>
				<xs:attribute name="Class" type="TokenType" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_329">Diese Attribut bietet eine zusätzliche
							Bedingung an die Tags des Zielknotens. Ein Zielknoten kann die Bedingung
							nur erfüllen, wenn die Class den gleichen Wert enthält. Ist die Class in
							der Bedingung nicht besetzt oder leer, gilt die Bedingung bzgl. Class
							als erfüllt.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_329">This attribute is an additional condition on the tag of the destination node. A destination node can satisfy the condition only if the class contains the same value. If the class is not specified or is empty, the condition regarding class is considered fulfilled.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Offset" type="xs:unsignedInt">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_330">Gibt die Position an, ab der der Body des Tag-Elementes verglichen werden soll. (Default ist Position 0 - dies entspricht dem ersten Zeichen.)
						</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_330">Specifies the location from which the body of the tag element is to be compared. (The default position is 0 - this corresponds to the first character.)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Length" type="xs:unsignedInt">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_331">Gibt die Anzahl der Zeichen an, die im Body des Tag-Elementes verglichen werden sollen. Ist das Attribut nicht besetzt, so wird immer der Body des TagElementes bis zum Ende der Zeichenkette verglichen. </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_331">Specifies the number of characters to be compared in the body of the tag element. If the attribute is not specified, the body of the TagElement is compared to the end of the character string.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="EmptyKeyConditionType">
		<xs:simpleContent>
			<xs:extension base="EmptyKeyType">
				<xs:attributeGroup ref="ConditionAttributeGroup"/>
				<xs:attributeGroup ref="SourceAttributeGroup"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="EmptyTagConditionType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_332">Der TagConditionType definiert die Bedingung an
				bestimmte Tags inklusive Angabe der Class, Location und Werte des Tags. Tags sind
				Wertepaare, die an definierten Knotenpunkten angegeben werden können. Dadurch kann
				man Einfluss nehmen auf die Angebotserstellung und auch auf die
				Preisberechnung.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_332">The TagConditionType defines the condition of
				certain tags, as well as specifying the class, location and value of the tag. Tags
				are pairs of values ​​that can be specified at defined nodes. This allows you to
				influence the preparation of the offer and also the pricing.</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="EmptyTagType">
				<xs:attributeGroup ref="ConditionAttributeGroup"/>
				<xs:attributeGroup ref="SourceAttributeGroup"/>
				<xs:attribute name="Class" type="TokenType" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_333">Diese Attribut bietet eine zusätzliche
							Bedingung an die Tags des Zielknotens. Ein Zielknoten kann die Bedingung
							nur erfüllen, wenn die Class den gleichen Wert enthält. Ist die Class in
							der Bedingung nicht besetzt oder leer, gilt die Bedingung bzgl. Class
							als erfüllt.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_333">This attribute is an additional condition on the tags of the destination node. A destination node can satisfy the condition only if the class contains the same value. If the class is not specified or is empty, the condition regarding class is considered to be fulfilled.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Offset" type="xs:unsignedInt">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_334">Gibt die Position an, ab der der Body des Tag-Elementes verglichen werden soll. (Default ist Position 0 - dies entspricht dem ersten Zeichen.)
						</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_334">Specifies the location from which the body of the tag element is to be compared. (The default position is 0 - this corresponds to the first character.)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Length" type="xs:unsignedInt">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_335">Gibt die Anzahl der Zeichen an, die im Body des Tag-Elementes verglichen werden sollen. Ist das Attribut nicht besetzt, so wird immer der Body des TagElementes bis zum Ende der Zeichenkette verglichen. </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_335">Specifies the number of characters to be compared in the body of the tag element. If the attribute is not specified, the body of the TagElements is compared to the end of the character string.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="TagValueType" type="TagValueTypeEnum" default="String">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_336">Definiert den TagType des referenzierten Tags. Stimmt der TagType nicht mit dem TagType der TagDefinition überein, so wird als Value für den Tag der Wert="" verwendet.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_336">Defines the TagType of the tags referred to. If the TagType does not match the TagType in the TagDefinition, the value for the tag used is Value="".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="EmptyTagGroupedByEqualType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_905">Der Typ definiert die Bedingung an Tags, die zur Gruppenbildung
				verwendet werden sollen. Die Bedingung enthält eine Angabe der Class, Location und Werte des Tags. 
				Tags sind Wertepaare, die an definierten Knotenpunkten angegeben werden können. Dadurch kann
				man Einfluss nehmen auf die Angebotserstellung und auch auf die
				Preisberechnung.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_8905">The type defines conditions which select the tags to be used for defining
				groups. The condition specifies the class, location and value of the tag. Tags
				are pairs of values ​​that can be specified at defined nodes. This allows you to
				influence the preparation of the offer and also the pricing.</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="EmptyTagType">
				<xs:attribute name="DayAllocation" type="DayAllocationEnum" default="First"/>
				<xs:attributeGroup ref="SourceAttributeGroup"/>
				<xs:attribute name="Class" type="TokenType" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8906">Diese Attribut bietet eine zusätzliche
							Bedingung an die Tags des Zielknotens. Ein Zielknoten kann die Bedingung
							nur erfüllen, wenn die Class den gleichen Wert enthält. Ist die Class in
							der Bedingung nicht besetzt oder leer, gilt die Bedingung bzgl. Class
							als erfüllt.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8906">This attribute is an additional condition on the tags of the destination node. A destination node can satisfy the condition only if the class contains the same value. If the class is not specified or is empty, the condition regarding class is considered to be fulfilled.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Offset" type="xs:unsignedInt">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8907">Gibt die Position an, ab der der Body des Tag-Elementes verglichen werden soll. (Default ist Position 0 - dies entspricht dem ersten Zeichen.)
						</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8907">Specifies the location from which the body of the tag element is to be compared. (The default position is 0 - this corresponds to the first character.)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Length" type="xs:positiveInteger">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8908">Gibt die Anzahl der Zeichen an, die im Body des Tag-Elementes verglichen werden sollen. Ist das Attribut nicht besetzt, so wird immer der Body des TagElementes bis zum Ende der Zeichenkette verglichen. </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8908">Specifies the number of characters to be compared in the body of the tag element. If the attribute is not specified, the body of the TagElements is compared to the end of the character string.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="TagValueType" type="TagValueTypeEnum" default="String">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8909">Definiert den TagType des referenzierten Tags. Stimmt der TagType nicht mit dem TagType der TagDefinition überein, so wird als Value für den Tag der Wert="" verwendet.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8909">Defines the TagType of the tags referred to. If the TagType does not match the TagType in the TagDefinition, the value for the tag used is Value="".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="CompareValuesConditionType">
		<xs:simpleContent>
			<xs:extension base="BaseTagTypeList"/>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="ConditionalTagConditionType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_337">Der TagConditionType definiert die Bedingung an
				bestimmte Tags inklusive Angabe der Class, Location und Werte des Tags. Tags sind
				Wertepaare, die an definierten Knotenpunkten angegeben werden können. Dadurch kann
				man Einfluss nehmen auf die Angebotserstellung und auch auf die
				Preisberechnung.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_337">The TagConditionType defines the condition of
				certain tags, as well as specifying the class, location and value of the tag. Tags
				are pairs of values ​​that can be specified at defined nodes. This allows you to
				influence the preparation of the offer and also the pricing.</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="BaseTagTypeList">
				<xs:attributeGroup ref="ConditionAttributeGroup"/>
				<xs:attributeGroup ref="SourceAttributeGroup"/>
				<xs:attribute name="Class" type="TokenType" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_338">Class benennt das Tag und ist somit eine weitere Spezifizierung.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_338">Class names the tag and is therefore a further specification.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Offset" type="xs:unsignedInt">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_339">Gibt die Position an, ab der der String verglichen werden soll. (Default ist Position 0 - dies entspricht dem ersten Zeichen.)
						</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_339">Specifies the position at which the string is to be compared. (The default position is 0 - this corresponds to the first character.)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Length" type="xs:unsignedInt">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_340">Gibt die Länge des zu vergleichenden Substring an. (Default ist der komplette String, beginnend ab Offset.)</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_340">Specifies the length of the substring to be compared. (Default is the full string, starting at offset).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="RuleComponentBaseType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_341">Von diesem Basistyp werden für die verschiedenen
				Rule-Components mehrere Ableitungen erzeugt, um spätere individuelle Erweiterungen
				zu ermöglichen (unterschiedliche Unterkomponenten).</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_341">For the various Rule-Components several derivations are generated based on this
				base type, in order to later enable individual extensions (different sub-components).</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="ProductComponentGroup"/>
	</xs:complexType>
	<xs:complexType name="RuleAccommodationComponentType">
		<xs:complexContent>
			<xs:extension base="RuleComponentBaseType">
				<xs:sequence maxOccurs="2">
					<xs:element name="SellingAccom" type="RuleSellingAccomComponentType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleAccommodationWrapperComponentType">
		<xs:complexContent>
			<xs:extension base="RuleComponentBaseType">
				<xs:choice minOccurs="1" maxOccurs="unbounded">
					<xs:element name="Accommodation" type="RuleAccommodationComponentType"/>
					<xs:element name="CombiComponent" type="RuleCombiComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_9002">Hier können nur CombiComponents mit der Role="Accommodation" definiert werden.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_9002">Here only CombiComponents with the Role="Accommodation" may be defined.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefinedComponent" type="RuleDefinedComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_552">Hier können nur DefinedComponents mit der Role="Accommodation" definiert werden.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_552">Here only DefinedComponents with the Role="Accommodation" may be defined.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleFlightWrapperComponentType">
		<xs:complexContent>
			<xs:extension base="RuleComponentBaseType">
				<xs:choice minOccurs="1" maxOccurs="unbounded">
					<xs:element name="OnewayFlight" type="RuleOnewayFlightComponentType"/>
					<xs:element name="CombiComponent" type="RuleCombiComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_553">Hier können nur CombiComponents mit der Role="OnewayFlight" oder "Outbound" definiert werden.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_553">Here only CombiComponents with the Role="OnewayFlight" or "Outbound" may be defined.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefinedComponent" type="RuleDefinedComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_554">Hier können nur DefinedComponents mit der Role="OnewayFlight" oder "Outbound" definiert werden.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_554">Here only DefinedComponents with the Role="OnewayFlight" or "Outbound" may be defined.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleAddonWrapperComponentType">
		<xs:complexContent>
			<xs:extension base="RuleComponentBaseType">
				<xs:choice minOccurs="1" maxOccurs="unbounded">
					<xs:element name="Addon" type="RuleAddonComponentType"/>
					<xs:element name="CombiComponent" type="RuleCombiComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_555">Hier können nur CombiComponents mit der Role="Addon" definiert werden.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_555">Here only CombiComponents with the Role="Addon" may be defined.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefinedComponent" type="RuleDefinedComponentType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_556">Hier können nur DefinedComponents mit der Role="Addon" definiert werden.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_556">Here only DefinedComponents with the Role="Addon" may be defined.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleSellingAccomComponentType">
		<xs:complexContent>
			<xs:extension base="RuleComponentBaseType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleProductComponentType"/>
	<xs:complexType name="RuleReturnFlightComponentType">
		<xs:complexContent>
			<xs:extension base="RuleComponentBaseType">
				<xs:sequence minOccurs="0">
					<xs:element name="Outbound" type="RuleOutboundFlightComponentType"/>
					<xs:element name="Inbound" type="RuleInboundFlightComponentType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleOutboundFlightComponentType">
		<xs:complexContent>
			<xs:extension base="RuleComponentBaseType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleInboundFlightComponentType">
		<xs:complexContent>
			<xs:extension base="RuleComponentBaseType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleOnewayFlightComponentType">
		<xs:complexContent>
			<xs:extension base="RuleComponentBaseType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleAddonComponentType">
		<xs:complexContent>
			<xs:extension base="RuleComponentBaseType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleCombiComponentType">
		<xs:complexContent>
			<xs:extension base="ComponentsType">
				<xs:attributeGroup ref="ProductComponentGroup"/>
				<xs:attribute name="Role" type="RoleEnum" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_342">Dieses Attribut definiert die Rolle, die eine CombiComponente in Bezug auf den ComponentenTyp einnimmt. Das "Role" Attribut wird bei der Auswertung von Komponentenreferenzen (Attribut "Source" in Conditions) wie der statische Komponententyp echter Komponenten verwendet. Mögliche Werte sind aktuell:
- OnewayFlight
- ReturnFlight
- Outbound
- Inbound

In Version 1.0 sind die Rollen noch stark eingeschränkt. In späteren Versionen werden alle Komponenten mit Hilfe von DefinedComponents dargestellt werden können. 
</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_342">This attribute defines the role that is played by a CombiComponent in relation to the ComponentType. The "role" attribute evaluates component references (the "source" attribute in Conditions) typically used as static components. Possible values ​​are currently:
- OnewayFlight
- ReturnFlight
- Outbound
- Inbound

In version 1.0, roles are still highly restricted. In later versions, all components will be able to be represented by means of DefinedComponents.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleDefinedComponentType">
		<xs:attributeGroup ref="ProductComponentGroup"/>
		<xs:attribute name="UseRole" type="RoleEnum" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_343">Dieses Attribut referenziert auf die hier zu benutzende Definition der CombiComponet. Es wird dabei das Attribut "Role" in der CombiComponentDefinition referenziert und dadurch an dieser Stelle die Definition der dort definierten Komponente benutzt. 
Mögliche Werte sind aktuell:
- OnewayFlight
- ReturnFlight
- Outbound
- Inbound

In Version 1.0 sind die Rollen noch stark eingeschränkt. In späteren Versionen werden alle Komponenten mit Hilfe von DefinedComponents dargestellt werden können. 
</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_343">This attribute references the definition of the CombiComponet used here. In this case, the attribute "Role", referred to in the CombiComponentDefinition, at this point constitutes the definition of the component.
Possible values ​​are currently:
- OnewayFlight
- ReturnFlight
- Outbound
- Inbound

In version 1.0, roles are still highly restricted. In later versions, all components will be able to be represented by means of DefinedComponents.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="RuleVirtualComponentType">
		<xs:attributeGroup ref="ProductComponentBaseGroup"/>
	</xs:complexType>
	<xs:complexType name="RuleExternalComponentType">
		<xs:attribute name="Name" type="NameType">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_9001">Dieses Element definiert einen Namen, der innerhalb der ProductRules von den Filtern innerhalb des Attributes "Source" in Kombination mit dem Präfix "#" als Referenz benutzt werden kann. 
							</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_9001">This element defines a name within the product rules of the filters using the "Source" attribute in combination with the prefix "#" as the reference.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="ProductComponentBaseGroup"/>
		<xs:attribute name="Role" type="RoleEnum" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_9009">Dieses Attribut definiert die Rolle, die eine ExternalComponent in Bezug auf den ComponentenTyp einnimmt. Abhängig von der @Role sind nur die externen Komponenten mit Role="Accommodation" und Role="Addon" zeitlich flexible Komponenten.
Aktuell können explizit nur Flughafenbedingungen bzgl. der externen Komponente formuliert werden. 
Dementsprechend werden Key-, Tag- und ConditionalTag-Filter und -Conditions in Kombination mit externen Komponenten explizit als "False" ausgewertet.

Mögliche Werte für die Role sind: 

- OnewayFlight
- Outbound
- Inbound
- Accommodation
- Addon</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_9009">This attribute defines the role, which an ExternalComponent takes over with reference to the ComponentType. Depending on the @Role only the external componentes with Role="Accommodation" and Role="Addon" are components that are flexible timewise.
As of today only airport conditions with respect to the external component may be expressed.
According to this Key-, Tag- and ConditionalTag-Filters and -Conditions in combination with external components will be explicitly evaluated as "False"

Possible values for the Role are: 

- OnewayFlight
- Outbound
- Inbound
- Accommodation
- Addon</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="KeyConditionType">
		<xs:simpleContent>
			<xs:extension base="KeyTypeList">
				<xs:attributeGroup ref="ConditionAttributeGroup"/>
				<xs:attributeGroup ref="SourceAttributeGroup"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="OccupancyConditionType">
		<xs:sequence maxOccurs="unbounded">
			<xs:element name="Person" type="OccupancyConditionPersonType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_344">Definition der Personen, die in der Unterkunft buchbar sind. Die Personen werden nach Alter absteigend definiert.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_344">Definition of persons who are booked into the accommodation. Persons are defined in descending order by age.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="ConditionAttributeGroup"/>
		<xs:attributeGroup ref="SourceAttributeGroup"/>
	</xs:complexType>
	<xs:complexType name="OccupancyConditionPersonType">
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:sequence>
					<xs:element name="MinAge" type="PersonAgeType" minOccurs="1">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_345">Mindestalter der Person(en)</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_345">Minimum age of the person(s)</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="MaxAge" type="PersonAgeType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_346">Höchstalter der Person(en)</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_346">Maximum age of the person(s)</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:sequence>
					<xs:element name="MaxAge" type="PersonAgeType" minOccurs="1">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_504">Mindestalter der Person(en)</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_504">Minimum age of the person(s)</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:choice>
			<xs:choice>
				<xs:sequence>
					<xs:element name="MinCount" type="xs:unsignedShort" minOccurs="1">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_347">Mindestanzahl Personen</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_347">Minimum number of persons</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="MaxCount" type="xs:unsignedShort" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_505">Maximale Anzahl Personen</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_505">Maximum number of persons</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:sequence>
					<xs:element name="MaxCount" type="xs:unsignedShort" minOccurs="1">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_348">Maximale Anzahl Personen</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_348">Maximum number of persons</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:element name="Count" type="xs:unsignedShort" minOccurs="1">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_349">Genaue Anzahl der Person(en)</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_349">Exact number of person (s)</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="OccupancyConditionChoiceType">
		<xs:sequence minOccurs="2" maxOccurs="unbounded">
			<xs:element name="Person" type="OccupancyConditionPersonType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_350">Definition der Personen, die in der Unterkunft buchbar sind</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_350">Definition of persons who can be booked into the accommodation</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:group name="BookingDateConditionGroup">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_351">Bedingungen über das Buchungsdatum</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_351">Conditions applying to the booking date</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="BookingDate" type="BookingDateConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_352">Diese Element definiert die Bedingung, ob sich das Buchungsdatum (bzw. das Datum zum Zeitpunkt der Preisanfrage) innerhalb einer bestimmten Terminspanne befindet oder in einer explizit angegebenen Liste von Tagen enthalten ist.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_352">This element defines the condition, whether or not the booking date (or the date of the price request) falls within a specified range of dates or an explicitly specified list of days.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BookingDateOffset" type="BookingOffsetConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_353">Dieses Element definiert die Bedingung, ob sich das Buchungsdatum (bzw. das Datum zum Zeitpunkt der Preisanfrage) innerhalb eines bestimmten Zeitraums vor Reiseantritt befindet.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_353">This element defines the condition, whether the booking date (or the date of the price request) falls within a specified period prior to travel.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:complexType name="DayFilterType">
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Date" type="DateConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_470">Einschränkung bzgl. des Datums einzelner Reisetage. Die Bedingung gilt für die Reisetage als erfüllt, die die entsprechenden Terminbedingungen (größer=Min  und  kleiner= Max  und passt zum Attribute "DayType")  erfüllen.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_470">Limitations with respect to the dates of specific travel days. The condition is fulfilled for travel days that meet the applicable date conditions (greater=Min and lower=Max and fits the "DayType" attribute).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Weekdays" type="WeekdayConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_472">Einschränkung bzgl. des Wochentages
einzelner Tage Dieses Element definiert die Bedingung, ob
einzelne Tage der gerade betrachteten Reise eine Bedingung bzgl.
der Wochentage erfüllen. Die Bedingung ist für jeden Tag erfüllt
der einem der angegeben Wochentage entspricht. Dabei kann über
das Attribut "DayType" zusätzlich bestimmt werden, dass nur
bestimmte Tage der Reise betrachtet werden sollen (z.B.: nur der
Anreisetag oder nur Aufenthaltstage). Bitte beachten: Im
Gegensatz zu den anderen Conditions ist an dieser Stelle der
Defaultwert="CheckIn" gesetzt. Wird das Attribut "DayType" nicht
angegeben so wird an dieser Stelle der Wert "CheckIn" benutzt.
Das Element Weekdays kann eine durch Space getrennte Liste von
Wochentagen enthalten. Mögliche Werte sind "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", analog zu den englisch benamten Wochentagen. Die Bedingung ist erfüllt, wenn einer der
angegebenen Tage die Bedingung erfüllt. Es handelt sich also um
eine implizite "OR-Verknüpfung". Über das Attribut "Source" wird
die Quelle der betrachteten Reisetage bestimmt (z.B. Termine im
Hotel oder während des Fluges). Diese Bedingung überprüft, ob
bestimmte Tage einer Reise eine Wochentagsbedingung erfüllen und
deshalb ggf. Preise explizit für diese Tage gelten. Die
entsprechende Interpretation der Weekday-Condition ohne
Impact-Anteil ist dementsprechend abweichend - bitte beachten. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_472">Restrictions on specific weekdays of
individual days This element defines the condition whether or
not individual days of the currently viewed tour meet the
weekday restriction condition. The condition is met for all days
that correspond to the weekdays entered. The "DayType" attribute
can also be used to determine that only certain days of the tour
should be considered (e.g. only the arrival day or only the days
of the stay). Please note: In contrast to other conditions, here
the default value is set to ="CheckIn". If nothing is entered as
the "DayType" attribute, the value "CheckIn" will be used here.
The Weekdays element can contain a list of weekdays separated by
a space. Possible values are "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", and "Sun". The condition is fulfilled if one of the days entered
fulfils the condition. It therefore concerns an implicit "OR
connective". The "Source" attribute is used to determine the
source of the travel days currently being viewed (e.g. dates in
the hotel or during the flight). This condition checks whether
certain days of a tour meet a weekday condition, and therefore
also whether prices explicitly apply for these days. The
corresponding interpretation of the Weekday Condition without
Impact part changes accordingly - please
note.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ConditionalTags" type="ConditionalTagConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_442">Schränkt den Personenkreis ein, in dem ein
ConditionalTag überprüft wird. Dadurch kann nach bestimmten
Personentypen gefiltert werden, wie beispielsweise Vollzahler,
welche durch ConditionalTags markiert sind. Es ist nur sinnvoll,
sich an dieser Stelle auf ConditionalTags zu beziehen, die
keinen DayImpact-Anteil haben.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_442">By using a ConditionalTag, the number of people can be limited. This can be filtered according to specific types of people, such as full-paying guests, which are defined by ConditionalTags.
At this point it makes sense to refer only to ConditionalTags which have no DayImpact share.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<!--Start of price definition-->
	<xs:complexType name="PriceItemsType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_354">Definition der Preisbestandteile (PriceItem) bei
				Unterbringungen.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_354">Definition of price components (PriceItem) for
				accommodation.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MultipleSimpleUpdateNodeType">
				<xs:sequence>
					<xs:element name="PriceItem" type="PriceItemType" maxOccurs="unbounded"/>
					<xs:element name="Condition" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_9003">In diesem Element werden die Regeln zur Verwendung der PriceItems definiert. Immer wiederkehrende Preis Conditions können hier definiert werden. Dadurch kann Redundanz in den Conditions jedes einzelnen PriceItem vermieden werden. Gibt es eine Condtion in PriceItems, so ist diese mit den einzelnen PriceItems Conditions UND-verknüpft.
Das Attribut ExecutionOrder definiert, zu welchem Zeitpunkt die Conditions ausgewertet werden können. Wichtig ist hierbei, dass Conditions, die die DayPriceIndexCondition enthalten, nur in Verbindung mit dem Value ExecutionOrder= "Last" verwendet werden dürfen. </xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_9003">In this element, the rules for using the PriceItems are defined. Recurring conditions can be defined here.
								As a result, redundancy in the conditions of each PriceItem can be avoided. If there is a Condition in Price Items, this is AND-linked with the individual PriceItems Conditions. The ExecutionOrder attribute defines at which time the conditions can be evaluated. It is important that conditions which include the DayPriceIndexCondition can only be used in conjunction with the value ExecutionOrder= "Last".</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="ConditionType"/>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PriceItemType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_355">Definition der Preisbestandteile (PriceItem) bei
				Unterbringungen.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_355">Definition of price components (PriceItem) for
				accommodation.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="PriceTags" minOccurs="0" internal:otdsversion="1.9">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="PriceTag" type="TagType" maxOccurs="unbounded" internal:otdsversion="1.9"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:choice>
				<xs:element name="Absolute" type="PriceImpactAbsoluteType">
					<xs:annotation>
						<xs:documentation xml:lang="det" xml:id="de_356">Definition von fixen Absolutbeträgen mit der Festlegung des Values und der Aufteilung des Values auf die Kostenmatrix gemäß der Angaben unter DayBase und PersonBase.  
Die Zuordnung des Absolutbetrages zu spezifischen Percent-PriceItems wird über einzelne Bedingungen in den Elementen AppliedBy... und NotAppliedBy... festgelegt.
Die Percent-PriceItems ihrerseits können auch zusätzliche Bedingungen durch ApplyTo... und NotApplyTo... an die Zuordnung festlegen.
Mit dem Attribut @LogicalRelation="And" oder "Or" definiert man And-Bedingungen bzw. Or-Bedingungen.
Die finale Zuordnung eines Absoluten-PriceItems zu einem PercentPriceItem, erfolgt nur dann, wenn jede And-Bedingung und gleichzeitig mindestens 1 Or-Bedingung erfüllt ist.  </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_356">Definition of the absolute value of a price
							component (PriceItem) with the bases for the calculation and
							effects.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="GenericAbsolute" type="PriceImpactGenericType" internal:otdsversion="1.9">
					<xs:annotation>
						<xs:documentation xml:lang="det" xml:id="de_357">Definition von zur Laufzeit berechneten Absolutbeträgen mit der Festlegung des zu berechneden Values durch Definition einer spezifischen Berechnungsvorschrift, welche unterhalb des Elementes GenericValue definiert wird.

Die Aufteilung des Values auf die Kostenmatrix erfolgt gemäß der Angaben unter DayBase und PersonBase.
  
Die Zuordnung des Absolutbetrages zu spezifischen Percent-PriceItems wird über einzelne Bedingungen in den Elementen AppliedBy... und NotAppliedBy... festgelegt.
Die Percent-PriceItems ihrerseits können auch zusätzliche Bedingungen durch ApplyTo... und NotApplyTo... an die Zuordnung festlegen.
Mit dem Attribut @LogicalRelation="And" oder "Or" definiert man And-Bedingungen bzw. Or-Bedingungen.
Die finale Zuordnung eines Absoluten-PriceItems zu einem PercentPriceItem, erfolgt nur dann, wenn jede And-Bedingung und gleichzeitig mindestens 1 Or-Bedingung erfüllt ist.  </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_357">Indication of surcharge or discount by percentage.
							It affects specific PriceItems via ApplyTo or NotApplyTo and conditions impacting travellers and dates,</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="Percent" type="PriceImpactPercentType">
					<xs:annotation>
						<xs:documentation xml:lang="det" xml:id="de_506">Definition von prozentualen Zu- oder Abschlägen.  
Die Zuordnung des prozentualen Zu- oder Abschlages zu spezifischen Absolute-PriceItems wird über einzelne Bedingungen in den Elementen ApplyTo... und NotApplyTo... festgelegt.
Die Absolute-PriceItems ihrerseits können auch zusätzliche Bedingungen durch  AppliedBy... und NotAppliedBy...  an die Zuordnung festlegen.
Mit dem Attribut @LogicalRelation="And" oder "Or" definiert man And-Bedingungen bzw. Or-Bedingungen.
Die finale Zuordnung eines Absoluten-PriceItems zu einem PercentPriceItem, erfolgt nur dann, wenn jede And-Bedingung und gleichzeitig mindestens 1 Or-Bedingung erfüllt ist.  </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_506">Indication of surcharge or discount by percentage.
It affects specific PriceItems via ApplyTo or NotApplyTo and conditions impacting travellers and dates.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element name="Condition" minOccurs="0" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_9004">In diesem Element werden die Regeln zur Verwendung der PriceItems definiert. Das Attribut ImpactExecutionOrder definiert, zu welchem Zeitpunkt die Conditions ausgewertet werden können. Wichtig ist hierbei, dass Conditions, die die DayPriceIndexCondition enthalten, nur in Verbindung mit dem Value ImpactExecutionOrder= "Last" verwendet werden dürfen. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_9004">In this element, the rules for using the PriceItems are defined. The ImpactExecutionOrder attribute defines at which time the conditions can be evaluated. It is important that conditions which include the DayPriceIndexCondition can only be used in conjunction with the value ImpactExecutionOrder= "Last".</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ConditionType"/>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="Combinatorics" type="CombinatoricsType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_359">In diesem Element wird definiert, wie PriceItems miteinander kombiniert werden können oder auch nicht kombiniert werden dürfen. Die Auswertung der "Verträglichkeit" aller Combinatorics-Elemente eines Combinatoric-Layers wird unabhängig von allen anderen Layern ausgewertet. 
Jedes Combinatorics-Element ist einem solchen Combinatorics-Layer durch seine Attribute "LayerName" und "LayerLevel" eindeutig zugeordnet. Keine zwei Combinatorics-Elemente innerhalb eines PriceItem dürfen denselben LayerName und LayerLevel haben. Wird kein LayerName angegeben, so wird als Defaultwert "Default" angenommen. Wird kein LayerLevel angegeben, so wird als Defaultwert "0" angenommen. 
Die Auswertung der Kombinatorik erfolgt aufsteigend nach LayerLevel. Combinatoric-Elemente aus ausgeschlossenen PriceItems werden bei der Auswertung der CombinatoricsLayer mit höherem LayerLevel nicht mehr berücksichtigt. 
Jedes Combinatorics-Element kann CombinationCodes bzw. CombinationIndices definieren und auch Bedingungen definieren, mit welchen CombinationCodes bzw. CombinationIndices eine "Unverträglichkeit" besteht. 
Die Auswertung eines Combinatorics-Layer bestimmt, welche PriceItems aufgrund der "Unverträglichkeit" nicht mehr gültig ist. Die Auswertung erfolgt separat für jeden Einzelnen Kostenknoten.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_359">With this element you can define, which PriceItes can be combined with eachother or cannot be combined with eachother. The evalution of the "incompatibility" will be processed independantly per Combinatoircs-Layer. Each Combinatorics-Element is assigned to a Combinatorics-Layer with its attributes "LayerName" and "LayerLevel". 
Within each PriceItem the Combinatorics-Element needs to be unique regarding its attribute combination of "LayerName" and "LayerLevel". If the "LayerName" is not defined it gets the default value "Default". If the "LayerLevel" is not defined it gets the default value "0". 
The evaluation will be processed per Layer in ascending order of the LayerLevel. Combinatorics-Elements of already "excluded" PriceItems will no be cosiderded in the evaluation of higher Combinatorics-Layers. 
Each Combinatorics-Element can define CombinationCodes and/or CombinationIndices and also a condition about the compatibility with the CombinationCodes and/or CombinationIndices of other PriceItems CombinaticsElements. 
The evaluation of a complete CombinatoricsLayer defines which PriceItems needs to be excluded from the calcualtion. This evalution is processed per single PriceNode seperatly.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Booking" type="BookingWithoutNodeType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_360">In diesem Element kann man bei Änderungen von Zimmertypen oder Verpflegungstypen auch den dazugehörigen Booking Parameter anpassen.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_360">In this element, you can adjust the relevant Booking Parameter when changes are made to the room type or type of board.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Properties" type="PropertiesWithoutNodeType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_361">In diesem Element können Änderungen von Boardtypen oder Zimmertypen definiert werden. Diese Angaben überschreiben ggf. vorher definierte Zimmertypen oder Boardtypen. Zusätzlich kann an dieser Stelle ein Preistyp angegeben werden. Dieser Preistyp dient nur zur Anzeige des Types in einem Browser. Der Preistyp hat keine Auswirkung auf die Preisberechnung. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_361">In this element changes to room or board types are defined. These data will overwrite previous definitions of room or board type where already specified.
In addition, at this point, a price type must be specified. This price type is only for displaying the type in a browser. The price type has no effect on the price calculation.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="Class" type="TokenType" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_362">Gibt einen frei vergebbaren Klassennamen für das
					PriceItem an, auf den in Combinatorics Bezug genommen werden kann. Es wird
					typischerweise eine Kategorie von PriceItems angegeben, beispielsweise
					Kinderermäßigung, Frühbucherrabatt, DurationReduction etc.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_362">Specify a freely assignable class name for the PriceItem which will be referred back to in Combinatorics. Typically a category of PriceItems will be specified, such as children's discount, early booking discount, DurationReduction, etc.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="CombinatoricsType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_363">In diesem Element wird definiert, wie PriceItems miteinander kombiniert werden können oder auch nicht kombiniert werden dürfen. Dies kann auf unterschiedlichen voneinander unabhängigen Ebenen erfolgen. Dieses Element definiert einen solchen Combinatorics-Layer.
	Dieses Element definiert einen eigenen Combinatorics Layer. Diese Layer sind durch ihren Namen und einen Level identifiziert. Keine zwei Combinatorics Layer innerhalb eines PriceItem dürfen den selben Name und Level haben. Wird kein Name oder Level angegeben.
	Die Kombinatorik innerhalb eines Layers wird unabhängig von allen anderen Layern ausgewertet: Jeder Layer definiert seinen eigenen CombinationCodes, CombinationLevel usw. Das Ergebnis der Kombinatorik ist jedoch für Layer mit größerem LayerLevel sichtbar: In einem Layer mit kleinererm LayerLevel ausgeschlossene PriceItems sind für LayerLevel mit größerem LayerLevel nicht mehr sichtbar.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_363">This element defines how PriceItems can be combined with each other or how they may not be combined. This can be done at different levels independent of each other. This element defines such a CombinationLayer.
This element defines a separate Combinatorics Layer. These layers are identified by their name and a level. No two Combinatorics Layers within a single PriceItem may have the same name and level. No name or level is specified.
Combinations within a layer are analysed independent of all other layers: Each layer is defined by its own CombinationCodes, CombinationLevel, etc. However, the result of combinations can be seen in layers with a larger LayerLevel: PriceItems excluded from a layer with a smaller LayerLevel are no longer visible at a greater LayerLevel.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="CombinationLevel" type="xs:int" default="0" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_364">In jedem CombinationLayer enthält jedes PriceItem einen CombinationLevel. Ein PriceItem wird grundsätzlich nur von PriceItems mit kleinerem CombinationLevel (im selben CombinationLayer) beeinflusst. Zwei PriceItems mit selben CombinationLevel beeinflussen sich gegenseitig nicht. Der CombinationLevel gibt an, in welcher Reihenfolge die PriceItems innerhalb einer Combinatorics-Ebene kombiniert werden. Die Abarbeitung der Kombination erfolgt in aufsteigender Reihenfolge der CombinationLevel.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_364">Within every CombinationLayer, each PriceItem contains a CombinationLevel. A PriceItem is generally only influenced by PriceItems with a lower CombinationLevel (in the same CombinationLayer). Two PriceItems with the same CombinationLevel do not influence each other.
The CombinationLevel indicates in which order the PriceItems are combined within a CombinationLayer. The processing of the combination occurs in ascending order of CombinationLevel.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CombinationCode" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_365">Der CombinationCode ist eine Gruppenzuordnung für die Kombinatorik der PriceItems. Ein PriceItem kann dabei mehreren Gruppen (CombinationCode) zugeordnet werden. 
Die Kombinierbarkeit über den CombinationCode wird durch Aufzählung der kompatiblen oder inkompatiblen Codes definiert.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_365">The CombinationCode is a group assignment for the combination of the PriceItems. One PriceItem can be assigned to several groups (CombinationCode).
Combinability via CombinationCode is defined with a list of compatible or incompatible codes.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="IdentifierType">
							<xs:attribute name="Group" type="IdentifierType" default="Default">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_366">Name der Gruppe, für den der CombinationCode gilt.
									</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_366">Name of the group for which the CombinationCode applies.</xs:documentation>
								</xs:annotation>
							</xs:attribute>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="CombinationIndex" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_367">Der CombinationIndex kann als Alternative oder Ergänzung zum CombinationCode verstanden werden, er ist das numerische Äquivalent zum CombinationCode. Die Kombinierbarkeit über den CombinationIndex wird durch Angabe von gültigen Indexbereichen definiert.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_367">The CombinationIndex can be understood as an alternative or supplement to the CombinationCode; it is the numerical equivalent of the CombinationCode. Combinability via the CombinationIndex is defined by specifying applicable index areas.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="xs:int">
							<xs:attribute name="Group" type="IdentifierType" default="Default">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_368">Name der Gruppe, für den der CombinationIndex gilt.
									</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_368">Name of the group for which the CombinationIndex applies.</xs:documentation>
								</xs:annotation>
							</xs:attribute>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
			<xs:choice minOccurs="0">
				<xs:element name="ExcludePriceItemClasses">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_369">In diesem Element können PriceItemClasses angegeben werden, die bestimmte PriceItems während der Kombinatorik-Verarbeitung aus der Preisberechnung ausschließen.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_369">In this element, PriceItemClasses can be specified which exclude certain PriceItems from the price calculation during the processing of combinations.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="ExcludePriceItemClass" maxOccurs="unbounded">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_370">In diesem Element können PriceItemClasses angegeben werden, die bestimmte PriceItems während der Kombinatorik-Verarbeitung aus der Preisberechnung ausschließen. Dabei wird weder LayerLevel noch -Name noch CombiLevel verglichen. Die zu deaktivierenden PriceItems können sich dementsprechend auch außerhalb des aktuell betrachteten Layers befinden. Dieses Element kann eine durch Space getrennte Liste enthalten. Jedes Element der Liste definiert eine zu deaktivierende PriceItemClass. Werden mehrere Elemente "ExcludePriceItemClasses" an dieser Stelle angegeben, so definieren diese weitere PriceItemClasses ggf. in anderen Komponenten, die deaktiviert werden sollen. Per
Definition ist es nicht erlaubt, mehrere "ExcludePriceItemClasses" mit demselben Attribute "Source"	zu verwenden.</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_370">In this element, PriceItemClasses can be specified which exclude certain PriceItems from the price calculation during the processing of combinations. In this, neither LayerLevel nor LayerName or CombiLevel is compared. The PriceItems which are to be deactivated may therefore also be found outside the Layer currently being observed. This element may include a list separated by a space. Each element of the list defines a PriceItemClass which is to be deactivated. If several items specify "ExcludePriceItemClasses" in this section, these define additional PriceItemClasses to be deactivated, possibly in other components.
By definition, it is not permitted to use several "ExcludePriceItemClasses" with the same attribute "Source".</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:simpleContent>
										<xs:extension base="PriceItemClassTypeList">
											<xs:attributeGroup ref="ComponentAttributeGroup">
												<xs:annotation>
													<xs:documentation xml:lang="de" xml:id="de_8911">Das Attribut Component gibt an, auf welche Komponente sich dieses PriceItem bezieht. Durch die explizite Angabe einer Komponente ist es möglich, dass ein Percent-PriceItem sich auf ein absolutes PriceItem einer anderen Komponente bezieht. Das Attribut Source stellt eine Erweiterung zum Attribut dar. Wird gleichzeitig das Attribut 'Component' und das Attribut 'Source' angegeben, so wird nur die Source ausgewertet. Werden beide Attribute nicht angegeben, wird für das Attribut 'Component der Wert 'ThisComponent' angenommen.</xs:documentation>
													<xs:documentation xml:lang="en" xml:id="en_8911">The attribute Component indicates, which component this PriceItem refers to. By explicitly indicating a component it is possible to have a Percent-PriceItem refer to an absolute PriceItem of a different component. The attribute Source is an extension of the attribute. If both attributes 'Component' and 'Source' are indicated at the same time, only Source will be evaluated. If non of the attributes is indicated, the value 'ThisComponent' is assumed for the attribute 'Component'.</xs:documentation>
												</xs:annotation>
											</xs:attributeGroup>
										</xs:extension>
									</xs:simpleContent>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="CombinableWhen" type="CombinableWhenType">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_372">Mit CombinableWhen wird angegeben, mit welchen PriceItems ein PriceItem kombinierbar ist. Wird CombinableWhen nicht angegeben, so ist dieses PriceItem (von sich aus) mit allen anderen PriceItems kombinierbar (es ist jedoch möglich, dass ein anderes PriceItem mit kleinerem Level dieses PriceItem ausschließt, da
Kombinierbarkeit reflexiv ist). Mittels CombinableWhen kann sowohl eine Inklusivliste ("kombinierbar mit") als auch eine Exklusivliste ("nicht kombinierbar mit") ausgedrückt werden.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_372">CombinableWhen indicates the PriceItems with which a PriceItem can be combined. If CombinableWhen is not specified, the PriceItem is (in itself) combinable with all other PriceItems (it is however possible for another PriceItem with a lower Level to exclude this PriceItem, as combinability is reflexive). Through CombinableWhen, it is possible to express both an included list ("combinable with") and an excluded list ("not combinable with").</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
		</xs:sequence>
		<xs:attribute name="LayerName" type="IdentifierType" default="Default"/>
		<xs:attribute name="LayerLevel" type="xs:int" default="0"/>
	</xs:complexType>
	<xs:complexType name="CombinableWhenType">
		<xs:group ref="CombinableWhenGroup">
			<xs:annotation>
				<xs:documentation>Mit CombinableWhen wird angegeben, mit welchen PriceItems ein PriceItem kombinierbar ist. Wird CombinableWhen nicht angegeben, so ist dieses PriceItem (von sich aus) mit allen anderen PriceItems kombinierbar (es ist jedoch möglich, dass ein anderes PriceItem mit kleinerem Level dieses PriceItem ausschließt, da Kombinierbarkeit reflexiv ist). Mittels CombinableWhen kann sowohl eine Inklusivliste ("kombinierbar mit") als auch eine Exklusivliste ("nicht kombinierbar mit") ausgedrückt werden.</xs:documentation>
			</xs:annotation>
		</xs:group>
	</xs:complexType>
	<xs:group name="CombinableWhenGroup">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_373">Mit CombinableWhen wird angegeben, mit welchen
				PriceItems ein PriceItem kombinierbar ist. Wird CombinableWhen nicht angegeben, so
				ist dieses PriceItem (von sich aus) mit allen anderen PriceItems kombinierbar (es
				ist jedoch möglich, dass ein anderes PriceItem mit kleinerem Level dieses PriceItem
				ausschließt, da Kombinierbarkeit reflexiv ist). Mittels CombinableWhen kann sowohl
				eine Inklusivliste ("kombinierbar mit") als auch eine Exklusivliste ("nicht
				kombinierbar mit") ausgedrückt werden.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_373">CombinableWhen indicates the PriceItems with which a PriceItem can be combined. If CombinableWhen is not specified, the PriceItem is (in itself) combinable with all other PriceItems (it is however possible for another PriceItem with a lower Level to exclude this PriceItem, as combinability is reflexive). Through CombinableWhen, it is possible to express both an included list ("combinable with") and an excluded list ("not combinable with").</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:group ref="AtomicCombinableWhenGroup"/>
			<xs:element name="And">
				<xs:complexType>
					<xs:group ref="CombinableWhenGroup" minOccurs="1" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Mit CombinableWhen wird angegeben, mit welchen PriceItems ein PriceItem kombinierbar ist. Wird CombinableWhen nicht angegeben, so ist dieses PriceItem (von sich aus) mit allen anderen PriceItems kombinierbar (es ist jedoch möglich, dass ein anderes PriceItem mit kleinerem Level dieses PriceItem ausschließt, da Kombinierbarkeit reflexiv ist). Mittels CombinableWhen kann sowohl eine Inklusivliste ("kombinierbar mit") als auch eine Exklusivliste ("nicht kombinierbar mit") ausgedrückt werden.</xs:documentation>
						</xs:annotation>
					</xs:group>
				</xs:complexType>
			</xs:element>
			<xs:element name="Or">
				<xs:complexType>
					<xs:group ref="CombinableWhenGroup" minOccurs="1" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Mit CombinableWhen wird angegeben, mit welchen PriceItems ein PriceItem kombinierbar ist. Wird CombinableWhen nicht angegeben, so ist dieses PriceItem (von sich aus) mit allen anderen PriceItems kombinierbar (es ist jedoch möglich, dass ein anderes PriceItem mit kleinerem Level dieses PriceItem ausschließt, da Kombinierbarkeit reflexiv ist). Mittels CombinableWhen kann sowohl eine Inklusivliste ("kombinierbar mit") als auch eine Exklusivliste ("nicht kombinierbar mit") ausgedrückt werden.</xs:documentation>
						</xs:annotation>
					</xs:group>
				</xs:complexType>
			</xs:element>
			<xs:element name="Not">
				<xs:complexType>
					<xs:group ref="CombinableWhenGroup">
						<xs:annotation>
							<xs:documentation>Mit CombinableWhen wird angegeben, mit welchen PriceItems ein PriceItem kombinierbar ist. Wird CombinableWhen nicht angegeben, so ist dieses PriceItem (von sich aus) mit allen anderen PriceItems kombinierbar (es ist jedoch möglich, dass ein anderes PriceItem mit kleinerem Level dieses PriceItem ausschließt, da Kombinierbarkeit reflexiv ist). Mittels CombinableWhen kann sowohl eine Inklusivliste ("kombinierbar mit") als auch eine Exklusivliste ("nicht kombinierbar mit") ausgedrückt werden.</xs:documentation>
						</xs:annotation>
					</xs:group>
				</xs:complexType>
			</xs:element>
			<xs:element name="Imply">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="If">
							<xs:complexType>
								<xs:group ref="CombinableWhenGroup">
									<xs:annotation>
										<xs:documentation>Mit CombinableWhen wird angegeben, mit welchen PriceItems ein PriceItem kombinierbar ist. Wird CombinableWhen nicht angegeben, so ist dieses PriceItem (von sich aus) mit allen anderen PriceItems kombinierbar (es ist jedoch möglich, dass ein anderes PriceItem mit kleinerem Level dieses PriceItem ausschließt, da Kombinierbarkeit reflexiv ist). Mittels CombinableWhen kann sowohl eine Inklusivliste ("kombinierbar mit") als auch eine Exklusivliste ("nicht kombinierbar mit") ausgedrückt werden.</xs:documentation>
									</xs:annotation>
								</xs:group>
							</xs:complexType>
						</xs:element>
						<xs:element name="Then">
							<xs:complexType>
								<xs:group ref="CombinableWhenGroup">
									<xs:annotation>
										<xs:documentation>Mit CombinableWhen wird angegeben, mit welchen PriceItems ein PriceItem kombinierbar ist. Wird CombinableWhen nicht angegeben, so ist dieses PriceItem (von sich aus) mit allen anderen PriceItems kombinierbar (es ist jedoch möglich, dass ein anderes PriceItem mit kleinerem Level dieses PriceItem ausschließt, da Kombinierbarkeit reflexiv ist). Mittels CombinableWhen kann sowohl eine Inklusivliste ("kombinierbar mit") als auch eine Exklusivliste ("nicht kombinierbar mit") ausgedrückt werden.</xs:documentation>
									</xs:annotation>
								</xs:group>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:group name="AtomicCombinableWhenGroup">
		<xs:choice>
			<xs:element name="CombinationCode">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_374">Diese Kombinationsbedingung bezieht sich auf den CombinationCode eines PriceItems.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_374">This condition of combination refers to the CombinationCode of a PriceItem.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="IdentifierType">
							<xs:attribute name="Group" type="IdentifierType" default="Default">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_375">Die Group bezieht sich auf die bei
										CombinationCode angegebene Group.</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_375">This group refers to the group stated in the CombinationCode</xs:documentation>
								</xs:annotation>
							</xs:attribute>
							<xs:attributeGroup ref="ComponentAttributeGroup">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_376">Das Attribut Component beschränkt den
										Wirkungsradius der Kombinatorik auf PriceItems einer
										bestimmten Komponente. Wenn die Kombinatorikbedingungen auf ein
										PriceItem einer anderen Komponente wirken sollen, muss dies
										hier explizit angegeben werden. Mit der Source kann man die Adressierung noch verfeinern.
					Wird gleichzeitig das Attribut 'Component' und das Attribut 'Source' angegeben, so wird nur die Source ausgewertet. Werden beide Attribute nicht angegeben, wird für das Attribut 'Component' der Wert 'ThisComponent' angenommen.</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_376">The attribute Component limits 
										the sphere of the combinatorics to PriceItems of a 
										certain component. If the conditions of the combinatorics shall have an effect on the 
										PriceItem of another component, it must be indicated here explicitly. With the help of Source the addressing can be refined further.
					If the attribute 'Component' and the attribute 'Source' are indicated at the same time, only Source is being evaluated. If both attributes are not indicated, the value 'ThisComponent' is assumed for the attribute 'Component'.</xs:documentation>
								</xs:annotation>
							</xs:attributeGroup>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="CombinationIndexMin">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_377">Diese Kombinationsbedingung bezieht sich auf den CombinationIndex eines PriceItems und beschränkt diesen nach unten.
						</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_377">This combination condition relates to the CombinationIndex of a PriceItem and limits this to a minimum value.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="xs:int">
							<xs:attribute name="Group" type="IdentifierType" default="Default">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_378">Die Group bezieht sich auf die bei
										CombinationIndex angegebene Group</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_378">This Group refers to the group stated in
										the CombinationIndex</xs:documentation>
								</xs:annotation>
							</xs:attribute>
							<xs:attributeGroup ref="ComponentAttributeGroup">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_379">Das Attribut Component beschränkt den
										Wirkungsradius der Kombinatorik auf PriceItems einer
										bestimmten Komponente. Wenn die Kombinatorikbedingungen auf ein
										PriceItem einer anderen Komponente wirken sollen, muss dies
										hier explizit angegeben werden. Mit der Source kann man die Addressierung noch verfeinern.
					Wird gleichzeitig das Attribut 'Component' und das Attribut 'Source' angegeben, so wird nur die Source ausgewertet. Werden beide Attribute nicht angegeben, wird für das Attribut 'Component der Wert 'ThisComponent' angenommen.</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_379">The attribute Component limits 
										the sphere of the combinatorics to PriceItems of a 
										certain component. If the conditions of the combinatorics shall have an effect on the 
										PriceItem of another component, it must be indicated here explicitly. With the help of Source the addressing can be refined further.
					If the attribute 'Component' and the attribute 'Source' are indicated at the same time, only Source is being evaluated. If both attributes are not indicated, the value 'ThisComponent' is assumed for the attribute 'Component'.</xs:documentation>
								</xs:annotation>
							</xs:attributeGroup>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="CombinationIndexMax">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_380">Diese Kombinationsbedingung bezieht sich auf den CombinationIndex eines PriceItems und beschränkt diesen nach oben.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_380">This combination condition relates to the CombinationIndex of a PriceItem and limits this to a maximum value.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="xs:int">
							<xs:attribute name="Group" type="IdentifierType" default="Default">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_381">Die Group bezieht sich auf die bei
										CombinationIndex angegebene Group.</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_381">This group refers to the group stated in
										the CombinationIndex.</xs:documentation>
								</xs:annotation>
							</xs:attribute>
							<xs:attributeGroup ref="ComponentAttributeGroup">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_382">Das Attribut Component beschränkt den
										Wirkungsradius der Kombinatorik auf PriceItems einer
										bestimmten Komponente. Wenn die Kombinatorikbedingungen auf ein
										PriceItem einer anderen Komponente wirken sollen, muss dies
										hier explizit angegeben werden. Mit der Source kann man die Addressierung noch verfeinern.
					Wird gleichzeitig das Attribut 'Component' und das Attribut 'Source' angegeben, so wird nur die Source ausgewertet. Werden beide Attribute nicht angegeben, wird für das Attribut 'Component der Wert 'ThisComponent' angenommen.</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_382">The attribute Component limits 
										the sphere of the combinatorics to PriceItems of a 
										certain component. If the conditions of the combinatorics shall have an effect on the 
										PriceItem of another component, it must be indicated here explicitly. With the help of Source the addressing can be refined further.
					If the attribute 'Component' and the attribute 'Source' are indicated at the same time, only Source is being evaluated. If both attributes are not indicated, the value 'ThisComponent' is assumed for the attribute 'Component'.</xs:documentation>
								</xs:annotation>
							</xs:attributeGroup>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:simpleType name="GenericTagValueType">
		<xs:union memberTypes="xs:int">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="true"/>
					<xs:enumeration value="false"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="PriceImpactBaseValueType">
		<xs:union memberTypes="xs:positiveInteger">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="x"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="PriceNonImpactBaseValueType">
		<xs:restriction base="xs:string">
			<xs:maxLength value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="PriceImpactAbsoluteType">
		<xs:complexContent>
			<xs:extension base="PriceAbsoluteType">
				<xs:sequence>
					<xs:group ref="AllocationBaseGroup"/>
					<xs:group ref="PriceAppliedByGroup"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:group name="PriceAppliedByGroup">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded">
				<xs:element name="AppliedByPriceTags" type="PriceTagsApplyType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="1.9">
					<xs:annotation>
						<xs:documentation xml:lang="det">
Dieses Element definiert die Bedingung , dass mindestens eines der hier angegeben PriceTags am korrelierenden Percent-PriceItem (Percent//PriceTags) definiert sein muss.

Das Element enthält einen oder mehrere Values eines
						PriceTags und zusätzlich wird in dem Attribut "Class" auch die Class des
						PriceTags festgelegt. Es können auch mehrere Werte als Liste mit Space
						getrennt angegeben werden. Außerdem kann man sich wie in der Tag-Condition
						mit dem Attributen Length und Offset auf Teilbereiche des PriceTag-Values
						beziehen. Das Attribut "Source" wird hier auch häufig mit der Eigenschaft
						"Hierarchy.All" verwendet, um PriceItems aus mehren SubKomponenten
						gleichzeitig zu referenzieren. Am häufigsten wird
						Source="Hierarchy.All:ThisComponent" vorkommen, welches die aktuelle
						Komponente inkl. alle Ancestors und Descendants referenziert. PriceTags sind
						Tags, die am Knoten "PriceItem" definiert werden.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8912">In this element is being defined which other PriceItems can
						have an impact on this PriceItem. The element holds one or several values of
						a PriceTags; in addition the Class of the PriceTag is defined within the
						attribute "Class". A number of values can be specified in a list separated
						by Space. Also just like in the Tag-Condition it is possible to reference to
						certain sectors of the PriceTag-Value with the help of the attributes Length
						and Offset. The attribute "Source" in this aspect also is frequently used
						with the property "Hierarchy.All", in order to reference to PriceItems from
						several SubComponents at the same time. Most commonly the
						Source="Hierarchy.All:ThisComponent" will be used, which references the
						acutal Component including all ancestors and descendants. PriceTags are
						tags, that are defined at the node "PriceItem".</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="AppliedBy" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8913">In diesem Element wird definiert, welche Preisbestandteile mit
						prozentualem Zu- oder Abschlag eine Wirkung auf diesen Wert haben. Das
						Element enthält den Wert des Attributs "Class" des entsprechenden
						PriceItems. Es können auch mehrere Werte als Liste mit Space getrennt
						angegeben werden. In dem Attribut "Component" kann man definieren, auf
						welche Komponente sich das AppliedBy bezieht. Ist "Component" nicht gefüllt,
						so gilt der Default="ThisComponent". Im Zuge der Erweiterung von OTDS 2.0
						ist das Attribut "Source" hinzugekommen, welches in der Zukunft das Attribut
						"Component" komplett ersetzen wird. Falls beide Attribute gefüllt sind, so
						müssen beide Attribute erfüllt sein. Ist nur ein Attribut gefüllt, so muss
						dieses erfüllt sein. Ist sowohl "Source" als auch "Component" nicht gefüllt,
						so gilt ab Version V2.0 für Source der Default: ?? @ToDo</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_8913">In this element is being defined, which price components have an impact on this value with a percentage surcharge or discount. 
						The element holds the value of the attribute "Class" of the corresponding PriceItem. A number of values can be specified in a list separated by Space. 
						In the attribute "Component" can be defined to which component the AppliedBy refers to. If "Component" has no value, the default is "ThisComponent".
						
						In the course of developing OTDS 2.0 the attribute "Source" has been added, which in the future will completely replace the attribut "Component". 
						If both attributes have a value, both attribute have to be fulfilled. If only one attribute is filled, this attribute needs to be fulfilled. If neither
						"Source" nor "Component" is filled, from version V2.0 for Source the default ist valid.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="PriceItemClassTypeList">
								<xs:attributeGroup ref="ApplyAttributeGroup"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="AppliedByAll" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="2.0">
					<xs:annotation>
						<xs:documentation xml:lang="det">
Dieses Element definiert die Bedingung, dass das korrelierende Percent-PriceItem in einer der durch @Source und @Component referenzierten Komponenten bzw. Unterkomponenten definiert sein muss. 

Falls sowohl @Component als auch @Source gefüllt sind, so müssen beide Attribute erfüllt sein. Fehlt sowohl die Angabe von @Component als auch die von @Source, so gilt als Default: Component="ThisComponent".</xs:documentation>
						<xs:documentation xml:lang="en">The value is indicated which is stated in the PriceItem's attribute "Class". If there are several they can be specified in a list separated by Space.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attributeGroup ref="ApplyAttributeGroup"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="NotAppliedByPriceTags" type="PriceTagsApplyType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="2.0">
					<xs:annotation>
						<xs:documentation xml:lang="det">Dieses Element definiert die Bedingung , dass keines der hier angegeben PriceTags am korrelierenden Percent-PriceItem (Percent/PriceTags) definiert sein darf.

Das Element enthält einen oder mehrere Values eines PriceTags und zusätzlich wird in dem Attribut "Class" auch die Class des
						PriceTags festgelegt. Es können auch mehrere Werte als Liste mit Space
						getrennt angegeben werden. Außerdem kann man sich wie in der Tag-Condition
						mit dem Attributen Length und Offset auf Teilbereiche des PriceTag-Values
						beziehen. Das Attribut "Source" wird hier auch häufig mit der Eigenschaft
						"Hierarchy.All" verwendet, um PriceItems aus mehren SubKomponenten
						gleichzeitig zu referenzieren. Am häufigsten wird
						Source="Hierarchy.All:ThisComponent" vorkommen, welches die aktuelle
						Komponente inkl. alle Ancestors und Descendants referenziert. PriceTags sind
						Tags, die am Knoten "PriceItem" definiert werden.</xs:documentation>
						<xs:documentation xml:lang="en">In this element is being defined which other PriceItems can
						have an impact on this PriceItem. The element holds one or several values of
						a PriceTags; in addition the Class of the PriceTag is defined within the
						attribute "Class". A number of values can be specified in a list separated
						by Space. Also just like in the Tag-Condition it is possible to reference to
						certain sectors of the PriceTag-Value with the help of the attributes Length
						and Offset. The attribute "Source" in this aspect also is frequently used
						with the property "Hierarchy.All", in order to reference to PriceItems from
						several SubComponents at the same time. Most commonly the
						Source="Hierarchy.All:ThisComponent" will be used, which references the
						acutal Component including all ancestors and descendants. PriceTags are
						tags, that are defined at the node "PriceItem".</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="NotAppliedBy" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="2.0">
					<xs:annotation>
						<xs:documentation xml:lang="det">Dieses Element definiert die Bedingung, dass keines der hier angegeben Price-Classes am korrelierenden Percent-PriceItem (Percent/@Class) definiert sein darf.

Das Element enthält den Wert des Attributs "Class" des entsprechenden
						PriceItems. Es können auch mehrere Werte als Liste mit Space getrennt
						angegeben werden. In dem Attribut "Component" kann man definieren, auf
						welche Komponente sich das AppliedBy bezieht. 

Im Zuge der Erweiterung von OTDS 1.9 ist das Attribut "Source" hinzugekommen, welches die Referenzierung von Komponenten noch weiter einschränken kann. Falls beide Attribute gefüllt sind, so müssen beide Attribute erfüllt sein. Fehlt sowohl die Angabe von @Component als auch die von @Source, so gilt als Default: Component="ThisComponent".</xs:documentation>
						<xs:documentation xml:lang="en">The value is indicated which is stated in the PriceItem's attribute "Class". If there are several they can be specified in a list separated by Space.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="PriceItemClassTypeList">
								<xs:attributeGroup ref="ApplyAttributeGroup"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="NotAppliedByAll" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="2.0">
					<xs:annotation>
						<xs:documentation xml:lang="det">Dieses Element definiert die Bedingung, dass das korrelierende Percent-PriceItem in keiner der durch @Source und @Component referenzierten Komponenten bzw. Unterkomponenten definiert sein darf. 

Falls sowohl @Component als auch @Source gefüllt sind, so müssen beide Attribute erfüllt sein. Fehlt sowohl die Angabe von @Component als auch die von @Source, so gilt als Default: Component="ThisComponent".</xs:documentation>
						<xs:documentation xml:lang="en">Here PriceItems are excluded. The value is indicated which is stated in the PriceItem's attribute "Class".  If there are several they can be specified in a list separated by Space.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attributeGroup ref="ApplyAttributeGroup"/>
					</xs:complexType>
				</xs:element>
			</xs:choice>
		</xs:sequence>
	</xs:group>
	<xs:complexType name="PriceImpactPercentType">
		<xs:sequence>
			<xs:element name="Value" type="xs:decimal">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_389">Prozentwert für die Preisberechnung als
						Dezimalzahl (xx.xx). Abschläge werden als negativer Prozentwert, Aufschläge
						als positiver Prozentwert angegeben. Muss immer in Verbindung mit ApplyTo
						verwendet werden, um einen Bezug zu haben. Wird z.B. bei Kinderermäßigungen
						benötigt. z.B.: Ermäßigung 25% auf alles <Value>-25</Value>
						<ApplyToAll>true</ApplyToAll>
					</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_389">Percentage value for the price calculation as a decimal number (xx.xx).
Discounts are shown as a negative percentage, surcharges by a positive percentage.
Must always be used in combination with ApplyTo in order to have a point of reference.
Is required e.g. for discounts for children.
e.g. Discount of 25% on everything</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:group ref="ApplyToGroup" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="PriceImpactGenericType">
		<xs:sequence>
			<xs:element name="GenericValue" type="GenericValueType"/>
			<xs:group ref="AllocationBaseGroup"/>
			<xs:group ref="PriceAppliedByGroup"/>
		</xs:sequence>
		<xs:attribute name="ExecutionPriority" type="xs:int" default="0"/>
	</xs:complexType>
	<xs:complexType name="GenericValueType">
		<xs:choice>
			<xs:element name="Round" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8914">Dieses Element definiert, wie die durch "DomainSegmentedBy" definierten Segmente von PriceItems gerundet werden sollen. Dazu betrachtet die Round-Funktion jedes Ergebnisse der segmentierten PriceItems und rundet entsprechend der im Round-Element gesetzten Attribute. Die Funktion "Round" führt jeweils je Segment zu einem  generischen PriceItem mit Value="gerundeter Wert" - "berechneter Wert".</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8914">This element defines how the segments of PriceItems defined by "DomainSegmentedBy" are to be rounded. For this, the "Round" function treats each of the results of the segmented PriceItems and rounds according to the attributes set in the round element. As a result the "Round" function produces for each segment a generic PriceItem with Value = "rounded-off value" - "calculated value".</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="GroupAbsolutePriceItemsBy">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_8915">Dieses Element definiert, dass die Funktion jeweils auf mehrere Gruppen von Absolute-PriceItems angewendet wird.
Dabei werden die durch ApplyTo und AppliedBy adressierten Percent-PriceItems jeweils der Gruppe hinzugerechnet.

Es werden nur die unter ConsideredPriceItems definierten PriceItems berücksichtigt.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_8915">This element defines that the function is applied to each of several groups of Absolute-Price items. The Percent-PriceItems addressed by ApplyTo and AppliedBy will each be added to the group. Only the PriceItems defined under ConsideredPriceItems will be considered.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Person" type="EmptyElementType" minOccurs="0">
										<xs:annotation>
											<xs:documentation xml:lang="de" xml:id="de_8916">Alle absoluten PriceItems bezogen auf eine Person bilden eine separate Gruppe.</xs:documentation>
											<xs:documentation xml:lang="en" xml:id="en_8916">All absolute PriceItems referring to a person form a separate group.</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="Day" type="EmptyElementType" minOccurs="0">
										<xs:annotation>
											<xs:documentation xml:lang="de" xml:id="de_8917">Alle absoluten PriceItems bezogen auf einen Tag bilden eine separate Gruppe.</xs:documentation>
											<xs:documentation xml:lang="en" xml:id="en_8917">All absolute PriceItems referring to a day form a separate group.</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="AbsolutePriceItem" type="EmptyElementType" minOccurs="0">
										<xs:annotation>
											<xs:documentation xml:lang="de" xml:id="de_8918">Jedes absolute PriceItem bildet eine separate Gruppe.</xs:documentation>
											<xs:documentation xml:lang="en" xml:id="en_8918">Each absolute PriceItem forms a separate group.</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="PriceTagValue" type="EmptyPriceTagReferenceType" minOccurs="0" maxOccurs="unbounded" internal:otdsversion="1.9">
										<xs:annotation>
											<xs:documentation xml:lang="de" xml:id="de_8919">Alle absoluten PriceItems, die das hier definierte
												PriceTag mit identischem Value enthaltens bilden
												eine Gruppe. Nicht enthaltene PriceTags fließen je
												PriceTag mit dem Value="Default" jeweils in die
												dementsprechende Gruppe ein.</xs:documentation>
											<xs:documentation xml:lang="en" xml:id="en_8919">All absolute PriceItems that contain the defined PriceTag
												with identical value form a group. Price Tags not
												included are each included with the Value =
												"Default" in the corresponding
												group.</xs:documentation>
										</xs:annotation>
									</xs:element>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="ConsideredPriceItems" type="ConsideredPriceItemsType" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_8920">Beschränkt die zu berücksichtigenden PriceItems auf bestimmte Menge von PriceItems 
			eines bestimmten Types und/oder mit bestimmten PriceTags oder PriceClasses. Je Element "ConsideredPriceItems" wird eine Menge von PriceItems definiert.
			Bei mehrfacher Angabe des Elementes werden die einzelnen Mengen ver-ODER-ert.
			Es findet keine Duplizierung von PriceItems statt. 
			Falls ConsideredPriceItems kein Unterelement enthält, so werden alle PriceItems gemäß der Angaben in den Attributen "Source" und "ConsideredPriceItemType" berücksichtigt.
			
			Die Definition der Ergebnismenge eines  Elementes "ConsideredPriceItems"erfolgt in der folgenden Reihenfolge: 
			1. Auswahl der PriceItems gemäß der Attribute "Source" und "ConsideredPriceItemType"	
			
			2. Einschränkung der Auswahl der PreisItems auf bestimmte PriceClasses und PriceTags. Bei der Angabe mehrerer Unterelemente werden die einzelnen Einschränkungen bzgl. Tags und Classes ver-UND-et.
			
			3. Ergänzung der IncludedDescendants. </xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_8920">
									Restricts the PriceItems that need to be considered to a specific numer of 
						PriceItems of a specific type and/or with specific PriceTags or PriceClasses. For each element "ConsideredPriceItems" a numer of PriceItems is defined. If the element is indicated several times the single numbers are connected with OR. 
						There is no duplication of PriceItems.
						In the case that ConsideredPriceItems contains no sub-element, all PriceItems are considered according to the information in the attributes "Source" and "ConsideredPriceItemType".
						The definition of the result set of an element "ConsideredPriceItems" takes place in the following order:
					  1. selection of the PriceItems according to the attributes "Source" and "ConsideredPriceItemType"
					  2. Restriction of the selection of PriceItems to specific PriceClasses and PriceTags. When more than one sub-element is stated, the restrictions regarding Tags and Classes are connected with AND.
						3. Complementation of the IncludedDescendants.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="Method" type="RoundMethodEnum" default="Down">
						<xs:annotation>
							<xs:documentation xml:lang="de">Down
Up
AwayFromZero
TowardsZero</xs:documentation>
							<xs:documentation xml:lang="en">Down
								Up
								AwayFromZero
								TowardsZero</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="RemainingDigits" type="xs:int" default="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_8921">Anzahl der Stellen rechts vom Dezimalpunkt die nach dem Runden übrig bleiben. Rundung auf ganze Zahl bedeutet RemainingDigits=0.

Rundung auf die 2 Stelle hinter dem Komma bedeutet RemainingDigits=2 .
Negative Zahlen bedeuten Rundung auf 10er, 100er oder mehr.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_8921">Number of digits to the right of the decimal point remaining after the rounding. Rounding to an integer means RemainingDigits = 0. 
								Rounding to second decimal place means RemainingDigits = 2
								Negative numbers indicate rounding to 10 (tens), 100 (hundreds) or more.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="Threshold" type="xs:double" default="0.5">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_8922">Grenzwert  für Rundung in Abhängigkeit der Methode. Der Grenzwert gehört immer schon zu der Richtung, die der Name der Methode vorgibt.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_8922">Limit for rounding, in relation to the method. The limit
								belongs always to the direction set out by the name of the
								method.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="InheritPriceTags" type="InheritPriceTagsEnum">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_8923">Falls dieses Attribut den Wert "ConsideredAbsolutes" annimmt, dann erben
								die Generic-PriceItems die PriceTags der Considered
								Absolute-PriceItems.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_8923">If this attribute has the value "ConsideredAbsolutes" then the Generic-PriceItems inherit the PriceTags of the Considered Absolute-PriceItems.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element name="PercentModificationValue">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_8924">Dieses Element definiert einen generischen Absolutbetrag. Der Absolutbetrag berechnet sich für jeden Kostenknoten nach folgender Formel:
PercentModificationValue = ModificationBasis * PercentValue / 100
Wobei sich der Wert der ModificationBasis aus der OTDS-gemäßen Preiskalkulation der innerhalb des Elementes "ModificationBasis" definierten PriceItems bestimmt.
Die Angaben in DayBase und PersonBase sollten in der Regel immer = 1 sein. Abweichende Werte werden wie üblich einfach als Teiler benutzt, so dass die letztendliche anzuwendende Formel folgende ist: PercentModificationValue = ModificationBasis * PercentValue / 100 / DayBase / PersonBase</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_8924">This element defines a generic absolute amount. The absolute amount is calculated for each cost node according to the following formula:
PercentModificationValue = ModificationBasis * PercentValue / 100
Whereas the value of the ModificationBasis is generated from the PriceItems defined within the element "ModificationBasis" and used for the price calculation in accordance with OTDS.
The indications in DayBase and PersonBase in general should always = 1. Deviating values as usual are simply used as divisors, so that the formula to be applied is as follows: PercentModificationValue = ModificationBasis * PercentValue / 100 / DayBase / PersonBase</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="PercentValue" type="xs:decimal">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_8925">PercentValue repräsentiert den Wert "PercentValue" in der Formel

PercentModificationValue = ModificationBasis * PercentValue / 100 / DayBase / PersonBase  </xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_8925">PercentValue represents the value "PercentValue" in the formula

PercentModificationValue = ModificationBasis * PercentValue / 100 / DayBase / PersonBase  </xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ModificationBasis" internal:otdsversion="1.9">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_8926">Dieses Element definiert eine Menge von PriceItems, die durch eine OTDS konforme Preiskalkulation je Preisknoten den Wert "ModificationBasis"  in der Formel

PercentModificationValue = ModificationBasis * PercentValue / 100 / DayBase / PersonBase  

repräsentieren.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_8926">This element defines a number of PriceItems that thanks to an OTDS-conform price calculation represent the value "ModificationBasis" for each price node in the formula 
								
								PercentModificationValue = ModificationBasis * PercentValue / 100 / DayBase / PersonBase .</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="ConsideredPriceItems" type="ConsideredPriceItemsType" maxOccurs="unbounded">
										<xs:annotation>
											<xs:documentation xml:lang="de" xml:id="de_8927">Beschränkt die zu berücksichtigenden PriceItems auf bestimmte PriceItems eines bestimmten Types und/oder mit bestimmten PriceTags. Die Auswahl erfolgt in der	folgenden Reihenfolge: 1. Auswahl der PriceItems gemäß	PriceFilter 2. Ggf. Ergänzung der IncludedDescendants. Bei mehrfacher Angabe des Elementes besteht die finale Menge der PriceItems aus einem Merge der PriceItems der einzelnen ConsideredPriceItems-Auswertungen. Es findet keine Duplizierung von PriceItems statt.
Ist keine PriceItemFilterGroup angegeben, so findet keine Einschränkung der PriceItems statt. </xs:documentation>
											<xs:documentation xml:lang="en" xml:id="en_8927">Restricts the PriceItems to be considered to certain PriceItems of a specific type and/or with	certain Pricetags. The selection is made in the following order:
									1. selection of the PriceItems according to PriceFilter. 2. If necessary supplement of the IncludedDescendants. If the element
									occurs multiple times, the final amount of the PriceItems consists from a merge of the PriceItems of the individual
									ConsideredPriceItems evaluations. There will be no duplication of PriceItems. If no PriceItemFilterGroup is indicated, there will be no limitation of PriceItems. </xs:documentation>
										</xs:annotation>
									</xs:element>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="PriceAbsoluteType">
		<xs:sequence>
			<xs:element name="Value" type="MonetaryValue">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_390">Absolutwert des PriceItem</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_390">Absolute value of the PriceItem</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:group name="ApplyToGroup">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded">
				<xs:element name="ApplyToPriceTags" type="PriceTagsApplyType" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation xml:lang="det" xml:id="de_398">Dieses Element definiert die Bedingung , dass mindestens eines der hier angegeben PriceTags am korrelierenden Absolute-PriceItem (Absolute/PriceTags bzw. GenericAbsolute/PriceTags) definiert sein muss.

Das Element enthält einen oder mehrere Values eines
							PriceTags und zusätzlich wird in dem Attribut "Class" auch die Class des
							PriceTags festgelegt. Es können auch mehrere Werte als Liste mit Space
							getrennt angegeben werden. Außerdem kann man sich wie in der
							Tag-Condition mit dem Attributen Length und Offset auf Teilbereiche des
							PriceTag-Values beziehen. Das Attribut "Source" wird hier auch häufig
							mit der Eigenschaft "Hierarchy.All" verwendet, um PriceItems aus mehren
							SubKomponenten gleichzeitig zu referenzieren. Am Häufigsten wird
							Source="Hierarchy.All:ThisComponent" vorkommen, welches die aktuelle
							Komponente inkl. alle Ancestors und Descendants referenziert. PriceTags
							sind Tags, die am Knoten "PriceItem" definiert
							werden.</xs:documentation>
						<xs:documentation xml:lang="de" xml:id="en_398">In this element is being defined, which other PriceItems this PriceItem may have an impact on. 
							The element holds one or several values of a PriceTags; in addition the Class of the PriceTag is defined within the attribute "Class". 
							A number of values can be specified in a list separated by Space. Also just like in the Tag-Condition it is possible to reference to certain 
							sectors of the PriceTag-Value with the help of the attributes Length and Offset. The attribute "Source" in this aspect also is frequently used 
							with the property "Hierarchy.All", in order to reference to PriceItems from several SubComponents at the same time. Most commonly the 
							Source="Hierarchy.All:ThisComponent" will be used, which references the acutal Component including all ancestors and descendants. 
							PriceTags are tags, that are defined at the node "PriceItem".</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="ApplyTo">
					<xs:annotation>
						<xs:documentation xml:lang="det">Dieses Element definiert die Bedingung , dass mindestens eine der hier angegeben PriceClasses am korrelierenden Absolute-PriceItem (Absolute/@Class bzw. GenericAbsolute/@Class) definiert sein muss.

Das Element enthält den Wert des Attributs "Class" des entsprechenden
						PriceItems. Es können auch mehrere Werte als Liste mit Space getrennt
						angegeben werden. In dem Attribut "Component" kann man definieren, auf
						welche Komponente sich das AppliedBy bezieht. 

Im Zuge der Erweiterung von OTDS 1.9 ist das Attribut "Source" hinzugekommen, weclhes die Referenzierung von Komponenten noch weiter einschränken kann. Falls beide Attribute gefüllt sind, so müssen beide Attribute erfüllt sein. Fehlt sowohl die Angabe von @Component als auch die von @Source, so gilt als Default: Component="ThisComponent".</xs:documentation>
						<xs:documentation xml:lang="en">The value is specified, which is registered with the PriceItem in the attribute "Class". If there are several they can be given as a list separated by space.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="PriceItemClassTypeList">
								<xs:attributeGroup ref="ApplyAttributeGroup"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="ApplyToAll">
					<xs:annotation>
						<xs:documentation xml:lang="det">Dieses Element definiert die Bedingung, dass das korrelierende Absolue-PriceItem in einer der durch @Source und @Component referenzierten Komponenten bzw. Unterkomponenten definiert sein muss. 

Falls sowohl @Component als auch @Source gefüllt sind, so müssen beide Attribute erfüllt sein. Fehlt sowohl die Angabe von @Component als auch die von @Source, so gilt als Default: Component="ThisComponent".</xs:documentation>
						<xs:documentation xml:lang="en">The value is indicated which is stated in the PriceItem's attribute "Class". If there are several they can be specified in a list separated by Space.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attributeGroup ref="ApplyAttributeGroup"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="NotApplyToPriceTags" type="PriceTagsApplyType" maxOccurs="unbounded" internal:otdsversion="2.0">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_9010">Dieses Element definiert die Bedingung , dass keines der hier angegeben PriceTags am korrelierenden Absolute-PriceItem (Absolute/PriceTags bzw. GenericAbsolute/PriceTags) definiert sein darf.

In diesem Element wird definiert, auf welche anderen PriceItems dieses
							PriceItem wirkt. Das Element enthält einen oder mehrere Values eines
							PriceTags und zusätzlich wird in dem Attribut "Class" auch die Class des
							PriceTags festgelegt. Es können auch mehrere Werte als Liste mit Space
							getrennt angegeben werden. Außerdem kann man sich wie in der
							Tag-Condition mit dem Attributen Length und Offset auf Teilbereiche des
							PriceTag-Values beziehen. Das Attribut "Source" wird hier auch häufig
							mit der Eigenschaft "Hierarchy.All" verwendet, um PriceItems aus mehren
							SubKomponenten gleichzeitig zu referenzieren. Am Häufigsten wird
							Source="Hierarchy.All:ThisComponent" vorkommen, welches die aktuelle
							Komponente inkl. alle Ancestors und Descendants referenziert. PriceTags
							sind Tags, die am Knoten "PriceItem" definiert
							werden.</xs:documentation>
						<xs:documentation xml:lang="de" xml:id="en_9010">In this element is being defined, which other PriceItems this PriceItem may have an impact on. 
							The element holds one or several values of a PriceTags; in addition the Class of the PriceTag is defined within the attribute "Class". 
							A number of values can be specified in a list separated by Space. Also just like in the Tag-Condition it is possible to reference to certain 
							sectors of the PriceTag-Value with the help of the attributes Length and Offset. The attribute "Source" in this aspect also is frequently used 
							with the property "Hierarchy.All", in order to reference to PriceItems from several SubComponents at the same time. Most commonly the 
							Source="Hierarchy.All:ThisComponent" will be used, which references the acutal Component including all ancestors and descendants. 
							PriceTags are tags, that are defined at the node "PriceItem".</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="NotApplyTo">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_9265">Dieses Element definiert die Bedingung, dass keines der hier angegeben PriceClasses am korrelierenden Absolute-PriceItem (Absolute/@Class bzw. GenericAbsolute/@Class) definiert sein darf.

Das Element enthält den Wert des Attributs "Class" des entsprechenden PriceItems. Es können auch mehrere Werte als Liste mit Space getrennt
angegeben werden. In dem Attribut "Component" kann man definieren, auf welche Komponente sich das AppliedBy bezieht. 

Im Zuge der Erweiterung von OTDS 1.9 ist das Attribut "Source" hinzugekommen, welches die Referenzierung von Komponenten noch weiter einschränken kann. Falls beide Attribute gefüllt sind, so müssen beide Attribute erfüllt sein. Fehlt sowohl die Angabe von @Component als auch die von @Source, so gilt als Default: Component="ThisComponent".</xs:documentation>
						<xs:documentation xml:lang="en"  xml:id="en_9265">This element defines the condition, that none of the PriceClasses indicated here may be defined at the correlating Absolute-PriceItem (Absolute/@Class bzw. GenericAbsolute/@Class).

The element contains the value of the attribute "Class" of the corresponding PriceItems.  If there are several values, they can be specified in a list separated by Space. In the attribute "Component" it can be defined, to which component the AppliedBy refers to.

In OTDS 1.9 the attribute "Source" was added, which can further restrict the referencing of components. If both attributes are filled, then both attributes have to be fulfilled. If both the indication of @Component as well as of @Source is missing, the Component="ThisComponent" is the default.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="PriceItemClassTypeList">
								<xs:attributeGroup ref="ApplyAttributeGroup"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="NotApplyToAll" internal:otdsversion="2.0">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_9266">Dieses Element definiert die Bedingung, dass das korrelierende Absolute-PriceItem in keiner der durch @Source und @Component referenzierten Komponenten bzw. Unterkomponenten definiert sein darf. 

Falls sowohl @Component als auch @Source gefüllt sind, so müssen beide Attribute erfüllt sein. Fehlt sowohl die Angabe von @Component als auch die von @Source, so gilt als Default: Component="ThisComponent".</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_9266">This element defines the condition, that the correlating Absolute-PriceItem may be defined in noe of the components or sub-components referenced by @Source and/or @Component.
If both @Source and @Component are given, both attributes have to be fulfilled. If the indications of both @Component as well as of @Source are missing, then the following default is valid: Component="ThisComponent".</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attributeGroup ref="ApplyAttributeGroup"/>
					</xs:complexType>
				</xs:element>
			</xs:choice>
		</xs:sequence>
	</xs:group>
	<xs:group name="ConsideredPriceItemsGroup">
		<xs:choice>
			<xs:element name="ConsideredPriceItemClasses" type="PriceItemClassTypeList">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_397">Es wird der Wert angegeben, der beim PriceItem im Attribut "Class" eingetragen ist. Bei mehreren können diese als Liste durch Space getrennt angegeben werden.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_397">The value given is that which is specified for the PriceItem in the attribute "Class". If there are several, these can be provided as a list separated by a space.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="NotConsideredPriceItemClasses" type="PriceItemClassTypeList">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_399">Hier werden PriceItems ausgeschlossen. Es wird der Wert angegeben, der beim PriceItem im Attribut "Class" eingetragen ist. Bei mehreren können diese als Liste durch Space getrennt angegeben werden.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_399">PriceItems are excluded here. The value given is that which is specified for the PriceItem in the attribute "Class". If there are several, these can be provided as a list separated by a space.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:group name="DayPriceIndexConsideredPriceItemsGroup">
		<xs:choice>
			<xs:element name="ConsideredPriceItemClasses">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_9011">Es wird der Wert angegeben, der beim PriceItem im Attribut "Class" eingetragen ist. Bei mehreren können diese als Liste durch Space getrennt angegeben werden.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_9011">The value given is that which is specified for the PriceItem in the attribute "Class". If there are several, these can be provided as a list separated by a space.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="PriceItemClassTypeList">
							<xs:attributeGroup ref="ComponentAttributeGroup"/>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="NotConsideredPriceItemClasses">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_9012">Hier werden PriceItems ausgeschlossen. Es wird der Wert angegeben, der beim PriceItem im Attribut "Class" eingetragen ist. Bei mehreren können diese als Liste durch Space getrennt angegeben werden.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_9012">PriceItems are excluded here. The value given is that which is specified for the PriceItem in the attribute "Class". If there are several, these can be provided as a list separated by a space.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="PriceItemClassTypeList">
							<xs:attributeGroup ref="ComponentAttributeGroup">
								<xs:annotation>
									<xs:documentation xml:lang="de" xml:id="de_534">Das Attribut Component beschränkt den Wirkungsradius der hier definierten Classes auf PriceItems einer bestimmte Komponente. Per Default beschränkt sich die Kombinatorik auf PriceItems aus der selben Komponente (ThisComponent). Wenn die Kombinatorikbedingungen auf ein PriceItem einer anderen Komponente wirken sollen, muss dies hier explizit angegeben werden.</xs:documentation>
									<xs:documentation xml:lang="en" xml:id="en_534">The component attribute limits the scope of possible combinations to PriceItems of a specific component. By default, the combinations are limited to PriceItems from the same component (ThisComponent). If the combination conditions are to have an affect on a PriceItem of another component, this must be explicitly stated here.</xs:documentation>
								</xs:annotation>
							</xs:attributeGroup>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- product specific Types -->
	<xs:complexType name="TagsType">
		<xs:complexContent>
			<xs:extension base="SimpleUpdateNodeType">
				<xs:sequence>
					<xs:element name="Tag" type="TagType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_401">Die Tags werden für die Kombinationsregeln von Reisekomponenten benutzt. Die Tags können über das Attribut "Class" genauer spezifiziert werden. </xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_401">The tags are used for the combination rules of travel components. The tags can be more precisely specified via the "Class" attribute.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="ConditionalTag" type="ConditionalTagType" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ProductsTagsType">
		<xs:complexContent>
			<xs:extension base="TagsType">
				<xs:sequence>
					<xs:element name="GenericTag" type="GenericTagType" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TagType">
		<xs:simpleContent>
			<xs:extension base="TokenType">
				<xs:attributeGroup ref="TagAttributeGroup"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="MatchType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_404">Mit Match kann man Felder definieren, die im Wert übereinstimmen müssen, damit die Bedingung erfüllt ist. Die Felder können	sowohl Tags mit Class sein, als auch Elemente. Bei Tags definiert dieses Element die Tag Position und die Class die entsprechende Class des Tags.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_404">Match serves to define fields that must match in value so that the condition is satisfied. The fields can be both tags with class, as well as elements. For tags the element defines the tag position and the class the corresponding class of the tag.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="2" maxOccurs="unbounded">
			<xs:element name="Key" type="EmptyKeyConditionType" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_3">Dieses Element adressiert einen bestimmten Key innerhalb des Angebotskontextes. Der Angebotskontext besteht dabei aus allen möglichen Kombinationen der in der ProductRule angegebenen Komponenten. Die Kombinatorik geht dabei bis auf die Terminebene hinunter.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_3">This element addresses a specific key within the
						offer context. The offer context consists of all possible combinations of	the components specified in the ProductRule. The combinatorics go down to
						the date level.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Tag" type="EmptyTagConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_405">Dieses Element adressiert ein bestimmtes Tag innerhalb des Angebotskontextes. Der Angebotskontext besteht dabei aus allen möglichen Kombinationen der in der ProductRule angegebenen Komponenten. Die Kombinatorik geht dabei bis auf die Terminebene hinunter.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_405">This element addresses a specific tag within the offer context. The offer context consists of all possible combinations of the components specified in the ProductRule. The combinatorics go down to the date level.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ConditionalTag" type="EmptyTagConditionType" internal:otdsversion="1.9.2">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_535">Dieses Element adressiert ein bestimmtes ConditionalTag innerhalb des Angebotskontextes. 
Bei der Auswertung reicht es, wenn das ConditionalTag in einem Day- oder PersonKnoten identisch ist.
Der Angebotskontext besteht dabei aus allen möglichen Kombinationen der in der ProductRule angegebenen Komponenten. Die Kombinatorik geht dabei bis auf die Terminebene hinunter.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_535">This element addresses a specific tag within the offer context. For the evaluation it is sufficient, if a ConditionalTag is identical within a Day- or a Person node. 
					The offer context consists of all possible combinations of the components specified in the ProductRule. The combinatorics go down to the date level.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Element">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_406">Dieses Element adressiert einen bestimmten Knoten oder Parameter innerhalb des Angebotskontextes. Der Angebotskontext besteht dabei aus allen möglichen Kombinationen der in der ProductRule	angegebenen Komponenten. Die Kombinatorik geht dabei bis auf die Terminebene hinunter. 
Über das Attribut "Source" wird die Unterkomponente adressiert.
Der Body dieses Elements spezifiziert den SourceKnoten als nächsten	untergeordneten Knoten unterhalb der adressierten Unterkomponente.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_406">This element addresses a specific node or parameter within
						the offer context. The offer context consists of all possible combinations of the components specified in the ProductRule. The combinatorics go down to	the date level.
						Via the attribute "Source" the subcomponent is addressed. The body of this element specifies the SourceNode as the next subordinate node below the addressed subcomponent.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="MatchElementEnum">
							<xs:attributeGroup ref="ConditionAttributeGroup"/>
							<xs:attributeGroup ref="SourceAttributeGroup"/>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="CompareType">
		<xs:choice minOccurs="2" maxOccurs="unbounded">
			<xs:element name="Key" type="EmptyKeyConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_321">Dieses Element adressiert eine Menge von Key-Values innerhalb des Angebotskontextes. Der Angebotskontext besteht dabei aus allen möglichen Kombinationen der in der ProductRule angegebenen Komponenten. Die Menge der Key-Values wird eingegrenzt durch die Angabe in den Attributen "Source" und "DayAllocation". Im Falle, dass mit Source und DayAllocation mehrere Komponenten-Instanzen referenziert werden, entscheidet @EvaluationMode, ob nur eine der Instanzen ("Any") die Bedingung erfüllen muss oder ob alle ("All") Instanzen die Bedingung erfüllen müssen.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_321">This element addresses a number of Key-Values within the offer context. The offer context consists from all possible combinations of the components indicated in the ProductRule. 
					The amount of Key-Values is limited by the indication in the attributes "Source" and "DayAllocation". In case that with Source and DayAllocation numerous component instances are referenced, @EvaluationMode determines if only one of the instances ("Any") fulfills the condition or if all ("All") instances have to fulfill the condition.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Tag" type="EmptyTagConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_322">Dieses Element adressiert ein Menge von Tag-Values innerhalb des Angebotskontextes. Der Angebotskontext besteht dabei aus allen möglichen Kombinationen der in der ProductRule angegebenen Komponenten. 
Die Menge der Tag-Values wird eingegrenzt durch die Angabe in den Attributen "Class", "TagValueType", "Source" und "DayAllocation". Im Falle, dass mit Source und DayAllocation mehrere Komponenten-Instanzen referenziert werden, entscheidet @EvaluationMode, ob nur eine der Instanzen ("Any") die Bedingung erfüllen muss oder ob alle ("All") Instanzen die Bedingung erfüllen müssen. 
Die Attribute "@Offset" und "@Length" definieren, welcher Anteil des Tag-Values betrachtet werden soll.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_322">This element addresses a number of tag values within the offer context. The offer context consists from all possible combinations of the components indicated in the ProductRule. 
					The amount of tag values is limited by the indication in the attributes "Class", "TagValueType","Source" and "DayAllocation". In case that with Source and DayAllocation numerous component instances are referenced, @EvaluationMode determines if only one of the instances ("Any") fulfills the condition or if all ("All") instances have to fulfill the condition.
The attributes "@Offset" and "@Length" define, which part of the tag value has to be considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ConditionalTag" type="EmptyTagConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_371">Dieses Element adressiert ein Menge von ConditionalTag-Values innerhalb des Angebotskontextes. Der Angebotskontext besteht dabei aus allen möglichen Kombinationen der in der ProductRule angegebenen Komponenten. 
Die Menge der ConditionalTag-Values wird eingegrenzt durch die Angabe in den Attributen Class, TagValueType, Source und DayAllocation. Im Falle, dass mit Source und DayAllocation mehrere Komponenten-Instanzen referenziert werden, entscheidet @EvaluationMode, ob nur eine der Instanzen ("Any") die Bedingung erfüllen muss oder ob alle ("All") Instanzen die Bedingung erfüllen müssen. 
Die Attribute @Offset und @Length definieren, welcher Anteil des ConditionalTag-Values betrachtet werden soll.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_371">This element addresses a number of ConditionalTag-Values within the offer context. The offer context consists from all possible combinations of the components indicated in the ProductRule.
The amount of ConditionalTag-Values is limited by the indication in the attributes "Class", "TagValueType","Source" and "DayAllocation". In case that with Source and DayAllocation numerous component instances are referenced, @EvaluationMode determines if only one of the instances ("Any") fulfills the condition or if all ("All") instances have to fulfill the condition.
The attributes "@Offset" and "@Length" define, which part of the ConditionalTag value has to be considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Element">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_386">Dieses Element adressiert ein Menge von Komponenten-Ausprägungs-Values innerhalb des Angebotskontextes. Der Angebotskontext besteht dabei aus allen möglichen Kombinationen der in der ProductRule angegebenen Komponenten. 
Derzeit existieren lediglich Abflughafen, Zielflughafen und Catchment-Airports als verwendbare Ausprägungen.
Dementsprechend eingegrenzt wird diese Menge an Komponenten-Ausprägungsvalues durch die Angabe einer bestimmten Komponentenausprägung als Wert von "Element" einer bestimmten Source und der DayAllocation. Im Falle, dass mit Source und DayAllocation mehrere Komponenten-Instanzen referenziert werden, entscheidet @EvaluationMode, ob nur eine der Instanzen ("Any") die Bedingung erfüllen muss oder ob alle ("All") Instanzen die Bedingung erfüllen müssen. 
Die Attribute @Offset und @Length definieren, welcher Anteil des Komponenten-Ausprägungs-Values betrachtet werden soll.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_386">This element addresses a number of ComponentCharacteristics-Values within the offer context. The offer context consists from all possible combinations of the components indicated in the ProductRule. At present only departure airport, destination airport and catchment airport exist as applicable characteristics.
The amount of ComponentCharacteristics-Values is accordingly limited by the indication of a certain ComponentCharacteristic as value of "element" of a specific Source an the DayAllocation. In case that with Source and DayAllocation numerous component instances are referenced, @EvaluationMode determines if only one of the instances ("Any") fulfills the condition or if all ("All") instances have to fulfill the condition.
The attributes "@Offset" and "@Length" define, which part of the ComponentCharacteristics value has to be considered.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="MatchElementEnum">
							<xs:attributeGroup ref="ConditionAttributeGroup"/>
							<xs:attributeGroup ref="SourceAttributeGroup"/>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="Values" type="CompareValuesConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_387">Dieses Element definiert eine Menge von Values, </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_387">This element defines a number of values, </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:attribute name="Operation" type="CompareOperationEnum" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_8936">Dieses Attribut legt die Vergleichsoperation fest. Es stehen die klassischen mathematischen Vergleichoperationen zur Verfügung:
- Equal
- LessThan
- LessThanOrEqual
- GreaterThan
- GreaterThanOrEqual</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_8936">This attribute determines the comparison operation. The classic mathematical comparison operation can be applied:
- Equal
- LessThan
- LessThanOrEqual
- GreaterThan
- GreaterThanOrEqual</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--  Availability Types definitions -->
	<!--  Availability definitions -->
	<xs:complexType name="AvailabilitiesType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_407">Unter diesem Zweig werden die Verfügbarkeiten eines Objektes definiert. Im Zusammenspiel mit den Conditions und entsprechenden DefaultDayStates können sowohl tageweise Verfügbarkeiten als auch dauerbezogene Verfügbarkeiten geliefert werden. Generell erlaubt die Definition des DefaultDayStates sowohl eine Lieferung von nur positiven Verfügbarkeiten als auch nur negativen Verfügbarkeiten. 
Die Ebene Availabilities definiert, welche Art der Verfügbarkeits-Lieferung vorliegt. Wenn zum Beispiel eine Steuerung der Verfügbarkeiten über die Belegung stattfindet, so wird  je eingeschränkter Belegung ein eigener Availabilities-Zweig mit einer entsprechenden Belegungsbedingung unter "Conditions" angeben. Im Allgemeinen sollte der Key des Availabilities-Knoten genau mit dieser Condition korrelieren, damit der Key für inkrementelle Updates immer eindeutig reproduzierbar ist. 
Viele Beispiele unterschiedlicher Verfügbarkeitslieferungen finden Sie in der Thematischen Dokumentation unter "Availabilities".</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_407">Under this branch the availabilites of an object are defined. In combining them with Conditions and the corresponding DefaultDayStates not only availabilities on day-basis but also duration-related availabilities can be delivered. In general the definition of DefaultDayStates allows the delivery of only positive availabilities as well as of only negative availabilities.
The level availabilities defines, which kind of availability delivery is at hand. If for instance a steering of availabilities takes place via the occupancy, for each restricted occupancy a separate availability branch with a corresponding occupancy condition will be indicated under "Conditions". In general the key of the availability node should correlate with this very condition in order to make the key always unambiguously reproducible for incremental updates.
There are numerous examples for different availability deliveries in the "Thematischen Documentation" (search for "Availabilities").</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MultipleCompositeUpdateNodeType">
				<xs:sequence>
					<xs:element name="Availability" type="AvailabilityType" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_408">Unter diesem Zweig wird jeweils ein Block von tageweisen Verfügbarkeiten geliefert. Das Startdate definiert den ersten Tag des Blockes. In den Kindelementen "DayState" stellt jeweils ein Attribut "Offset" einen relativen Bezug zum StartDate her und definiert so en jeweils betrachteten Tag. Es sollte darauf geachtet werden, dass ein reproduzierbarer Key gewählt wird, so dass inkrementelle Lieferungen von einzelnen DayState-Elementen möglich sind.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_408">Under this branch, a block with the availabilities for each day is delivered. The StartDate defines the first day of the block. In the "DayState" element each "Offset" attribute creates a relative reference to the StartDate and defines each day viewed in doing so. You should ensure that a reproducible Key is selected, so that incremental deliveries of individual DayState elements are possible.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Condition" type="ConditionSimpleNodeType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_409">In diesem Zweig wird definiert, welche zusätzlichen Bedingungen für die unter Availability gelieferten Verfügbarkeiten gelten. Im Allgemeinen sollte der Key des Availabilities-Knoten genau mit dieser Condition korrelieren, damit der Key für inkrementelle Updates immer eindeutig reproduzierbar ist.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_409">This branch defines which additional conditions apply to the availabilities listed under Availability. In general, the key for the Availabilities node should correlate exactly with this condition, so that the key is always unambiguously reproducible for incremental updates.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AvailabilityType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_411">Dieser Type definiert einen Block von tageweisen	Verfügbarkeiten (DayState-Elementen). Das StartDate definiert den ersten Tag des Blockes. In den Kindelementen "DayState" stellt jeweils ein Attribut "Offset" einen relativen Bezug zum StartDate her und definiert so jeweils den betrachteten Tag. Der erste Tag hat in DayState den Offset=0. Zusätzlich muss auch ein EndDate definiert werden. Das EndDate spielt besonders dann eine Rolle, wenn der DefaultDayState auf "Open" steht. Denn alle nicht gelieferten DayStates sind dann verfügbar. Es sollte darauf geachtet werden, dass ein reproduzierbarer AvailabilityKey gewählt wird, so dass inkrementelle Lieferungen von einzelnen DayState-Elementen möglich sind.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_411">This Type defines a block of availabilities for each day (DayState elements). The StartDate defines the first day of the block. In the "DayState" child elements, each "Offset" attribute creates a relative reference to the StartDate and defines the day concerned for each. The first day has the Offset=0 in DayState. An EndDate must also be defined. The EndDate is particularly important if the DefaultDayState is set to "Open". Then all non-delivered DayStates will be available. You should then ensure that a reproducible AvailabilityKey is selected, so that incremental deliveries of individual DayState elements are possible.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MultipleCompositeUpdateNodeType">
				<xs:sequence>
					<xs:element name="DefaultDayState" type="DefaultDayStateType">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_412">Dieser Zweig definiert analog zu DayState, welche Stati gesetzt werden sollen, wenn in diesem AvailabilityBlock ein kompletter DayState oder auch einzelne Stati nicht besetzt sind. Dadurch kann man sowohl nur negative als auch nur positive Availabilities explizit liefern.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_412">In a similar manner to DayState, this branch defines which statuses should be set, if an entire DayState or individual statuses are not set in this AvailabilityBlock. Here you can have either negative Availabilities only or positive Availabilities only.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DayState" type="DayStateType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_413">Unter diesem Zweig wird der Verfügbarkeitsstatus eines Tages aus einem Availability-Block definiert. Das Attribut "Offset" im DayState-Knoten stellt eine Beziehung zum StartDate im Availabilityknoten her. Startdate und Offset ergeben das Datum des betrachteten Termins im DaySate. Der erste Termin (StartDate) hat damit den Offset=0. 

Im DayState kann der Verfügbarkeitsstatus bzgl. der unterschiedlichen Tageskontexte 
- Aufenthaltes (Stay) 
- Anreise (CheckIn) 
- Abreise (CheckOut) 
definiert werden.

Folgende Verfügbarkeitsstati stehen zur Verfügung: 
- Open
- Request
- Closed
- StopSale
- Blacklisted

Seit Version 2.0 kann bzgl. jedes Tageskontexts das verfügbare Kontingent mit angegeben werden. In der Regel werden keine Kontingente &gt;9 angegeben. Das obliegt aber dem Lieferanten.

Eine Reise ist verfügbar, wenn 
1. die CheckIn-Termine der Hauptkomponenten-Instanzen die CheckIn-Stati "Open" oder "Request" besitzen 
2. die CheckOut-Termine der Hauptkomponenten-Instanzen die CheckOut-Stati "Open" oder "Request" besitzen
3. die Stay-Termine der Hauptkomponenten-Instanzen die Stay-Stati "Open" oder "Request" besitzen
4. die Anzahl der Personen bzw. gebuchten Units in die ggf. angegebenen Tageskontingente (Vaues in Stay, CheckIn, CheckOut oder Stay) passen. 
Ob Personen oder Units durch die Availability addressiert werden legt die Angabe unter Occupancy/Person/AvailabilityMatching fest. 
Mit der AvailabilityState-Condition lässt sich die Gültikeit bezogen auf die AvailabilityStates weiter einschränken.

Im Zusammenspiel mit den Angaben im Element DefaultDayState ist man in der Lage, weitreichende Default-Einstellungen für die Werte jedes DayStates vorgeben zu können.
Ist zu einem Termin kein DayState-Element enthalten, so definieren die unter DefaultDayState angegebenen Elemente und ggf. deren Defaults die Default-Angaben für die Elemente Stay, CheckIn und CheckOut.

Ist ein DayState für einen Termin angegeben, aber keines der Elemente
Open
Closed
Request
StopSales
Blacklisted
Stay,
so definieren die entsprechenden unter DefaultDayState angegebenen Elemente die entsprechenden Defaultwerte.

Ist ein DayState für einen Termin angegeben, aber es fehlt sowohl eine Angabe zu CheckIn als auch eine Angabe zu NoCheckIn, so definieren die unter DefaultDayState angegebenen Elemente CheckIn bzw. NoCheckIn und ggf. deren Defaults die Default-Angaben für das Element CheckIn und ggf. NoCheckIn.

Ist ein DayState für einen Termin angegeben, aber es fehlt sowohl eine Angabe zu CheckOut als auch eine Angabe zu NoCheckout, so definieren die unter DefaultDayState angegebenen Elemente Checkout bzw. NoCheckOut und ggf. deren Defaults die Default-Angaben für das Element CheckOut und ggf. NoCheckout.
</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_413">Under this branch the availability status of a day from an AvailabilityBlock is defined. The "Offset" attribute in the DayState node creates a reference to the StartDate in the availability node. StartDate and Offset give the date of the day concerned. The first day (StartDate) has the Offset=0. 

Within DayState the availability status with relation to the following different day context can be defined:
-	Stay
-	CheckIn
-	CheckOut

The following statuses for availabilities may be used:
- Open
- Request
- Closed
- StopSale
- Blacklisted

Since version 2.0 the available allotment can be indicated relating to each day context. As a rule no allotments &gt;9 are indicated. However this is subject to the provider.

A trip is available, if for the CheckIn date one of the given CheckIn statuses is set, if also for the CheckOut date one of the given CheckOut statuses is set, and if all Stay dates have set one of the given Stay statuses.
In addition also the number of persons and booked units have to match the given day allotments. If persons or units are addressed by availability is determined by the indication in Occupancy/Person/AvailabilityMatching.
By further combination with the indications in the element DefaultDayState it is possible to determine elaborate default settings for the values of each DayState.

If there is no DayState element for a given date, the elements indicated under DefautDayState and, if applicable, their defaults define the default indications for the elements Stay, CheckIn and CheckOut.

If a DayState is indicated for a date, but none of the elements
Open
Closed
Request
StopSales
Blacklisted
Stay,
the corresponding elements indicated under DefaultDayState define the default values.

If a DayState is given for a date, but holds no indication for neither CheckIn nor NoCheckIn, the elements CheckIn repectively NoCheckIn indicated under DefaultDayState and, if applicable, their defaults define the default indications for the element CheckIn and, if applicable, NoCheckIn.

If a DayState is given for a date, but holds no indication for neither CheckOut nor NoCheckOut, the elements CheckOut repectively NoCheckOut indicated under DefaultDayState and, if applicable, their defaults define the default indications for the element CheckOut and, if applicable, NoCheckOut.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="StartDate" type="xs:date" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_414">Dieses Attribut definiert den ersten Tag des Verfügbarkeitsblocks, der in dem entsprechenden Availability-Zweig enthalten sein kann. Der Block besteht aus mehreren DayState Elementen, von denen jedes für einen Tag steht. Die DateState Elemente beziehen sich über das Attribut "Offset" relativ auf das StartDate und definieren so den Termin des DayState-Elementes. Das DayState-Element für den ersten Tag hat den Offset=0.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_414">This attribute defines the first day of the availability block in which the corresponding availability branch can be contained. The block consists of several DayState elements, each of which represents a day. The DateState elements refer via the attribute "Offset" to the relative StartDate and in this way define the date of the DayState element. The DayState element for the first day has the Offset=0.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="EndDate" type="xs:date" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_415">Dieses Attribut definiert den letzten Tag des Verfügbarkeitsblocks, der in dem entsprechenden Availability-Zweig enthalten sein kann. Das EndDate ist besonders dann ausschlaggebend, wenn DefaultDayStates auf Open stehen. Denn alle nicht gelieferten DayStates sind dann verfügbar. </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_415">This attribute defines the last day of the availability block which can be contained in the corresponding availability branch. The EndDate is particularly determinative if DefaultDayStates are set to Open. Due to the fact that all non-delivered DayStates will be available.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DayStateType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_416">Dieser Type definiert den Verfügbarkeitsstatus eines Tages aus einem Availability-Block. Das Attribut "Offset" im DayState-Knotenstellt eine Beziehung zum StartDate im Availabilityknoten her. StartDate und Offset ergeben das Datum des betrachteten Termins. Es können sowohl unterschiedliche Stati (Open, Request, Closed, etc.) als auch freie Plätze angegeben werden. Das Vorhandensein der Elemente "Open", "Closed", etc. zeigt den Status an. Bei "Open" und "Request" können die Anzahl der verfügbaren Plätze auch als Wert angegeben werden. 
Zusätzlich zur einfachen Angabe der Availabilities kann definiert werden, ob ein Tag für Ankunft oder Abreise verwendet werden darf oder nicht. Wenn es keine weitere Information zu Ankunft/Abreise gibt, werden keine Einschränkungen bezüglich der Ankunft-/Abreise-Optionen angezeigt. 
Der Key sollte reproduzierbar sein, um Incremental Updates für einzelne Tage zu ermöglichen. Im einfachsten Falle entspricht Key dem Offset.
			</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_416">This Type defines the availability status of a day from the availability block. The "Offset" attribute creates a reference to the StartDate in the parent node. StartDate and Offset gives the date of the day concerned. Either different statuses (Open, Request, Closed, etc.) or free spaces can be indicated. The mere presence of the elements "Open", "Closed", etc. indicates the status. For Open and Request the number of free spaces can also be provided as a value. In addition to simply stating the availabilities, you can also define whether or not a day can be used as arrival or departure. If there is no entry for arrival/departure, there will be no restrictions displayed with regard to the departure/arrival options. The key should be reproducible, so as to make it possible to make incremental updates for individual days. In the simplest case the Key is the same as the Offset.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MultipleSimpleUpdateNodeType">
				<xs:sequence>
					<xs:choice>
						<xs:element name="Open" type="AvailabilityOpenType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_417">Dieses Element enthält die Anzahl freier Verfügbarkeiten für diesen Tag. Ist das Element vorhanden, aber ohne Value, so bedeutet dies, dass der Tag generell verfügbar ist.
Eine Definition in diesem Element wird durch eine gleichzeitige Definition im Element DayState/Stay ersetzt.

Grundsätzlich gilt der Status "Open" als verfügbar. Mit dem AvailabilityState-Filter kann diese Interpretation aber weiter eingeschränkt werden.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_417">This element contains the amount of free availability for this day. If the element is present but without a Value, this means that the day is available in general.
A definition in the element is replaced by a simultaneous definition in the element  DayState/Stay.
In general the State "Open" is considered as available. With the help of the AvailabilityState-Filter however this interpretation can be further restricted.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Request" type="AvailabilityRequestType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_418">Dieses Element enthält die Anzahl der verfügbaren Plätze, die aber nur auf Anfrage zur Buchung freigegeben werden. Ist das Element vorhanden, aber ohne Value, so bedeutet dies, dass der Tag nur auf Anfrage verfügbar ist.
Eine Definition in diesem Element wird durch eine gleichzeitge Definition im Element DayState/Stay ersetzt. Grundsätzlich gilt der Status "Request" als verfügbar. Mit dem AvailabilityState-Filter kann diese Interpretation aber weiter eingeschränkt werden.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_418">This element contains the number of available spaces, which are however only released upon booking request. If this element is present, but without a Value, this means that the date is only available on request.
								A definition in this element is replaced by a simultaneous definition in the element DayState/Stay. In general the State "Request" is considered available. With the help of the AvailabilityState-Filter however this interpretation can be restricted further.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Closed" type="AvailabilityEmptyType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_419">Ist dieses Element in einer Lieferung enthalten, so zeigt es an, dass ein Tag nicht verfügbar ist. Das Element kann keinen Wert enthalten.
Eine Definition in diesem Element wird durch eine gleichzeitge Definition im Element DayState/Stay ersetzt.
Grundsätzlich gilt der Status "Closed" als nicht verfügbar.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_419">If this element is contained in a data delivery, it shows that a day is not available. The element cannot contain a value.
								A definition in this element is replaced by a simultaneous definition in the element DayState/Stay. In general the State "Closed" is considered as not available.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="StopSales" type="AvailabilityEmptyType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_420">Ist dieses Element in einer Lieferung enthalten, so zeigt es an, dass dieser Termin zur Zeit nicht angeboten wird. Das Element kann keinen Wert enthalten.
Eine Definition in diesem Element wird durch eine gleichzeitge Definition im Element DayState/Stay ersetzt.

Grundsätzlich gilt der Status "StopSales" als nicht verfügbar.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_420">If this element is contained in a data delivery, it indicates that this date is not currently offered. The element cannot contain a value.
A definition in this element is replaced by a simultaneous definition in the element DayState/Stay. In general the State "StopSales" is considered as not available.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Blacklisted" type="AvailabilityEmptyType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_421">Ist dieses Element in einer Lieferung enthalten so zeigt es an, dass dieser Termin zur Zeit nicht angeboten werden kann, da es auf einer Blacklist steht. Das Element kann keinen Wert enthalten.
Eine Definition in diesem Element wird durch eine gleichzeitige Definition im Element DayState/Stay ersetzt.
Grundsätzlich gilt der Status "Blacklisted" als nicht verfügbar.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_421">If this element is contained in a data delivery, it indicates that this date cannot currently be offered, as it appears on a blacklist. The element cannot contain a value. A definition in this element is replaced by a simultaneous definition in the element DayState/Stay.
In general the State "Blacklisted" is reagarded as not available</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Stay" type="AvailabilityStateType" internal:otdsversion="2.0">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_8959">Ist dieses Element in einer Lieferung enthalten, so definiert das Element an diesem Termin einen spezifischen Verfügbarkeitsstatus.
Im Attribut @State können folgende Verfügbarkeitsstati angegeben werden: 
- Open
- Request
- Closed
- StopSale
- Blacklisted

Grundsätzlich gelten die Stati "Open" und "Request" als verfügbar. Mit dem AvailabilityState-Filter kann diese Interpretation aber weiter eingeschränkt werden.

Enthält das Stay-Element eine Zahl, so drückt dies aus, wieviele Units bzw. Personen noch bzgl. des Aufenthalt-Verfügbarkeits-Status möglich sind. Ob es bei der Zahl um die Anzahl der Personen geht, wird durch das Attribut Occupancy/Person/@MatchAvailability festgelegt.
Mit dem State-Attribut gibt man den generellen Status bzgl. des Aufenthaltes an.

Die Definition des Stay-Elementes ersetzt eine gleichzeitge Definition von 
DefaultDayState/Open,
DefaultDayState/Closed,
DefaultDayState/Request,
DefaultDayState/StopSales,
DefaultDayState/Blacklisted.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_8959">If this element is contained in a data delivery, the element defines a specific availability status on this date.
								
In the attribute @State the following availability statuses can be used:
- Open
- Request
- Closed
- StopSale
- Blacklisted

The determination, which availability statuses in which context lead to displaying the offer, takes place in the product defintion due to a corresponding availability filter.

If the Stay element contains a number, it expresses how many Units respectively persons still are feasible concerning the Stay availability status. If the number indicates the number of persons is determined by the attribute Occupancy/Person/@MatchAvailability. 
The State attribute allows to define the general status concerning the stay.

The definition of the Stay element replaces the simultaneous definition of 
DefaultDayState/Open,
DefaultDayState/Closed,
DefaultDayState/Request,
DefaultDayState/StopSales,
DefaultDayState/Blacklisted.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
					<xs:choice minOccurs="0">
						<xs:element name="CheckIn" type="AvailabilityStateType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_422">Ist dieses Element in einer Lieferung enthalten, so definiert es, dass an diesem Termin die Anreise uneingeschränkt möglich. Enthält dieses Element eine Zahl, so drückt diese aus, dass die Anreise maximal für diese Anzahl von Units bzw. Personen möglich ist. Ob es bei der Zahl um die Anzahl der Personen geht, wird durch das Attribut Occupancy/Person/@MatchAvailability festgelegt.

Mit dem State-Attribut gibt man den generellen Status bzgl. der Anreise an.
Ist weder dieses Element noch das Element NoCheckIn angegeben, so gilt der im DefaultDayState festgelegte Default bzgl. CheckIn bzw. NoCheckIn.

Grundsätzlich gelten die Stati "Open" und "Request" als verfügbar. Mit dem AvailabilityState-Filter kann diese Interpretation aber weiter eingeschränkt werden.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_422">If this element is contained in a data delivery, it indicates that this is a possible arrival date. The element cannot contain a value.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="NoCheckIn" type="AvailabilityEmptyType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_423">Ist dieses Element in einer Lieferung enthalten, so definiert es, dass an diesem Termin die Anreise nicht möglich ist. 
Ist weder dieses Element noch das Element CheckIn angegeben, so gilt der im DefaultDayState festgelegte Default bzgl. CheckIn bzw. NoCheckIn.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_423">If this element is contained in a data delivery, it indicates that this is not a possible arrival date. 
								If neither this element nor the element CheckIn is indicated, the default regarding CheckIn repectively NoCheckIn as given in DefaultDayState applies.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
					<xs:choice minOccurs="0">
						<xs:element name="CheckOut" type="AvailabilityStateType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_424">Ist dieses Element in einer Lieferung enthalten, so definiert es, dass an diesem Termin die Abreise uneingeschränkt möglich ist. Enthält dieses Element eine Zahl, so drückt dies aus, dass die Abreise für maximal diese Anzahl von Units bzw. Personen möglich ist. Ob es bei der Zahl um die Anzahl der Personen geht, wird durch das Attribut Occupancy/Person/@MatchAvailability festgelegt.
Mit dem State-Attribut gibt man den generellen Status bzgl. der Anreise an.
Ist weder dieses Element noch das Element NoCheckOut angegeben, so gilt der im DefaultDayState festgelegte Default bzgl. CheckOut bzw. NoCheckOut.
Grundsätzlich gelten die Stati "Open" und "Request" als verfügbar. Mit dem AvailabilityState-Filter kann diese Interpretation aber weiter eingeschränkt werden.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_424">If this element is contained in a data delivery, it indicates that this is a possible departure date. If this element contains a number, it expresses that the departure is possible for the maximum number of units respectively personen. If the number refers to the amount of persons is defined by the attribute Occupancy/Person/@MatchAvailability.
The State-attribute serves to indicate the general state regarding the departure.
If neither this element not the element NoCheckOut is indicated, the default defined in DefaultDayState regarding the CheckOut repectively the NoCheckOut is valid.
In general the States "Open" and "Request" are considered as available.With the help of the AvailabilityState-Filter this interpretation however can be further restricted.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="NoCheckOut" type="AvailabilityEmptyType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_425">Ist dieses Element in einer Lieferung enthalten, so definiert es, dass an diesem Termin die Abreise nicht möglich ist. 
Ist weder dieses Element noch das Element CheckOut angegeben, so gilt der im DefaultDayState festgelegte Default bzgl. CheckOut bzw. NoCheckOut.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_425">If this element is contained in a data delivery, it indicates that this is not a possible departure date. If neither this element nor the element CheckOut is indicated, the default regarding CheckOut repectively NoCheckOut as given in DefaultDayState applies.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
				</xs:sequence>
				<xs:attribute name="Offset" type="xs:unsignedInt" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_426"> Das Attribut "Offset stellt eine Beziehung zum StartDate im Elternknoten her. Startdate + Offset ergeben das Datum des in DayState betrachteten Tages. </xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_426">The "Offset" attribute creates a reference to the StartDate in the parent node. StartDate + Offset give the date of the day described in DayState.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DefaultDayStateType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_427">Dieser Type definiert ganz analog zu DayState, welche Stati gesetzt werden sollen, wenn in diesem AvailabilityBlock ein kompletter
				DayState oder auch einzelne Stati nicht besetzt sind. Dadurch kann man sowohl nur negative als auch nur positive Availabilities angeben.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_427">In the same way as DayState does, this Type defines which statuses should be set if a whole DayState or individual statuses are not filled in in this AvailabilityBlock. Here you can have either negative Availabilities only or positive Availabilities only.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SimpleUpdateNodeType">
				<xs:sequence>
					<xs:choice>
						<xs:element name="Open" type="AvailabilityOpenType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_428">Ist dieses Element in einer Lieferung enthalten, so definiert es bzgl. des DayState einen Default, falls in DayState keines der Elemente Stay, Open, Closed, Request, StopSale, Blacklisted explizit angegeben ist. Bzgl. dieses Defaults definiert das Element, dass an diesem Termin mindestens ein Aufenthalt möglich ist. Enthält dieses Element eine Zahl, so drückt dies aus, wieviele Units bzw. Personen noch bzgl. des Aufenthaltes möglich sind. Ob es bei der Zahl um die Anzahl der Personen geht, wird durch das Attribut Occupancy/Person/@MatchAvailability festgelegt.

Die Festlegung, welche Verfügbarkeitsstati in welchem Kontext zu einer Anzeige des Angebotes führen, erfolgt in der Product-Definition durch einen entsprechenden Availability-Filter.

Eine Definition in diesem Element wird durch eine gleichzeitge Definition im Element DefaultDayState/Stay ersetzt.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_428">If this element is contained in a data delivery, it defines a default regarding the DayState for the case that none of the elements Stay, Open, Closed, Request, StopSale, Blacklisted is explicitly indicated in DayState. Regarding this default the element defines, that on this date at least one stay is possible. If this element contains a number, it expresses how many Units or Persons are possible regarding the stay. The attribute Occupancy/Person/@MatchAvailability determines if the number indicates the amount of persons.

The determination, which availability stauses in which context lead to displaying the offer, takes place by a corresponding availability filter in the product definition.
A definition in this element is replaced by a simultaneous definition in the element DefaultDayState/Stay.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Request" type="AvailabilityRequestType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_429">Ist dieses Element in einer Lieferung enthalten, so definiert es bzgl. des DayState einen Default, falls in DayState keines der Elemente Stay, Open, Closed, Request, StopSale, Blacklisted explizit angegeben ist. Bzgl. dieses Defaults definiert das Element, dass an diesem Termin mindestens ein Aufenthalt auf Nachfrage (Request) möglich ist. Enthält dieses Element eine Zahl, so drückt dies aus, wieviele Units bzw. Personen noch bzgl. des Aufenthaltes möglich sind. Ob es bei der Zahl um die Anzahl der Personen geht, wird durch das Attribut Occupancy/Person/@MatchAvailability festgelegt.

Die Festlegung welche Verfügbarkeitsstati in welchem Kontext zu einer Anzeige des Angebotes führen, erfolgt in der Product-Definition durch einen entsprechenden Availability-Filter.

Eine Definition in diesem Element wird durch eine gleichzeitge Definition im Element DefaultDayState/Stay ersetzt.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_429">If this element is contained in a data delivery, it defines a default regarding the DayState for the case that none of the elements Stay, Open, Closed, Request, StopSale, Blacklisted is explicitly indicated in DayState. Regarding this default the element defines, that on this date at least one stay on Request is possible. If this element contains a number, it expresses how many Units or Persons are still possible regarding the stay. The attribute Occupancy/Person/@MatchAvailability determines if the number indicates the amount of persons.

The determination, which availability stauses in which context lead to displaying the offer, takes place by a corresponding availability filter in the product definition.
A definition in this element is replaced by a simultaneous definition in the element DefaultDayState/Stay.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Closed" type="AvailabilityEmptyType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_430">Ist dieses Element in einer Lieferung enthalten, so definiert es bzgl. des DayState einen Default, falls in DayState keines der Elemente Stay, Open, Closed, Request, StopSale, Blacklisted explizit angegeben ist. Bzgl. dieses Defaults definiert das Element, dass an diesem Termin für alle Aufenthalte ein Closed gesetzt ist.

Die Festlegung welche Verfügbarkeitsstati in welchem Kontext zu einer Anzeige des Angebotes führen, erfolgt in der Product-Definition durch einen entsprechenden Availability-Filter.

Eine Definition in diesem Element wird durch eine gleichzeitge Definition im Element DefaultDayState/Stay ersetzt.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_430">If this element is contained in a data delivery, it defines a default regarding the DayState for the case that none of the elements Stay, Open, Closed, Request, StopSale, Blacklisted is explicitly indicated in DayState. Regarding this default the element defines, that on this date for all stays a Closed is set.
The determination, which availability stauses in which context lead to displaying the offer, takes place by a corresponding availability filter in the product definition.
A definition in this element is replaced by a simultaneous definition in the element DefaultDayState/Stay.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="StopSales" type="AvailabilityEmptyType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_431">Ist dieses Element in einer Lieferung enthalten, so definiert es bzgl. des DayState einen Default, falls in DayState keines der Elemente Stay, Open, Closed, Request, StopSale, Blacklisted explizit angegeben ist. Bzgl. dieses Defaults definiert das Element, dass an diesem Termin für alle Aufenthalte ein StopSale gesetzt ist.

Die Festlegung welche Verfügbarkeitsstati in welchem Kontext zu einer Anzeige des Angebotes führen, erfolgt in der Product-Definition durch einen entsprechenden Availability-Filter.

Eine Definition in diesem Element wird durch eine gleichzeitge Definition im Element DefaultDayState/Stay ersetzt.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_431">If this element is contained in a data delivery, it defines a default regarding the DayState for the case that none of the elements Stay, Open, Closed, Request, StopSale, Blacklisted is explicitly indicated in DayState. Regarding this default the element defines, that on this date for all stays a StopSale is set.
The determination, which availability stauses in which context lead to displaying the offer, takes place by a corresponding availability filter in the product definition.
A definition in this element is replaced by a simultaneous definition in the element DefaultDayState/Stay.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Blacklisted" type="AvailabilityEmptyType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_432">Ist dieses Element in einer Lieferung enthalten, so definiert es bzgl. des DayState einen Default, falls in DayState keines der Elemente Stay, Open, Closed, Request, StopSale, Blacklisted explizit angegeben ist. Bzgl. dieses Defaults definiert das Element, dass an diesem Termin alle Aufenthalte geblacklisted sind.

Die Festlegung welche Verfügbarkeitsstati in welchem Kontext zu einer Anzeige des Angebotes führen, erfolgt in der Product-Definition durch einen entsprechenden Availability-Filter.

Eine Definition in diesem Element wird durch eine gleichzeitge Definition im Element DefaultDayState/Stay ersetzt.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_432">If this element is contained in a data delivery, it defines a default regarding the DayState for the case that none of the elements Stay, Open, Closed, Request, StopSale, Blacklisted is explicitly indicated in DayState. Regarding this default the element defines, that on this date for all stays are blacklisted.
The determination, which availability stauses in which context lead to displaying the offer, takes place by a corresponding availability filter in the product definition.
A definition in this element is replaced by a simultaneous definition in the element DefaultDayState/Stay.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Stay" type="AvailabilityStateType" internal:otdsversion="2.0">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_8937">Ist dieses Element in einer Lieferung enthalten, so definiert es bzgl. des DayState einen Default, falls in DayState keines der Elemente Stay, Open, Closed, Request, StopSale, Blacklisted explizit angegeben ist. Bzgl. dieses Defaults definiert das Element, dass an diesem Termin mindestens ein Aufenthalt möglich ist. Enthält dieses Element eine Zahl, so drückt dies aus, wieviele Units bzw. Personen noch bzgl. des Aufenthaltes möglich sind. Ob es bei der Zahl um die Anzahl der Personen geht, wird durch das Attribut Occupancy/Person/@MatchAvailability festgelegt.
Mit dem State-Attribut gibt man den generellen Status bzgl. des Aufenthaltes an.

Die Festlegung welche Verfügbarkeitsstati in welchem Kontext zu einer Anzeige des Angebotes führen, erfolgt in der Product-Definition durch einen entsprechenden Availability-Filter.

Die Definition des Stay-Elementes ersetzt eine gleichzeitge Definition von DefaultDayState/Open, DefaultDayState/Closed, DefaultDayState/Request, DefaultDayState/StopSales, DefaultDayState/Blacklisted.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_8937">If this element is contained in a data delivery, it defines a default regarding the DayState for the case that none of the elements Stay, Open, Closed, Request, StopSale, Blacklisted is explicitly indicated in DayState. Regarding this default the element defines, that on this date at least one stay is possible. If this element contains a number, it expresses how many Units or Persons are still possible regarding the stay. The attribute Occupancy/Person/@MatchAvailability determines if the number indicates the amount of persons.
The attribute "State" indicates the general status regading the stay.
The determination, which availability stauses in which context lead to displaying the offer, takes place by a corresponding availability filter in the product definition.
A definition of the Stay element replaces a simultaneous definition of DefaultDayState/Open, DefaultDayState/Closed, DefaultDayState/Request, DefaultDayState/StopSales, DefaultDayState/Blacklisted.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
					<xs:choice minOccurs="0">
						<xs:element name="CheckIn" type="AvailabilityStateType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_433">Ist dieses Element in einer Lieferung enthalten, so definiert es bzgl. des DayState einen Default, falls in DayState das Element CheckIn bzw. NoCheckIn nicht explizit angegeben ist. Bzgl. dieses Defaults definiert das Element, dass an diesem Termin eine Anreise uneingeschränkt möglich ist. Enthält dieses Element eine Zahl, so drückt dies aus, dass die Anreise nur für maximal diese Anzahl von Units bzw. Personen möglich ist. Ob es bei der Zahl um die Anzahl der Personen geht, wird durch das Attribut Occupancy/Person/@MatchAvailability festgelegt.

Mit dem State-Attribut gibt man den generellen Status bzgl. der Anreise an.

Ist weder dieses Element noch das Element NoCheckIn angegeben, so gilt <CheckIn State="Open"/> als Default.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_433">If this element is contained in a data delivery, it defines a default regarding the DayState for the case that neither the element CheckIn nor NoCheckIn is explicitly indicated in DayState. Regarding this default the element defines, that on this date an arrival is possible without restrictions. If this element contains a number, it expresses that the arrival is possible only for this maximum number of Units or Persons. The attribute Occupancy/Person/@MatchAvailability determines if the number indicates the amount of persons.
The attribute "State" indicates the general status regading the arrival.
If neither this element nor the element NoCheckIn indicated, CheckIn State ="Open" is the default setting.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="NoCheckIn" type="AvailabilityEmptyType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_434">Ist dieses Element in einer Lieferung enthalten, so zeigt es an, dass man an diesem Termin nicht anreisen kann. Das Element kann keinen Wert enthalten.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_434">If this element is contained in a data delivery, it indicates that this is not a possible arrival date. The element cannot contain a value.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
					<xs:choice minOccurs="0">
						<xs:element name="CheckOut" type="AvailabilityStateType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_435">Ist dieses Element in einer Lieferung enthalten, so definiert es bzgl. des DayState einen Default, falls in DayState das Element CheckOut bzw. NoCheckOut nicht explizit angegeben ist. Bzgl. dieses Defaults definiert das Element, dass an diesem Termin eine Abreise uneingeschränkt möglich ist. Enthält dieses Element eine Zahl, so drückt dies aus, dass die Abreise nur für maximal diese Anzahl von Units bzw. Personen möglich sind. Ob es bei der Zahl um die Anzahl der Personen geht, wird durch das Attribut Occupancy/Person/@MatchAvailability festgelegt.
Mit dem State-Attribut gibt man den generellen Status bzgl. der Abreise an.
Ist weder dieses Element noch das Element NoCheckOut angegeben, so gilt <CheckOut State="Open">9</CheckOut>  als Default.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_435">If this element is contained in a data delivery, it defines a default regarding the DayState for the case that neither the element CheckOut nor NoCheckOut is explicitly indicated in DayState. Regarding this default the element defines, that on this date a departure is possible without restrictions. If this element contains a number, it expresses that the departure is possible only for this maximum number of Units or Persons. The attribute Occupancy/Person/@MatchAvailability determines if the number indicates the amount of persons.
The attribute "State" indicates the general status regading the departure.
If neither this element nor the element NoCheckOut indicated, <CheckOut State="Open">9</CheckOut> is the default setting.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="NoCheckOut" type="AvailabilityEmptyType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_436">Ist dieses Element in einer Lieferung enthalten, so zeigt es an, dass man an diesem Termin abreisen kann. Das Element kann keinen Wert enthalten.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_436">If this element is contained in a data delivery, it indicates that this is a possible departure date. The element cannot contain a value.I</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="AvailabilityOpenType">
		<xs:union>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:length value="0"/>
				</xs:restriction>
			</xs:simpleType>
			<xs:simpleType>
				<xs:restriction base="xs:unsignedInt"/>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="AvailabilityRequestType">
		<xs:union>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:length value="0"/>
				</xs:restriction>
			</xs:simpleType>
			<xs:simpleType>
				<xs:restriction base="xs:unsignedInt"/>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="ValidStateValueType">
		<xs:restriction base="xs:string">
			<xs:length value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="AvailabilityEmptyType"/>
	<xs:complexType name="AvailabilityStateType">
		<xs:simpleContent>
			<xs:extension base="AvailabilityRequestType">
				<xs:attribute name="State" type="AvailabilityStateEnum" default="Open" internal:otdsversion="2.0">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_8938">Dieses Attribut definiert, welchen Verfügbarkeitsstatus ein Termin bzgl. der Anreise, Abreise oder des Aufenthaltes hat. 

Folgende Verfügbarkeitsstati sind möglich: 
- Open
- Request
- Closed
- StopSale
- Blacklisted

Fehlt das Attribut gilt der Default = "Open"</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="ValidStateType">
		<xs:simpleContent>
			<xs:extension base="ValidStateValueType">
				<xs:attribute name="State" type="AvailabilityStateConditionEnum" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_1439">Dieses Attribut definiert, welcher Verfügbarkeitsstatus als valide gilt.
Mögliche Werte sind:
- Open
- Request</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_1439">This attribute defines, which availability state is considered valid.
Possible values are:
- Open
- Request</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!-- Begin of ConditionalTagCondition type-->
	<xs:group name="ConditionOfConditionalTagGroup">
		<xs:choice>
			<xs:group ref="AtomicBaseConditionGroup"/>
			<xs:group ref="AtomicPersonImpactConditionGroup"/>
			<xs:group ref="AtomicDayImpactConditionGroup"/>
			<xs:element name="And">
				<xs:complexType>
					<xs:group ref="ConditionOfConditionalTagGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Or">
				<xs:complexType>
					<xs:group ref="ConditionOfConditionalTagGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Not">
				<xs:complexType>
					<xs:group ref="ConditionOfConditionalTagGroup"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Imply">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="If">
							<xs:complexType>
								<xs:group ref="ConditionOfConditionalTagGroup"/>
							</xs:complexType>
						</xs:element>
						<xs:element name="Then">
							<xs:complexType>
								<xs:group ref="ConditionOfConditionalTagGroup"/>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:group name="CountMinMaxConditionGroup">
		<xs:choice>
			<xs:sequence maxOccurs="2">
				<xs:choice>
					<xs:element name="Min" type="xs:int">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_437">In diesem Element kann eine minimale Anzahl definiert werden</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_437">In this element a minimum number can be defined.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Max" type="xs:int">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_438">In diesem Element kann eine maximale Anzahl definiert werden</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_438">In this element a maximum number can be defined.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:sequence>
			<xs:element name="Counts" type="IntegerListType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_439">Es kann eine Liste von mehreren gültigen Anzahlen angegeben werden. Die einzelnen Zahlen müssen durch Space voneinander separiert sein.
Counts="1 4 -3 -1" bestimmt die älteste Person, die viertälteste Person, die drittjüngste Person sowie die jüngste Person.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_439">A list of indexes of participants can be specified. The individual indices must be separated from each other by a space.

Indices="1 4 -3 -1" defines the oldest person, the 4th oldest person, the 3rd youngest person and the youngest person.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- Begin of new Condition types-->
	<xs:complexType name="DayCountConditionType">
		<xs:sequence>
			<xs:group ref="CountMinMaxConditionGroup"/>
			<xs:element name="DayFilter" type="DayFilterConditionType" minOccurs="0" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_527">Dieses Element filtert die Personen der Reise, für welche der PersonIndex gelten soll. Standardmäßig werden alle Personen der Reise betrachtet, die nach Alter absteigend sortiert vorliegen. Soll sich der PersonIndex auf Personen beziehen, die bestimmte Bedingungen erfüllen, kann durch dieses Element der Personenkreis eingeschränkt werden. Anwendungsfall ist beispielsweise, nur Vollzahler oder Kinder zu adressieren. Die Ergebnismenge dieses Filters wird nach Alter absteigend sortiert; auf diese Menge beziehen sich die Indexangaben in den Elementen "Min", "Max" und "Indices".</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_527">This element filters the participants in the tour to which the PersonIndex should apply. By default, all participants in the tour are sorted in descending order according to age.
Where the PersonIndex refers to persons that meet certain conditions, they can be restricted by this element. An application of this would be, for example, to address only full-paying adults or children.
The result of this filter is to sort participants in descending order by age and relate this information to the index information in the elements, "Min", "Max" and "Indices".</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="ConditionAttributeGroup"/>
		<xs:attributeGroup ref="SourceAttributeGroup"/>
	</xs:complexType>
	<xs:complexType name="PersonCountConditionType">
		<xs:sequence>
			<xs:group ref="CountMinMaxConditionGroup"/>
			<xs:sequence>
				<xs:element name="PersonFilter" type="PersonFilterConditionType" minOccurs="0">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_526">Dieses Element filtert die Personen der Reise, für welche der PersonIndex gelten soll. Standardmäßig werden alle Personen der Reise betrachtet, die nach Alter absteigend sortiert vorliegen. Soll sich der PersonIndex auf Personen beziehen, die bestimmte Bedingungen erfüllen, kann durch dieses Element der 						Personenkreis eingeschränkt werden. Anwendungsfall ist beispielsweise, nur Vollzahler oder Kinder zu adressieren. Die Ergebnismenge dieses Filters wird nach Alter absteigend sortiert; auf diese Menge beziehen sich die Indexangaben in den Elementen "Min", "Max" und "Indices".</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_526">This element filters the participants in the tour to which the PersonIndex should apply. By default, all participants in the tour are sorted in descending order according to age.
Where the PersonIndex refers to persons that meet certain conditions, they can be restricted by this element. An application of this would be, for example, to address only full-paying adults or children.
The result of this filter is to sort participants in descending order by age and relate this information to the index information in the elements, "Min", "Max" and "Indices".</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
		</xs:sequence>
		<xs:attributeGroup ref="ConditionAttributeGroup"/>
		<xs:attributeGroup ref="SourceAttributeGroup"/>
	</xs:complexType>
	<xs:complexType name="PersonIndexConditionType">
		<xs:sequence>
			<xs:choice>
				<xs:sequence minOccurs="0">
					<xs:element name="Until" type="NonZeroIntegerType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_528">Definition aller Personen bis zu einer bestimmten Person. Until=x definiert die X ältesten Personen. Until=-x definiert alle Personen dem Alter nach absteigend bis zur X-jüngsten Person. NICHT zu verwechseln mit den X-jüngsten Personen, die über From=-x definiert werden. </xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_528">Definition of all persons up to a certain person.

Until=x defines the X oldest persons.

Until=-x defines all persons in ascending order by age up to the X-youngest person. NOT to be confused with the X-youngest persons, defined by From=-x.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="From" type="NonZeroIntegerType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_529">Definition aller Personen ab einer bestimmten Person. Standardverwendung ist hier From=-x. From=-x definiert die X jüngsten Personen. From=x definiert alle Personen dem Alter nach absteigend ab der X-ältesten Person (inklusive der Xten Person).</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_529">Definition of all persons from a certain person. 
							The standard usage for this is
From=-x. From=-x defines the X youngest persons.

From=x defines all persons in ascending order by age from the X-oldest person (including the Xth person).</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:element name="Indices" type="NonZeroIntegerListType">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_530">Es kann eine Liste an Indizes von Reiseteilnehmern angegeben werden. Die einzelnen Indizes müssen durch Space voneinander separiert sein. Indices="1 4 -3 -1" definiert die älteste Person, die 4.-älteste Person, die 3.-jüngste Person und die jüngste Person</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_530">A list of indexes of participants can be specified. The individual indices must be separated from each other by a space.

Indices="1 4 -3 -1" defines the oldest person, the 4th oldest person, the 3rd youngest person and the youngest person.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element name="PersonFilter" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_440">Dieses Element filtert die Personen der Reise, für welche der PersonIndex gelten soll. Standardmäßig werden alle Personen der Reise betrachtet, die nach Alter absteigend sortiert vorliegen. Soll sich der PersonIndex auf Personen beziehen, die bestimmte Bedingungen erfüllen, kann durch dieses Element der Personenkreis eingeschränkt werden. Anwendungsfall ist beispielsweise, nur Vollzahler oder Kinder zu adressieren. Die Ergebnismenge dieses Filters wird nach Alter absteigend sortiert; auf diese Menge beziehen sich die Indexangaben in den Elementen "Min", "Max" und "Indices".</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_440">This element filters the participants in the tour to which the PersonIndex should apply. By default, all participants in the tour are sorted in descending order according to age.
Where the PersonIndex refers to persons that meet certain conditions, they can be restricted by this element. An application of this would be, for example, to address only full-paying adults or children.
The result of this filter is to sort participants in descending order by age and relate this information to the index information in the elements, "Min", "Max" and "Indices".</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice maxOccurs="unbounded">
						<xs:element name="PersonAge" type="AgeConditionType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_441">Definiert eine Bedingung an das Alter der Reiseteilnehmer. Es kann ein minimales und maximales Alter angegeben werden oder alternativ ein minimales und maximales Geburtsdatum.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_441">Defines a restriction on the age of the traveller. You can specify a minimum and maximum age, or alternatively a minimum or maximum birth date.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ConditionalTags" type="ConditionalTagConditionType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_507">Schränkt den Personenkreis ein, in dem ein ConditionalTag überprüft wird. Dadurch kann nach bestimmten Personentypen gefiltert werden, wie beispielsweise Vollzahler, welche durch ConditionalTags markiert sind. Es ist nur sinnvoll, sich an dieser Stelle auf ConditionalTags zu beziehen, die keinen DayImpact-Anteil haben.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_507">By using a ConditionalTag, the number of people can be limited. This can be filtered according to specific types of people, such as full-paying guests, which are defined by ConditionalTags.
At this point it makes sense to refer only to ConditionalTags which have no DayImpact share.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="ConditionAttributeGroup"/>
		<xs:attributeGroup ref="SourceAttributeGroup"/>
	</xs:complexType>
	<xs:complexType name="DayIndexConditionType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_443">Dieses Element definiert eine Gültigkeit für 
				bestimmte Tage eines Reiseverlaufs. Alle betrachteten Tage werden nach Reiseverlauf
				sortiert und bekommen dann jeweils einen von 1 aufsteigenden Index. Die Bedingung
				selbst gibt eine Liste von Indizes bzw. einen MinIndex oder einen MaxIndex an, über
				den die Tage definiert sind, für die diese Bedingung gültig ist. Über die Attribute
				"Count" und "Extend" können weitere Einstellungen für sich wiederholende Muster von
				Tagen definiert werden. Negative Indizes adressieren die letzten Tage der Reise. Um
				bestimmte Zeiträume zu adressieren, ergeben sich vier typische Fälle: 1. Die ersten
				x Tage: Until=x 2. Die letzten x Tage: From=-x 3. Alle Tage nach dem Xten Tag:
				From=X 4. Alle Tage vor dem x-letzten Tag: Until=-x. Außerdem sind dazu noch
				Kombinationen von "From" und "Until" möglich und die Angabe einer Liste von Indizes. </xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_443">This element defines a validity for certain days
				of the itinerary. All days are sorted according to the itinerary and placed in an
				index which ascends in increments of 1. The condition itself specifies a list of
				indexes, a MinIndex or a MaxIndex, in which the days for which this condition is
				valid are defined. With the "Count" and "extend" attributes further settings can be
				defined for repeating patterns of days. Negative indices address the last days of
				the tour. To address certain periods, there are four typical cases: 1. The first x
				days: Until=x 2. The last x days: From=-x 3. all days after the Xth day: From=X 4.
				all days befor the x-last day: Until=-x. In addition combinations of "From" and
				"Until" are possible as well as specifying a list of indices.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice>
				<xs:sequence>
					<xs:element name="Until" type="NonZeroIntegerType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_444">Definiert innerhalb der zeitlich aufsteigenden
							Tage alle Indizes, die sich zeitlich vor dem in "Until" angegebeben
							Index befinden sowie den angegebenen Index selbst. Bei Angabe eines
							negativen Index wird der Tag von hinten gezählt. Until=1 ist dabei der
							CheckIn-Tag. Until=-1 ist der CheckOut-Tag und alle davor liegenden
							Tage. </xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_444">Days within the defined time period and all
							indices appearing before "Until" will be found in the index as well as
							the specified index itself. When using a negative index the day is
							counted in reverse. Until=1 is the check-in day Until=-1 is the
							check-out day and all other days prior to it.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="From" type="NonZeroIntegerType" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_445">Definiert innerhalb der zeitlich aufsteigenden
							Tage alle Indizes, die sich zeitlich nach dem in "From" angegebeben
							Index befinden sowie den angegebenen Index selbst. Bei Angabe eines
							negativen Index wird der Index vom letzten Tag aus gezählt. From=1 ist
							dabei der CheckIn-Tag und alle folgenden. From=-1 ist der
							CheckOut-Tag.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_445">Within the days in ascending chronological
							order, this defines all indices appearing after the index found in
							"From" as well as the specified index itself. If a negative index is
							entered, the index is counted backwards from the last day. From=1 is the
							check-in day and all following days. From=-1 is the check-out
							day.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:element name="Indices" type="NonZeroIntegerListType">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_446">Es kann eine Liste an Indizes von Tagen der
						Reise angegeben werden. Die einzelnen Indizes müssen durch Space voneinander
						separiert sein. Bei Angabe eines negativen Index wird der Index vom letzten
						Tag aus gezählt. Indices="1 3 -3 -1" definiert den CheckIn Tag und den Tag
						zwei Tage später sowie den CheckOut Tag und den Tag zwei Tage
						vorher.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_446">A list of indices for the days of the journey can be specified. The individual indices must be separated from each other by a space.
If a negative index is entered, the index is counted backwards from the last day.
Indices="1 3 -3 -1" defines the check-in day and 2 following days as well as the check-out day and and the 2 days prior to it.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element name="DayFilter" type="DayFilterType" minOccurs="0" internal:otdsversion="1.9.1"/>
		</xs:sequence>
		<xs:attribute name="Repeat" type="xs:positiveInteger">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_447">Dieses Attribut gibt an, dass es sich um ein sich wiederholendes Muster von Indizes handelt. Der angegebene Value definiert
					die Weite des Wiederholungszyklus.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_447">This attribute indicates that there is a repeating pattern of indices. The specified value defines the size of the repeat cycle.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="SourceAttributeGroup"/>
		<xs:attribute name="IntervalType" type="IntervalTypeEnum" default="Stay">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_448">Dieses Attribut definiert, welche Tage bzgl. des DayIndex betrachtet werden. 
Mögliche Werte sind: 
- Stay 
Alle Stay-Tage werden betrachtet. 
- CheckInOut 
Alle Tage zwischen CheckIn und einschließlich CheckOut werden betrachtet. 
Default ist "Stay".</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_448">This attribute defines which days are referred to by the DayIndex.
Possible values are:
- Stay
All days of the stay are to be considered
- CheckInOut
All the days from check-in up to and including the day of check-out are to be considered.
The default is "Stay".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="DayPriceIndexType">
		<xs:annotation>
			<xs:documentation xml:lang="de" xml:id="de_449">Eine Condition, die für die Tage gültig ist, die zu den X günstigsten / teuersten Tagen zählen.</xs:documentation>
			<xs:documentation xml:lang="en" xml:id="en_449">A condition that is valid for the days that are among the x cheapest/most expensive days.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Until" type="NonZeroIntegerType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_450">Anzahl der Tage bis zu einem Xten Tag. Die Sortierung der Tage erfolgt nach aufsteigenden Preisen. Positive Werte (also Until=x) definieren die X günstigsten Tage inklusive des Xten Tages. Negative Werte definieren ALLE Tage BIS zum X teuersten Tag. 
NICHT zu verwechseln mit der Definition der X teuersten Tage, welche über das Element "From=-x" dargestellt werden.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_450">Number of days up until the Xth day. The days are sorted by price in ascending order. Positive values (Until=x) define the X cheapest days up to and including the Xth day. Negative values define ALL days up to and including the X most expensive day. NOT to be confused with the definition of the X most expensive days, which are displayed via the element "From=-x".</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="From" type="NonZeroIntegerType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_451">Anzahl der Tage ab einem Xten Tag. Die Sortierung der Tage erfolgt nach aufsteigenden Preisen. Die Standardverwendung von "From" wird mit negativen Werten sein. From=-x definiert alle Tage ab dem X teuersten Tag inklusive des Xten Tages. Was so viel heißt wie die X teuersten Tage. Die Verwendung eines positive Wertes im Zusammenhang mit "From"(also From=x) ist eher selten und definiert alle Tage ab dem X günstigsten Tag.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_451">Number of days from the Xth day. The days are sorted by price in ascending order. The
standard usage of "From" is with negative values. From=-x defines all days from the X most expensive day including the Xth day. Which means the same thing as the X most expensive days.
It is rare to use a positive value in relation to "From", i.e. "From=x", and it will define all days from the Xth cheapest day.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:sequence>
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_1440">Hier werden die PriceItems definiert bzw. ausgeschlossen, welche zur Beurteilung des Preisindizes herangezogen werden. Jedes Element "ConsideredPriceTags",  "NotConsideredPriceTags", "ConsideredPriceItemClasses" bzw. "NotConsideredPriceItemClasses" wird in seinem Component-Kontext ausgewertet. Die Ergebnismenge der gültigen PriceItems ist die Vereinigungsmenge der Einzelauswertungen. Dabei werden keine PriceItems vervielfältigt.
Ist keine PriceItemFilterGroup angegeben, so findet keine Einschränkung der PriceItems statt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_1440">Here the PriceItems are defined respectively excluded, which are used for evaluating the PriceIndex. Each element "ConsideredPriceTags",  "NotConsideredPriceTags", "ConsideredPriceItemClasses", and "NotConsideredPriceItemClasses" is evaluated within its Component context. The result set of the valid PriceItems is the united set of the single evaluations. In this process no PriceItems are duplicated. If no PriceItemFilterGroup is indicated, there will be no restriction of the PriceItems.</xs:documentation>
				</xs:annotation>
				<xs:choice maxOccurs="unbounded">
					<xs:element name="ConsideredPriceTags">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_9007">Diese Elemente definieren, dass nur PriceItems berücksichtigt werden, die eines der aufgeführten PriceTags beinhalten.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_9007">These elements define, that only those PriceItems will be considered, that include one of the listed PriceTags.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="ConsideredPriceTagsReferenceType">
									<xs:attributeGroup ref="ComponentAttributeGroup"/>
								</xs:extension>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
					<xs:element name="NotConsideredPriceTags">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_9008">>Diese Elemente definieren, dass nur PriceItems berücksichtigt werden, die keines der aufgeführten PriceTags beinhalten.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_9008">>These elements define, that only those PriceItems will be considered, that include none of the listed PriceTags.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="ConsideredPriceTagsReferenceType">
									<xs:attributeGroup ref="ComponentAttributeGroup"/>
								</xs:extension>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
					<xs:group ref="DayPriceIndexConsideredPriceItemsGroup">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_9006">Hier werden die PriceItems definiert bzw. ausgeschlossen, welche zur Beurteilung des Preisindizes herangezogen werden.  Jedes Element "ConsideredPriceItemClasses" bzw. "NotConsideredPriceItemClasses" wird in seinem Component-Kontext ausgewertet. Die Ergebnismenge der gültigen PriceItems ist die Vereinigungsmenge der Einzelauswertungen. Dabei werden keine PriceItems vervielfältigt.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_9006">This is used to define or exclude the PriceItems that are used to evaluate the PriceIndices. Each element "ConsideredPriceItemClasses" respectively "NotConsideredPriceItemClasses" is evaluated in its component context. The result set of the valid PriceItems is the set union of the single evaluations. No PriceItems will be duplicated.</xs:documentation>
						</xs:annotation>
					</xs:group>
				</xs:choice>
			</xs:sequence>
			<xs:element name="DayFilter" type="DayFilterType" minOccurs="0" internal:otdsversion="1.9.1">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5708">Der DayFilter schränkt die betrachteten Tage auf bestimmte Tage ein. Die eingeschränkten Tage müssen alle Bedingungen hinsichtlich der angegebenen Date, Weekdays und ConditionalTags erfüllen.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5708">The DayFilter restricts the days that are considered to specific days. The restricted days have to fulfill all conditions regarding the indicated Date, Weekdays and ConditionalTags</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="SourceAttributeGroup"/>
		<xs:attribute name="IntervalType" type="IntervalTypeEnum" default="Stay">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_453">Dieses Attribut definiert, welche Tage bzgl. der Preishöhe betrachtet werden. 
Mögliche Werte sind: 
- Stay: Alle Stay-Tage werden betrachtet. 
- CheckInOut: Alle Tage zwischen CheckIn und einschließlich CheckOut werden betrachtet. Default ist "Stay".</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_453">This attribute defines which days should be included when setting the price.
Possible values are:
- Stay
All days of the stay are to be considered
- CheckInOut
All the days from check-in up to and including the day of check-out are to be considered.

The default is "Stay".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="AvailabilityConditionType">
		<xs:sequence>
			<xs:element name="ValidState" type="ValidStateType" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_1142">Mit diesem Element kann mit dem Attribut @State ein spezifischer AvailabilityStatus definiert werden, der als valide gilt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_1142">This element via the attribute @State allows to define a specific AvailabilityState that is considered valid.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="Component" type="ComponentAttributeType" use="optional" default="ThisComponent">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_1426">Dieses Attribut gibt den Type einer Komponente
					an. Folgende Typen stehen zur Auswahl: -
					Accommodation, - Flight, - Addon, - ThisComponent.
					Mit der Source kann man die Addressierung noch feiner auflösen.
					Wird gleichzeitig das Attribut 'Component' und das Attribut 'Source' angegeben, so wird nur die Source ausgewertet. Werden beide Attribute nicht angegeben, wird für das Attribut 'Component' der Wert 'ThisComponent' angenommen.
					</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_1426">This attribute specifies the type of a
					component. The following types are available: - Accommodation,
					- Flight, - Add-on, - ThisComponent.
					With the help of Source the addressing can be refined further. 
					If the attribute 'Component' and the attribute 'Source' are indicated at the same time, only Source is being evaluated. If both attributes are not indicated, the value 'ThisComponent' is assumed for the attribute 'Component'.
					</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- Begin of Definition of condition groups-->
	<xs:group name="AtomicBaseConditionGroup">
		<xs:choice>
			<xs:element name="Date" type="DateConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_456">Dieses Element definiert die Bedingung, ob bestimmte Termine in der gerade betrachteten Reise enthalten sind. Es kann ein Datumsintervall angegeben werden oder eine Liste von Einzelterminen. Die Bedingung gilt als erfüllt, wenn ein Termin entsprechend der Bedingungen enthalten ist. Über das Attribut "DayType" kann zusätzlich bestimmt werden, dass nur bestimmte Tage der Reise betrachtet werden sollen (z.B. nur der Anreisetag oder nur Aufenthaltstage). Über das Attribut "Source" wird die Quelle der betrachteten Reisetermine bestimmt (z.B. Termine im Hotel oder während des Fluges). Diese Bedingung überprüft ausdrücklich nicht, ob bestimmte Tage einer Reise eine Terminbedingung erfüllen und deshalb Preise explizit für diese Tage gelten. Dies wird nur durch die DayImpact Bedingung erfüllt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_456">This element defines the condition, as to whether certain dates are included in the trip currently being dealt with. You can either enter a range of dates or a list of individual dates. The condition is considered to be met if the date is one specified in the condition.
The "DayType" attribute can also be used to define that only certain days of the trip should be considered (e.g. only the arrival day or only the days of the stay).
The "Source" attribute can be used to define the source of the travel dates being viewed (e.g. dates in the hotel or during the flight).

This condition explicitly does not check whether or not certain days of a trip fulfil a date condition, and therefore whether the prices are valid expressly for these days. This is only fulfilled by the DayImpact condition.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:group ref="BookingDateConditionGroup">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_457">Diese Gruppe fasst Bedingungen bzgl. des Buchungsdatums bzw. Anfragedatums zusammen.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_457">This group brings together all conditions regarding the booking date or request date.</xs:documentation>
				</xs:annotation>
			</xs:group>
			<xs:element name="Duration" type="DurationConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_458">Dieses Element definiert die Bedingung, ob die gerade betrachtete Reisedauer in einer Liste von Dauern enthalten ist. Dabei können erlaubte Reisedauern explizit angegeben werden oder Einschränkungen für gültigen Reisedauern angegeben werden (minimale bzw. maximale gültige Reisedauer). Ebenso ist es möglich, erlaubte Reisedauern über Schrittweiten anzugeben, z.B. das Vielfache von 7 Tagen. Über das Attribut "Source" kann die betrachtete Dauer näher bestimmt werden. Bei den Dauern ist die nähere Bestimmung der betrachteten Dauer dann entscheidend, wenn es um Pauschalangebote bei Fernreisen geht. Dann kann die Dauer der Unterkunft von der Dauer der Reise abweichen, wenn Übernachtflüge benutzt werden. Sonderfälle, bei denen die Dauer ggf. nicht vom CheckIn bis zum CheckOut einer Komponente gehen, können über eine explizite Angabe des Start- und Endpunktes in den Elementen DurationStart und DurationEnd angegeben werden. 
Es sollte dabei berücksichtigt werden, dass die Termine der jeweiligen Komponenten immer bezogen auf die Lokalzeit der jeweiligen Komponente sind.

Wichtig: Die Sonderlocke, dass mit der Source="ReturnFlight" die Dauer vom CheckIn des Hinfluges bis zum CheckIn des Rückfluges referenziert wird, ist seit der Version 2.0 nicht mehr gültig. Die Source="ReturnFlight" wird ab Version 2.0 nach den normalen OTDS Regeln interpretiert.

Das Attribut "DurationUnit" definiert, in welcher Einheit die Dauer angegeben wird. Default ist "Nights"</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_458">This element defines the condition as to whether a list of duration contains the travel duration currently being viewed. Specific allowed durations can be entered or restrictions for valid durations (minimum or maximum valid duration). It is also possible to enter durations in increments, e.g. in multiples of 7 days.
The "Source" attribute allows the viewed duration to be more precisely defined.
For durations, the more precise definition of the current duration is crucial when dealing with package deals for long-haul journeys. The duration of the accommodation may then differ from the duration of the journey if overnight flights are taken. Special cases in which the duration does not last from CheckIn until the CheckOut of a component, may be expressed by explicitly indicating the beginning and the end in the elements DurationStart and DurationEnd. However it should be considered, that the dates of the components always refer to the local time of the corresponding component.

NOTE: The exception which had the duration between CheckIn of the outgoing flight referenced to the CheckIn of the return flight via Source="ReturnFlight", with Version 2.0 is no longer valid. I

The attribute "DurationUnit" defines, in which entity the duration is described. The default is "Nights".</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Weekdays" type="WeekdayConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_459">Dieses Element definiert die Bedingung, ob ein bestimmter Wochentag in der gerade betrachteten Reise enthalten ist. Die Bedingung gilt als erfüllt, wenn einer der angegebenen Wochentage in der betrachteten Reise enthalten ist. Dabei kann über das Attribut "DayType"
zusätzlich bestimmt werden, dass nur bestimmte Tage der Reise betrachtet werden sollen (z.B. nur der Anreisetag oder nur Aufenthaltstage). Bitte beachten: Im Gegensatz zu den anderen Conditions ist an dieser Stelle der Defaultwert="CheckIn" gesetzt. Wird das Attribut "DayType" nicht angegeben, so wird an dieser Stelle der Wert "CheckIn" benutzt. Das Element Weekdays kann eine durch Space getrennte Liste von Wochentagen enthalten. 
Mögliche Werte sind "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", analog zu den englisch benamten Wochentagen. 
Die Bedingung ist erfüllt, wenn einer der angegebenen Tage die Bedingung erfüllt. Es handelt sich also um eine implizite "OR-Verknüpfung". Über das Attribut "Source" wird die Quelle der betrachteten Reisetage bestimmt (z.B. Termine im Hotel oder während des Fluges). Diese Bedingung überprüft ausdrücklich nicht, ob bestimmte Tage einer Reise eine Wochentagsbedingung erfüllen und deshalb ggf. Preise explizit für diese Tage gelten. Dies wird nur durch die entsprechende DayImpact Bedingung erfüllt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_459">This element defines the condition as to whether the tour currently being viewed contains a certain weekday. The condition is considered to be fulfilled if the tour currently being viewed contains the weekday entered.
The "DayType" attribute can also be used to determine that only certain days of the trip should be considered (e.g. only the arrival day or only the days of the stay).

Please note: In contrast to other conditions, here the default value is set to ="CheckIn". If nothing is entered as the "DayType" attribute, the value "CheckIn" will be used here.

The Weekdays element can contain a list of weekdays separated by a space. Possible values are "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", and "Sun". The condition is fulfilled if one of the days entered fulfils the condition. It therefore concerns an implicit "OR connective".
The "Source" attribute is used to determine the source of the travel days currently being viewed (e.g. dates in the hotel or during the flight).

This condition explicitly does not check whether or not certain days of a trip fulfil a weekday condition, and therefore whether prices explicitly apply for these days. This is checked by the corresponding DayImpact condition.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PersonGroup" type="OccupancyConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_460">Dieses Element definiert die Bedingung, ob die Teilnehmer der Reise als Gruppe bestimmte Bedingungen bzgl. Alter und Anzahl erfüllen. Es werden dem Alter nach absteigend Eigenschaften je Person festgelegt. Alternativ können Personen mit gleichen Eigenschaften zusammengefasst werden. Weiterhin können Personen als optional angegeben werden. 

Diese Bedingung überprüft ausdrücklich nicht, ob bestimmte Personen Bedingungen erfüllen und deshalb ggf. Preise explizit für diese Personen gelten. Dies wird nur durch die entsprechende PersonImpact Bedingung erfüllt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_460">This element defines the condition of whether the participants of the holiday, as a group, fulfil certain conditions with regard to age and number. The characteristics of each person are detailed, in descending order by age. Alternatively, persons with the same characteristics can be summarised. Persons can also be listed as 'optional'.

This condition expressly does not examine whether specific persons fulfil conditions and therefore whether or not prices apply specifically for these persons. This is only fulfilled through the relevant PersonImpact condition.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ConditionalTags" type="ConditionalTagConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_461">Dieses Element definiert die Bedingung, ob an einem bestimmten Knoten des betrachteten Angebotes das Kind-Element "ConditionalTag" mit einem bestimmten Tag-Value enthalten ist. Zusätzlich müssen noch die Bedingungen des entsprechenden ConditionalTags erfüllt sein. Das Element ConditionalTags kann eine durch Space getrennte Liste von Tags enthalten. Die Bedingung ist erfüllt, wenn einer der Tags mit dem Wert des Zielknotens übereinstimmt (es handelt sich also um eine implizite "OR-Verknüpfung"). Der adressierte Knoten wird dabei durch Auswertung des Inhaltes der Attribute "Source" bestimmt. 
Elternknoten sind diesbzgl. auch logische übergeordnete Knoten, die sich aus der Auswertung der Product- und CombinationRules ergeben. Durch Angabe der Attribute "Offset" und "Length" wird der Vergleich des Wertes des ConditionalTag-Elementes auf bestimmte Zeichen begrenzt. Zusätzlich kann auch noch das Attribut "Class" besetzt werden und muss in dem entsprechenden ConditionalTag-Element dann auch übereinstimmen, damit die Gesamtbedingung erfüllt ist. Damit die Bedingung erfüllt ist, reicht es, dass ein ConditionalTag am Zielknoten die Bedingung erfüllt. Falls jedoch die  Adressierung des Zielknotens nicht eindeutig ist, so muss jeder Zielknoten die Tag-Bedingung wenigstens einmal erfüllen, damit die Gesamtbedingung erfüllt ist. (Siehe auch Thematische Dokumentation Auswertung der ConditionalTags)</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_461">This element defines the condition of whether, at a specific node of the observed offer, the child element "ConditionalTag" has a specific TagValue. In addition, the conditions of the relevant ConditionalTag must be fulfilled. The element ConditionalTags may include a list of tags separated by a space. The condition is fulfilled if one of the tags matches the value of the target node (it can therefore be described as an implicit "OR-connective"). In this situation, the addressed node is defined through an evaluation of the contents of the attribute "Source".
Parent nodes are in this sense also logical superordinate nodes which result from the evaluation of the ProductRules and CombinationRules. Through the provision of the attributes "Offset" and "Length", the comparison of the value of the ConditionalTag element is limited to certain characters. In addition, the attribute "Class" may also be occupied and must then also match in the corresponding ConditionalTag element, in order that the overall condition is fulfilled. In order for the condition to be fulfilled, it suffices for a ConditionalTag at the target node to fulfil the condition. If, however, the addressing of the destination node is not unambiguous, every destination node must fulfil the tag condition at least once, in order that the overall condition is fulfilled.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:group name="AtomicComponentConditionGroup">
		<xs:choice>
			<xs:element name="Keys" type="KeyConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_462">Dieses Element definiert die Bedingung, ob an einem bestimmten Elternknoten des betrachteten Angebotes das Attribut "Keys" mit einem bestimmten Wert enthalten ist. Das Element Keys kann eine durch Space getrennte Liste von Keys enthalten. Die Bedingung ist erfüllt, wenn einer der Keys mit dem Wert des Zielknotens übereinstimmt (es handelt sich also um eine implizite "OR-Verknüpfung"). 
Der adressierte Knoten wird dabei durch Auswertung des Inhaltes der Attribute "Source" und "Location" bestimmt. Ist der Zielknoten nicht eindeutig auf einer Ebene, so müssen alle Zielknoten die Bedingung erfüllen, damit die Gesamtbedingung erfüllt ist. Elternknoten sind diesbzgl. auch logische übergeordnete Knoten, die sich aus der Auswertung der Product- und CombinationRules ergeben.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_462">This element defines the condition of whether, at a specific parent node of the observed offer, the attribute "Key" has a specific value. The element Keys may include a list of keys separated by a space. The condition is fulfilled if one of the Keys matches the value of the destination node (it can therefore be described as an implicit "OR-connective").
In this situation, the addressed node is defined through an evaluation of the contents of the attribute "Source" and "Location". If the destination node is not unambiguously on one level, all destination nodes must fulfil the condition, in order that the overall condition is fulfilled.
Parent nodes are in this sense also logical superordinate nodes which result from the evaluation of the ProductRules and CombinationRules.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Tags" type="TagConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_463">Dieses Element definiert die Bedingung, ob an einem bestimmten Elternknoten des betrachteten Angebotes das Kind-Element "Tag" mit einem bestimmten Wert enthalten ist. Das Element Tag kann eine durch Space getrennte Liste von Tags enthalten. Die Bedingung ist erfüllt, wenn eines der Tags mit dem Wert des Zielknotens übereinstimmt (es handelt sich also um eine implizite "OR-Verknüpfung"). Der adressierte Knoten wird dabei durch Auswertung des Inhaltes der Attribute "Source" und "Location" bestimmt. 
Elternknoten sind diesbzgl. auch logische übergeordnete Knoten, die sich aus der Auswertung der Product- und CombinationRules ergeben. Durch Angabe der Attribute "Offset" und "Length" wird der Vergleich des Wertes des Tag-Elementes auf bestimmte Zeichen begrenzt. Zusätzlich kann auch noch das Attribut "Class" besetzt werden und muss in dem entsprechenden Tag-Element dann auch übereinstimmen, damit die Gesamtbedingung erfüllt ist. Damit die Bedingung erfüllt ist, reicht es, dass ein Tag am Zielknoten die Bedingung erfüllt. Falls jedoch die Adressierung des Zielknotens nicht eindeutig ist, so muss jeder Zielknoten die Tag-Bedingung wenigstens einmal erfüllen, damit die Gesamtbedingung erfüllt ist.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_463">This element defines the condition of whether, at a specific parent node of the observed offer, the child element "Tag" has a specific value. The element Tags may include a list of tags separated by a space. The condition is fulfilled if one of the tags matches the value of the target node (it can therefore be described as an implicit "OR-connective").
In this situation, the addressed node is defined through an evaluation of the contents of the attributes "Source" and "Location".
Parent nodes are in this sense also logical superordinate nodes which result from the evaluation of the ProductRules and CombinationRules.
Through the provision of the attributes "Offset" and "Length", the comparison of the value of the Tag element is limited to certain characters.
In addition, the attribute "Class" may also be occupied and must then also match in the corresponding Tag element, in order that the overall condition is fulfilled. In order for the condition to be fulfilled, it suffices for a Tag at the target node to fulfil the condition.
If, however, the addressing of the destination node is not unambiguous, every destination node must fulfil the tag condition at least once, in order that the overall condition is fulfilled.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Airports" type="AirportConditionType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_464">Dieses Element definiert die Bedingung, ob der einer Komponente oder Unterkomponente zugeordnete Flughafen mit einem der in dieser Bedingung angegebenen Flughäfen übereinstimmt. Die Bedingung kann eine durch Space getrennte Liste von Airports enthalten. Die Angabe der Airports erfolgt im IATA-Format (IATA Airport-Code bzw. IATA MAA-Code). Die adressierte Ziel-Unterkomponente des gerade betrachteten Angebots wird über den Inhalt des Attributs "Source" abgegeben. Das Attribut "AirportType" gibt an, aus welchem Kind-Element der Unterkomponente der Airport ausgelesen wird. Ist die Adressierung der Ziel-Component mittels Source nicht eindeutig (z.B. wegen eines zusammengesetzten Fluges), gelten folgende Regeln: * AirportType = 'Departure': Überprüfe den DepartureAirport der zeitlich ersten Komponente * AirportType = 'Arrival': Überprüfe den ArrivalAirport der zeitlich letzten Komponente * AirportType = 'Catchment': Überprüfe den CatchmentAirport aller Komponenten. 

Spezialfall: wenn der Code sowohl einen konkreten Flughafen als auch eine Flughafengruppe (MAA - Metropolitan Airport Code) identifiziert, wird nur der konkrete Flughafen berücksichtigt. 

Um die Definition der Airport-Codes seitens IATA zu überprüfen, nutzen Sie bitte den Link: http://www.iata.org/publications/Pages/code-search.aspx

Eine nicht zwingend vollständige und nicht zwingend korrekte Liste der IATA-Airport-Codes finden Sie unter: https://de.wikipedia.org/wiki/Liste_der_IATA-Flughafen-Codes

Eine nicht zwingend vollständige und nicht zwingend korrekte Liste der MAA-Codes finden Sie unter: 
http://wikitravel.org/en/Metropolitan_Area_Airport_Codes</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_464">This element defines the condition in which a component or sub-component of the associated airport matches a specified airport. The condition can consist of a list of airports separated by spaces. The airports are named using the IATA format (IATA airport code or IATA MAA Code). The target sub-component addressed in the offer currently under consideration is submitted with the content of the "Source" attribute. The "Airport Type" attribute specifies which child element of the sub-component the airport is selected from. Where the addressing of the target component via the source attribute is unclear (e.g. in the case of a composite flight) the following rules apply: * AirportType = 'Departure': Check that the DepartureAirport is the first component chronologically * AirportType = 'Arrival': Check that the ArrivalAirport is the final component chronologically * AirportType = 'Catchment': Check the CatchmentAirport is specified for all components.
						
Special case: If the code identifies both, a real airport and a group of airports (MAA - Metropolitan Airport Code), only the real airport is considered. For information about the IATA airport code definition see: http://www.iata.org/publications/Pages/code-search.aspx
					    
You will find a list of the concrete airport codes that is not garanteed to be complete or correct here: https://de.wikipedia.org/wiki/Liste_der_IATA-Flughafen-Codes
					    
You will find a list of the MAA-Codes  that is not garanteed to be complete or correct here: http://wikitravel.org/en/Metropolitan_Area_Airport_Codes
						</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:group name="AtomicPersonImpactConditionGroup">
		<xs:sequence>
			<xs:element name="PersonImpact">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_465">Alle Bedingungen innerhalb dieses Elementes beziehen sich auf die einzelnen Reiseteilnehmer und definieren eine Gültigkeit für jeden dieser Teilnehmer. Preise, die mit einer PersonImpactBedingung verknüpft sind, sind nur für bestimmte Personen gültig und werden dementsprechend nur bestimmten Personen zugewiesen. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_465">All conditions within this element relate to the individual tour participants and define validity criteria for each of them.
Prices, which are linked to a PersonImpactCondition, are valid only for persons matching specific criteria and are assigned accordingly.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice>
						<xs:element name="PersonAge" type="AgeConditionType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_466">Dieses Element definiert die Bedingung an das Alter von einzelnen Personen, für die etwas gültig wird. Es kann ein Mindestalter und ein maximales Alter angegeben werden. Ebenso kann ein Intervall für das Geburtsdatum angegeben werden.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_466">This element defines the condition specifying the age of individuals for whom something is valid. A minimum or a maximum age can be specified. Similarly, an interval can be specified by date of birth.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="PersonIndex" type="PersonIndexConditionType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_467">Dieses Element definiert die Bedingung an eine bestimmte Position einer Person in einer nach Alter absteigend sortierten Rangfolge der Reiseteilnehmer. Die betrachteten Personen können zusätzlich eingeschränkt werden. Positive Indizes beziehen sich auf die ältesten Reiseteilnehmer, negative Indizes in einer dem Alter nach absteigend sortierte Liste, also auf die jüngsten Reiseteilnehmer. Der Index "1" bezieht sich also auf den ältesten, der Index "-1" auf den jüngsten Reiseteilnehmer. Um Teilgruppen aus dem Personenkreis zu adressieren, ergeben sich vier typische Fälle: 1. Die ältesten x Personen: Until=x 2. Die jüngsten x Personen: From=-x Außerdem sind auch Kombinationen von "Until" und "From" und die Definition einer Liste von Indizes, also ein Muster, möglich. Über die integrierte PersonFilter kann die betrachtete Personengruppe zusätzlich eingeschränkt werden.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_467">This element defines the conditions affecting a participant at a particular location, ranking participants in descending order according to age.
Further restrictions can be placed upon the persons under consideration.

Positive indices refer to the oldest passengers, negative indices are sorted in descending order according to age and refer to the youngest participants. Thus index "1" refers to the oldest participant and index "-1" to the youngest participant.
To address sub-groups within the group of participants, there are four typical cases:

1. The x oldest persons: Until=x
2. The x youngest persons: From=-x

Additionally combinations of "Until" and "From" and the definition of a list of indices are also possible.

Using the integrated PersonFilter the group of persons can be further filtered.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="PersonGenders" type="PersonGendersConditionType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_468">Dieses Element definiert eine Bedingung an das Geschlecht. Mögliche Werte sind: - Male - Female -Undefined. Es ist möglich, eine durch Space getrennte Liste von Werten anzugeben. Die Liste definiert ein implizites "Oder" zwischen den Elementen.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_468">This element defines a condition based on the sex of the participant. Possible values are:
- Male
- Female
- Undefined

It is possible to provide a list of values separated by spaces. The list defines an implicit "or" between the elements.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ProductPrice" type="ProductPriceConditionType" internal:otdsversion="1.9"/>
						<xs:element name="GroupedPerson" type="EmptyElementType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_5864">Dieses Element wird nur für GenericAbsolutes benutzt und hat in anderem Kontext keine Auswirkung. Das Element hängt direkt zusammen mit dem Element GroupAbsolutePriceItemsBy/Person und definiert, dass die GenericValues separat auf die Kostenknoten der separat betrachteten Personen aufgeteilt werden. Ist das Element Person innerhalb von GroupAbsolutePriceItemsBy nicht gesetzt, so hat GroupedPerson keine Auswirkung.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_5864">This element is used only for GenericAbsolutes and has no
									effect in a different context. The element is directly related
									to the element GroupAbsolutePriceItemsBy / person and defined
									that the Generic Values are divided on the cost-nodes of the
									separately regarded persons. If the Person element is not set
									within GroupAbsolutePriceItemsBy so GroupedPerson has no
									effect.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
					<xs:attributeGroup ref="ConditionsCombinatoricsAttributGroup"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<xs:group name="AtomicDayImpactConditionGroup">
		<xs:sequence>
			<xs:element name="DayImpact">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_469">Alle Bedingungen innerhalb dieses Elementes beziehen sich auf die einzelnen Tage der Reise und definieren eine Gültigkeit für jeden dieser Tage. Preise, die mit einer DayImpactBedingung verknüpft sind, sind nur für bestimmte Tage der Reise gültig und werden dementsprechend nur bestimmten Tagen zugewiesen. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_469">All conditions within this element relate to each day of the trip and define validity criteria for each of these days.
Prices which are linked to a DayImpactCondition are valid only for certain days of the trip and will be assigned to days accordingly.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice>
						<xs:element name="Date" type="DateConditionType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_509">Einschränkung bzgl. des Datums einzelner Reisetage. Die Bedingung gilt für die Reisetage als erfüllt, die die entsprechenden Terminbedingungen (größer=Min  und  kleiner= Max  und passt zum Attribute "DayType")  erfüllen.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_509">Limitations with respect to the dates of specific travel days. The condition is fulfilled for travel days that meet the applicable date conditions (greater=Min and lower=Max and fits the "DayType" attribute).</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DayIndex" type="DayIndexConditionType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_471">Einschränkung auf bestimmte Tage des Reiseverlaufs. Dieses Element definiert eine Gültigkeit für bestimmte Tage eines Reiseverlaufs. Alle betrachteten Tage werden nach Reiseverlauf sortiert und bekommen dann jeweils einen von 1 aufsteigenden Index. Im Gegenzug werden alle Tage entgegen des Reiseverlaufs sortiert und bekommen einen zweiten Index von 1 aufsteigend, aber mit negativem Vorzeichen. Die Bedingung selbst gibt eine Liste von Indizes bzw. einen Wert "Until" (bis zu) und/oder einen Wert "From" (ab) an, über die die gültigen Tage definiert sind. Über das Attribute "Repeat" können weitere Einstellungen für sich wiederholende Muster von Tagen definiert werden. Positive Indizes adressieren die Tage in zeitlich aufsteigender Reihenfolge. Negative Indizes adressieren die Tage in zeitlich absteigender Form, also zum Beispiel die letzten 3 Tage der Reise.  		Um bestimmte Zeiträume zu adressieren, ergeben sich vier typische Fälle: 1. Die ersten x Tage: Until=x 2. Die letzten x Tage: From=-x 3. Alle Tage nach dem Xten Tag: From=X 4. Alle Tage vor dem x-letzten Tag: Until=-x Außerdem sind dazu noch Kombinationen von "From" und "Until" möglich und die Angabe einer Liste von Indizes. Dazu mehr bei der Beschreibung zum Element "Indices".</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_471">Restrictions on certain days of the itinerary

This element defines a validity for certain days of the itinerary. All days are sorted according to the itinerary and placed in an index starting from 1. All days are again sorted chronologically according to the itinerary and get a second index starting from 1 in ascending order but with a negative sign.

The condition itself is a list of indices or a value "Until" and/or "From", which is used to define the days for which it are valid.
The "Repeat" attribute is used to define further settings for repeating patterns of days. Positive indices address the days according to chronological order by date. Negative indices address the days in reverse order, for instance the last 3 days of the trip.
To address certain periods, there are four typical cases:

1. The first x days: Until=x
2. The last x days: From=-x
3. All days after day X: From=X
4. All days prior to day X: Until=-x

Additionally, combinations of "From" and "Until" can be used as definitions in a list of indices. More details can be found in the description of the "Indices" element.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Weekdays" type="WeekdayConditionType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_510">Einschränkung bzgl. des Wochentages einzelner Tage Dieses Element definiert die Bedingung, ob einzelne Tage der gerade betrachteten Reise eine Bedingung bzgl. der Wochentage erfüllen. Die Bedingung ist für jeden Tag erfüllt der einem der angegeben Wochentage entspricht. Dabei kann über das Attribut "DayType" zusätzlich bestimmt werden, dass nur bestimmte Tage der Reise betrachtet werden sollen (z.B.: nur der Anreisetag oder nur Aufenthaltstage). Bitte beachten: Im Gegensatz zu den anderen Conditions ist an dieser Stelle der Defaultwert="CheckIn" gesetzt. Wird das Attribut "DayType" nicht angegeben ,so wird an dieser Stelle der Wert "CheckIn" benutzt.
									Das Element Weekdays kann eine durch Space getrennte Liste von Wochentagen enthalten. Mögliche Werte sind "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", analog zu den englisch benamten Wochentagen. 
Die Bedingung ist erfüllt, wenn einer der angegebenen Tage die Bedingung erfüllt. Es handelt sich also um eine implizite "OR-Verknüpfung". Über das Attribut "Source" wird die Quelle der betrachteten Reisetage bestimmt (z.B. Termine im Hotel oder während des Fluges). Diese Bedingung überprüft, ob bestimmte Tage einer Reise eine Wochentagsbedingung erfüllen und deshalb ggf. Preise explizit für diese Tage gelten. Die entsprechende Interpretation der Weekday-Condition ohne 	Impact-Anteil ist dementsprechend abweichend - bitte beachten. </xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_510">Restrictions on specific weekdays of
									individual days This element defines the condition whether or
									not individual days of the currently viewed tour meet the
									weekday restriction condition. The condition is met for all days
									that correspond to the weekdays entered. The "DayType" attribute
									can also be used to determine that only certain days of the tour
									should be considered (e.g. only the arrival day or only the days
									of the stay). Please note: In contrast to other conditions, here
									the default value is set to ="CheckIn". If nothing is entered as
									the "DayType" attribute, the value "CheckIn" will be used here.
									The Weekdays element can contain a list of weekdays separated by
									a space. Possible vaules are "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", and "Sun". The condition is fulfilled if one of the days entered
									fulfils the condition. It therefore concerns an implicit "OR
									connective". The "Source" attribute is used to determine the
									source of the travel days currently being viewed (e.g. dates in
									the hotel or during the flight). This condition checks whether
									certain days of a tour meet a weekday condition, and therefore
									also whether prices explicitly apply for these days. The
									corresponding interpretation of the Weekday Condition without
									Impact part changes accordingly - please
									note.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DayPriceIndex" type="DayPriceIndexType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_473">Einschränkung auf bestimmte Tage des Reisverlaufs aufgrund der Preissortierung. Man definiert hier im Allgemeinen die x teuersten Tage (From=-x) und/oder die x billigsten Tage (Until=x) oder Kombinationen von beiden. Diese Condition wird innerhalb von OTDS ausdrücklich ausschließlich auf Dauerreduktionen - also die Verwendung in Verbindung mit 100%-Rabatten - begrenzt. Die Berechnung der Preise ist nur möglich, wenn alle anderen Conditions und auch die Combinatorics bereits ausgewertet wurden. Deshalb ist die DayPriceIndexCondition ausschließlich zusammen mit dem Attribut ImpactExecutionOrder="Last" verwendbar. Umgekehrt ist das ImpactExecutionOrder="Last" auch nur zusammen mit dieser Condition anwendbar.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_473">Restriction on certain days of the travel
									itinerary, due to price sorting. This is generally used to
									define the x most expensive days (From=-x) and/or the x cheapest
									days (Until=x) or combinations of the two. This condition is
									exclusively used within OTDS for long-term discounts, with
									restricted use for 100% discounts. Price calculations are only
									possible after all other conditions and combinations have been
									evaluated. Therefore, the DayPriceIndex condition can be used
									exclusively together with the ImpactExecutionOrder="Last"
									attribute. And vice versa, the ImpactExecutionOrder="Last"
									attribute can only be applied with this
									condition.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ProductPrice" type="ProductPriceConditionType"/>
						<xs:element name="GroupedDay" type="EmptyElementType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_5865">Dieses Element wird nur für GenericAbsolutes benutzt und hat in anderem Kontext keine Auswirkung. Das Element hängt direkt zusammen mit dem Element GroupAbsolutePriceItemsBy/Day und definiert, dass die GenericValues separat auf die Kostenknoten der separat betrachteten Tage aufgeteilt werden. Ist das Element Day innerhalb von GroupAbsolutePriceItemsBy nicht gesetzt, so hat GroupedDay keine Auswirkung.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_5865">This element is used only for GenericAbsolutes and has no
									effect in a different context. The element is directly related
									to the element GroupAbsolutePriceItemsBy / day and defines that
									the Generic Values are divided on the cost-nodes of the
									separately regarded days. If the Day element is not set within
									GroupAbsolutePriceItemsBy so GroupedDay has no
									effect.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
					<xs:attributeGroup ref="ConditionsCombinatoricsAttributGroup"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<xs:group name="AtomicImpactConditionGroup">
		<xs:sequence>
			<xs:element name="Impact">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_474">Alle Bedingungen innerhalb dieses Elementes beziehen sich auf die einzelnen Tage der Reise und definieren eine
Gültigkeit für jeden dieser Tage. Preise, die mit einer DayImpactBedingung verknüpft sind, sind nur für bestimmte Tage der Reise gültig und werden dementsprechend nur bestimmten Tagen zugewiesen. </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_474">All conditions within this element relate to each day of the trip and define validity criteria for each of these days.
Prices that have a DayImpactCondition attached to them are only valid for certain days of the trip and are therefore only applied to the corresponding days.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice>
						<xs:element name="ConditionalTags" type="ConditionalTagConditionType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_475">Dieses Element definiert die Bedingung, ob an einem bestimmten Knoten des betrachteten Angebotes das Kind-Element "ConditionalTag" mit einem bestimmten Tag-Value enthalten ist. Zusätzlich müssen noch die Bedingungen des entsprechenden ConditionalTags erfüllt sein. Das Element ConditionalTags kann eine durch Space getrennte Liste von Tags enthalten. Die Bedingung ist erfüllt, wenn einer der Tags mit dem Wert des Zielknotens übereinstimmt (es handelt sich also um eine implizite "OR-Verknüpfung"). Der adressierte Knoten wird dabei durch Auswertung des Inhaltes der Attribute "Source" und "Location" bestimmt. Elternknoten sind diesbzgl. auch logische übergeordnete Knoten, die sich aus der Auswertung der Product- und CombinationRules ergeben. Durch Angabe der Attribute "Offset" und "Length" wird der Vergleich des Wertes des ConditionalTag-Elementes auf bestimmte Zeichen begrenzt. Zusätzlich kann auch noch das Attribut "Class" besetzt werden und muss in dem entsprechenden ConditionalTag-Element dann auch übereinstimmen, damit die Gesamtbedingung erfüllt ist. Damit die Bedingung erfüllt ist, reicht es, dass ein ConditionalTag am Zielknoten die Bedingung erfüllt. Falls jedoch die Adressierung des Zielknotens nicht eindeutig ist, so muss jeder Zielknoten die Tag-Bedingung wenigstens einmal erfüllen, damit die Gesamtbedingung erfüllt ist. (@ToDo: Siehe auch Thematische Dokumentation Auswertung der ConditionalTags)</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_475">This element defines the condition of
									whether, at a specific node of the observed offer, the child
									element "ConditionalTag" is included with a specific Tag-Value.
									In addition, the conditions of the relevant ConditionalTag must
									be fulfilled. The element ConditionalTags may include a list of
									tags separated by a space. The condition is fulfilled if one of
									the tags matches the value of the target node (it can therefore
									be described as an implicit "OR-connective"). In this situation,
									the addressed node is defined through an evaluation of the
									contents of the attributes "Source" and "Location". Parent nodes
									are in this sense also logically superordinate nodes which
									result from the evaluation of the ProductRules and
									CombinationRules. Through the provision of the attributes
									"Offset" and "Length", the comparison of the value of the
									ConditionalTag element is limited to certain characters. In
									addition, the attribute "Class" may also be occupied and must
									then also match in the corresponding ConditionalTag element, in
									order that the overall condition is fulfilled. In order for the
									condition to be fulfilled, it suffices for a ConditionalTag at
									the target node to fulfil the condition. If, however, the
									addressing of the destination node is not unambiguous, every
									destination node must fulfil the tag condition at least once, in
									order that the overall condition is fulfilled. </xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="GroupedAbsolute" type="EmptyElementType">
							<xs:annotation>
								<xs:documentation xml:lang="de" xml:id="de_5866">Dieses Element wird nur für GenericAbsolutes benutzt und hat in anderem Kontext keine Auswirkung. Das Element hängt direkt zusammen mit dem Element GroupAbsolutePriceItemsBy/AbsolutePriceItem und definiert, dass die GenericValues separat auf die Kostenknoten der separat betrachteten PriceItemGruppen aufgeteilt werden. Ist das Element AbsolutePriceItem innerhalb von GroupAbsolutePriceItemsBy nicht gesetzt, so hat GroupedAbsolute keine Auswirkung.</xs:documentation>
								<xs:documentation xml:lang="en" xml:id="en_5866">This element is used only for GenericAbsolutes and has no
									effect in a different context. The element is directly related
									to the element GroupAbsolutePriceItemsBy/AbsolutePriceItem and
									defines that the Generic Values are divided on the cost-nodes of
									the separately regarded PriceItemGroups. If the
									AbsolutePriceItem element is not set within
									GroupAbsolutePriceItemsBy so GroupedAbsolute has no
									effect.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
					<xs:attributeGroup ref="ConditionsCombinatoricsAttributGroup"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<xs:group name="AtomicDayPriceIndexConditionGroup">
		<xs:sequence>
			<xs:element name="DayImpact">
				<xs:complexType>
					<xs:choice/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<xs:group name="AtomicRulesConditionGroup">
		<xs:choice>
			<xs:element name="MatchEqual" type="MatchType">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_476">Dieses Element definiert die Bedingung, ob mehrere Werte aus unterschiedlichen Tags, Elementen und ggf. jeweils auch aus unterschiedlichen Komponenten übereinstimmen. Die Bedingung ist erfüllt, wenn die Bodies der adressierten Tags oder Elemente übereinstimmen. Bei Tags können auch nur Teilbereiche des Bodies über entsprechende Besetzung der Attribute betrachtet werden. Die Adressierung der Knoten erfolgt jeweils über das Attribut "Source" und bei Tag zusätzlich "Location".</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_476">This element defines the condition as to whether several values from different tags, elements and in some cases from different components all match up. This condition is fulfilled if the bodies of the addressed tags or elements are the same. For tags, just parts of the bodies can be checked to see if they possess common attributes.

Nodes are to be addressed using the "Source" attribute, and for tags also via "Location".</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Compare" type="CompareType" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_388">Dieses Element definiert die Bedingung, ob Werte aus mehreren definierten Wertemengen bzgl. einer definierten Vergleichsoperation übereinstimmen.
Die Vergleichoperation wird mit dem Attribut @Operation festgelegt. Das Compare-Element beinhaltet mehrere Unterelemente in einer definierten Reihenfolge. Jedes dieser Unterelemente referenziert eine Menge von Werten.
Die Compare-Bedingung ist erfüllt, wenn jede dieser Value-Mengen wenigstens ein Element enthält, welche(s) die unter Compare/@Operation angegebene Vergleichoperation bzgl. der Nachbar-Wertemenge(n) erfüllt.
In der Regel sind hier alle betrachteten Value-Types vom Typ "String". Lediglich die Tags und ConditionalTags können explizit noch spezifische ValueTypes wie "Numeric" oder "Price" ausprägen. 

Der größer/kleiner Vergleich ergibt beim Vergleich unterschiedlicher ValueTypes das Ergebnis "False".

Der String-Vergleich folgt der lexikalischen Standard-Sortierung in OTDS, deren aufsteigende Reihenfolge  wie folgt definiert ist:

Zeichenketten werden grundsätzlich mit dem linken Zeichen beginnend	Zeichen für Zeichen sortiert, wobei das erste Zeichen die höchste Priorität besitzt. Die Sortierung folgt den ASCII-Values der Zeichen und entspricht damit folgender aufsteigenden Liste: 
-
.
0
1
2
3 
usw.
A
B
C 
usw.
_ 
a 
b
c 
usw.
|
~ </xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_388">This element defines the condition, if values from several value sets match each other with respect to a defined comparison operation. The comparison operation is defined with the attribute @Operation. The compare element contains several sub-elements in a defined order. Each of these sub-elements references a number of values.
The compare condition is fulfilled, if each of those value sets contains at least one or more elements which fulfill(s) the comparison operation regarding the neighbouring value set(s) indicated under Compare/@Operation.
In general all viewed value types generate from the type "String". Only the Tags and ConditionalTags can explicitly form specific ValueTypes such as "Numeric" or "Price". 

The comparison "greater/less" results in "False" if different ValueTypes are compared.

The String comparison follows the lexical standard sorting of OTDS, which ascending order is defined as follows:

Character strings are sorted character by character, starting with the character on the left. The first character has the highest priority. The sorting follows the ASCII-Values of the characters and thus complies to the following ascending list: 
-
.
0
1
2
3 
etc.
A
B
C 
etc.
_ 
a 
b
c 
etc.
|
~ </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- Begin of General condition type-->
	<xs:group name="ConditionGroup">
		<xs:choice>
			<xs:group ref="AtomicBaseConditionGroup"/>
			<xs:group ref="AtomicGenericTagConditionGroup"/>
			<xs:group ref="AtomicComponentConditionGroup"/>
			<xs:group ref="AtomicPersonImpactConditionGroup"/>
			<xs:group ref="AtomicDayImpactConditionGroup"/>
			<xs:group ref="AtomicImpactConditionGroup"/>
			<xs:group ref="AtomicRulesConditionGroup"/>
			<xs:group ref="AtomicProductPriceConditionGroup"/>
			<xs:group ref="AtomicCountConditionGroup"/>
			<xs:group ref="AtomicAvailabilityConditionGroup"/>
			<xs:element name="And">
				<xs:complexType>
					<xs:group ref="ConditionGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Or">
				<xs:complexType>
					<xs:group ref="ConditionGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Not">
				<xs:complexType>
					<xs:group ref="ConditionGroup"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Imply">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="If">
							<xs:complexType>
								<xs:group ref="ConditionGroup"/>
							</xs:complexType>
						</xs:element>
						<xs:element name="Then">
							<xs:complexType>
								<xs:group ref="ConditionGroup"/>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="NonImpact" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5867">Mit dem NonImpact Wrapper kann man ausdrücken, dass eine komplexe Bedingung, die auch ImpactBedingungen enthält am Ende doch als NICHT-Impact ausgewertet wird. 
Zum Beispiel die Bedingung, dass ein Preis gilt, wenn ein Freitag mit einer Saison A enthalten ist. Das ist erreichbar, indem man zwei ImpactBedingungen verundet und diese dann mit dem NonImpact-Wrapper umschließt.
Der NonImpact-Wrapper kann auch dabei helfen, wenn man kombinierte CheckIn- und StaySeasons mit nur einem ConditionalTag ausdrücken will.
Dabei kann mit den Elementen DayBase und PersonBase definiert werden, welche Kostenknoten überhaupt bei der Auswertung berücksichtigt werden.
Das Attribut "EvaluationMode" definiert, ob ein Kostenknoten die Bedingung erfüllen muss oder ob es alle erfüllen müssen.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5867">The NonImpact Wrapper allows to express that a complex condition, which might also contain ImpactConditions after all will be interpreted as a NON-Impact. 
						For example: a price is valid, if a Friday with a Season A is included. This can be realised by connecting two ImpactConditions with AND and enclosing those with the NonImpact-Wrapper.
						The NonImpact-Wrapper can also help to express combined CheckIn- and StaySeasons with only one ConditionalTag.
						Here the elements DayBase and PersonBase allow to define, which cost nodes need to be considered in the interpretation.
						The attribute "EvaluationMode" defines if a cost node has to fulfill the condition or if all have to fulfill it.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:group ref="AllocationBaseConditionGroup"/>
						<xs:element name="Condition" type="ConditionType"/>
					</xs:sequence>
					<xs:attribute name="EvaluationMode" type="EvaluationModeEnum" default="Any">
						<xs:annotation>
							<xs:documentation xml:lang="de" xml:id="de_5868">Mit diesem Attribut definiert man, ob die NonImpact Bedingung erfüllt ist, wenn ein beliebiger ("Any") Kostenknoten die Condition erfüllt oder wenn alle ("All") durch DayBase und PersonBase definierten Kostenknoten die Condition erfüllen.</xs:documentation>
							<xs:documentation xml:lang="en" xml:id="en_5868">This attribute helps to define, if a NonImpact Condition is fulfilled when a random ("Any") cost node fulfills the condition or when all ("All") cost nodes which are defined by DayBase and PersonBase fulfill the Condition.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:group name="PersonFilterConditionGroup">
		<xs:choice>
			<xs:group ref="AtomicPersonImpactConditionGroup"/>
			<xs:group ref="AtomicImpactConditionGroup"/>
			<xs:element name="And">
				<xs:complexType>
					<xs:group ref="PersonFilterConditionGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Or">
				<xs:complexType>
					<xs:group ref="PersonFilterConditionGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:group name="DayFilterConditionGroup">
		<xs:choice>
			<xs:group ref="AtomicDayImpactConditionGroup"/>
			<xs:group ref="AtomicImpactConditionGroup"/>
			<xs:element name="And">
				<xs:complexType>
					<xs:group ref="DayFilterConditionGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Or">
				<xs:complexType>
					<xs:group ref="DayFilterConditionGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:complexType name="ConditionType">
		<xs:group ref="ConditionGroup"/>
	</xs:complexType>
	<xs:complexType name="DayFilterConditionType">
		<xs:group ref="DayFilterConditionGroup"/>
	</xs:complexType>
	<xs:complexType name="PersonFilterConditionType">
		<xs:group ref="PersonFilterConditionGroup"/>
	</xs:complexType>
	<xs:complexType name="GenericTagConditionType">
		<xs:attribute name="Class" type="TokenType" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_4958">Mit diesem Attribut kann man das Tag weiter spezifizieren, auf dessen Knoten sich der Inhalt bezieht.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_4958">With this attribute, it is possible to further specify the tag, the node of which the contents refer to.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ConditionSimpleNodeType">
		<xs:complexContent>
			<xs:extension base="SimpleUpdateNodeType">
				<xs:group ref="ConditionGroup"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FilterSimpleNodeType">
		<xs:complexContent>
			<xs:extension base="OptionalMultipleSimpleUpdateNodeType">
				<xs:group ref="ConditionGroup"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Begin of Combination condition type-->
	<xs:group name="CombinationConditionGroup">
		<xs:choice>
			<xs:group ref="AtomicBaseConditionGroup"/>
			<xs:group ref="AtomicComponentConditionGroup"/>
			<xs:group ref="AtomicPersonImpactConditionGroup"/>
			<xs:group ref="AtomicDayImpactConditionGroup"/>
			<xs:element name="And">
				<xs:complexType>
					<xs:group ref="CombinationConditionGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Or">
				<xs:complexType>
					<xs:group ref="CombinationConditionGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Not">
				<xs:complexType>
					<xs:group ref="CombinationConditionGroup"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Imply">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="If">
							<xs:complexType>
								<xs:group ref="CombinationConditionGroup"/>
							</xs:complexType>
						</xs:element>
						<xs:element name="Then">
							<xs:complexType>
								<xs:group ref="CombinationConditionGroup"/>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- Begin of Pricecondition type-->
	<xs:group name="DayPriceIndexConditionGroup">
		<xs:choice>
			<xs:group ref="AtomicDayPriceIndexConditionGroup"/>
			<xs:element name="And">
				<xs:complexType>
					<xs:group ref="DayPriceIndexConditionGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Or">
				<xs:complexType>
					<xs:group ref="DayPriceIndexConditionGroup" minOccurs="1" maxOccurs="unbounded"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Not">
				<xs:complexType>
					<xs:group ref="DayPriceIndexConditionGroup"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Imply">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="If">
							<xs:complexType>
								<xs:group ref="DayPriceIndexConditionGroup"/>
							</xs:complexType>
						</xs:element>
						<xs:element name="Then">
							<xs:complexType>
								<xs:group ref="DayPriceIndexConditionGroup"/>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:simpleType name="DistanceLocationEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Beach"/>
			<xs:enumeration value="CityCenter"/>
			<xs:enumeration value="Shopping"/>
			<xs:enumeration value="Airport"/>
			<xs:enumeration value="PublicTransport"/>
			<xs:enumeration value="SkiLift"/>
			<xs:enumeration value="GolfCourse"/>
			<xs:enumeration value="Lake"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="FigureFacilitiesEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="AmountBedrooms"/>
			<xs:enumeration value="UnitSize"/>
			<xs:enumeration value="AmountRooms"/>
			<xs:enumeration value="AmountFloors"/>
			<xs:enumeration value="AmountBathrooms"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="UnitBedTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Single"/>
			<xs:enumeration value="SingleExtraLong"/>
			<xs:enumeration value="KingSingle"/>
			<xs:enumeration value="DoubleSize"/>
			<xs:enumeration value="QueenSize"/>
			<xs:enumeration value="KingSize"/>
			<xs:enumeration value="SofaBed"/>
			<xs:enumeration value="SinglePullDownBed"/>
			<xs:enumeration value="DoublePullDownBed"/>
			<xs:enumeration value="BunkBed"/>
			<xs:enumeration value="CotBed"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="MandatoryServicePaidAtLocationEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="FinalCleanUp"/>
			<xs:enumeration value="VisitorsTax"/>
			<xs:enumeration value="BedLinen"/>
			<xs:enumeration value="Parking"/>
			<xs:enumeration value="CookService"/>
			<xs:enumeration value="LaundryService"/>
			<xs:enumeration value="RollService"/>
			<xs:enumeration value="CleaningService"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="BaggageTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Cabin"/>
			<xs:enumeration value="Checked"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="FloatWithUnitType">
		<xs:simpleContent>
			<xs:extension base="xs:float">
				<xs:attribute name="Unit" type="xs:string">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_481">Definiert die Einheit zu dem gelieferten Wert.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_481">Defines the unit to the provided value.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:group name="AtomicProductPriceConditionGroup">
		<xs:sequence>
			<xs:element name="ProductPrice" type="ProductPriceConditionType" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_482">Einschränkung bzgl. des Preises des Gesamtangebots oder einzelner Personen. Für die Auswertung der ProductPrice Condition ist es notwendig, dass die Komponente, welche die ProductPrice Condition enthält, zusammen mit einer ProductComponent in der Produktdefintion definiert ist. Eine ProductPrice Condition bezieht sich immer auf den Gesamtpreis eines Produktes. Der Gesamtpreis kann aber je Teilnehmer durch das Attribut ConsiderationBase betrachtet werden.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_482">Limitation of the price of the total offer or for individual persons. For the evaluation of the ProductPrice Condition, it is necessary that the components which the ProductPrice Condition contains are defined together with a ProductComponent in the Productdefinition. A ProductPrice Condition always refers to the total price of a product. The total price can however be regarded per participant through the attribute ConsiderationBase.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<xs:group name="AtomicCountConditionGroup">
		<xs:choice>
			<xs:element name="DayCount" type="DayCountConditionType" internal:otdsversion="1.9"/>
			<xs:element name="PersonCount" type="PersonCountConditionType" internal:otdsversion="1.9"/>
		</xs:choice>
	</xs:group>
	<xs:group name="AtomicAvailabilityConditionGroup">
		<xs:choice>
			<xs:element name="AvailabilityState" type="AvailabilityConditionType" internal:otdsversion="2.0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_3277">Mit dieser Bedingung lässt sich die allgemeine Auswertung der Availabilities weiter einschränken. Diese Bedingung ist erfüllt, wenn der AvailabilityStatus der durch @Component adressierten Hauptkomponentensinstanz nach der Auswertung der Availabilities einen der aufgeführten ValidState/@State als Komponentenstatus besitzt. 
Bis zur Auswertung der Availabilities gilt diese Bedingung als undefined und wird dementsprechend erst nach der Auswertung der Availabilities explizit nach OTDS-Vorschrift ausgewertet. 
Die AvailabiltyState-Bedingung wird nur in den Filtern auf Product und DefineComponent-Ebene ausgewertet. In allen anderen Positionen bleibt die Auswertung der Bedingung = "undefined".</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_3277">With the condition the general evaluation of the availabilities can be further restricted. The condition is fulfilled, if the AvailabilityState of the main component instance addressed by @Component after the evaluation of the availabilities has one of the ValidState/@State indicated as component state. 
Until the evaluation of the availabilities this condition is considered undefined. Hence it is only evaluated after the evaluation of the availabilities, and follows explicitly the OTDS regulation.
The AvailabiltyState condition is evaluated only in filters on Product and DefineComponent level. In all other positions the evaluation of the condition = "undefined".</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:group name="AtomicGenericTagConditionGroup">
		<xs:sequence>
			<xs:element name="GenericTag" internal:otdsversion="1.9">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5869">Die GenericTag-Condition definiert eine Bedingung an das GenericTag. Das Attribut "Class" referenziert, welches GenericTag geprüft wird. Die Bedingung ist erfüllt, wenn der Value des referenzierten GenericTags innerhalb der Value-Bedingungen liegt. Eine GenericTag Bedingung ohne Value ist "False".
Die Auswertung der GenericTag-Bedingung erfolgt nur in Product- und DefinedComponent-Filtern. In allen anderen Conditions und Filtern werden GenericTag-Bedingungen als "False" ausgewertet.
Die Auswertung der GenericTag-Bedingung erfolgt nach dem letzten Step der Preisberechnung, also nach ExecutionOrder ="Last".
Bis dahin ist die GenericTag-Bedingung als "undefined" zu bewerten.  
Der Umgang mit "undefined" Bedingungen wird in der Dokumentation beschrieben. (Suchen Sie dazu bitte nach "undefined")</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5869">The GenericTag-Condition defines a condition for the GenericTag. The attribute "Class" references, which GenericTag is to be evaluated. The condition is fulfilled, if the value of the referenced GenericTag lies within the Value-conditions. A GenericTag condition without Value is interpreted as "False".
					The evaluation of the GenericTag condition only takes place in Product. and DefinedComponent filters. In all other conditions and filters the GenericTag conditions are nterpreted as "False".
The evaluation of the GenericTag condition takes place after the last step of the price calculation, that is after ExecutionOrder="Last". Until then the GenericTag condition has to be rated as "undefined". How to deal with "undefined" conditions is described in the documentation (please search for "undefined").</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="GenericTagConditionType">
							<xs:choice>
								<xs:element name="Value" type="GenericTagValueType"/>
								<xs:sequence>
									<xs:element name="MinValue" type="xs:int" minOccurs="0"/>
									<xs:element name="MaxValue" type="xs:int" minOccurs="0"/>
								</xs:sequence>
							</xs:choice>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<xs:simpleType name="ConsiderationBaseEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Total"/>
			<xs:enumeration value="Person"/>
			<xs:enumeration value="Day"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ProductPriceConditionType">
		<xs:choice>
			<xs:sequence>
				<xs:element name="Min" type="xs:decimal" minOccurs="1">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_483">Dieses Element definiert den kleinsten Preis, also die Untergrenze einer Preisspanne.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_483">This element defines the lowest price, i.e. the lower limit of a price range.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="Max" type="xs:decimal" minOccurs="0">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_484">Dieses Element definiert den höchsten Preis, also die Obergrenze einer Preisspanne.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_484">This element defines the highest price, i.e. the upper limit of a price range.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:sequence>
				<xs:element name="Max" type="xs:decimal" minOccurs="1">
					<xs:annotation>
						<xs:documentation xml:lang="de" xml:id="de_489">Dieses Element definiert den höchsten Preis, also die Obergrenze einer Preisspanne.</xs:documentation>
						<xs:documentation xml:lang="en" xml:id="en_489">This element defines the highest price, i.e. the upper limit of a price range.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:element name="Prices" minOccurs="1">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_485">In diesem Element kann eine Liste von Preisen oder ein Preis angegeben werden. Wenn der betrachtete Preis mit einem der Preise aus der Liste übereinstimmtm, ist die Bedingung erfüllt. Die Preise in der Liste sind durch "Leerzeichen" getrennt.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_485">In this element, a list of prices or one price can be specified. If the displayed price matches one of the prices on the list, the condition is fulfilled. The prices in the list are separated by "spaces".</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="xs:decimal"/>
				</xs:simpleType>
			</xs:element>
		</xs:choice>
		<xs:attribute name="ConsiderationBase" type="ConsiderationBaseEnum" default="Total">
			<xs:annotation>
				<xs:documentation xml:lang="de" xml:id="de_486">Die ConsiderationBase definiert, ob für die Ermittlung des Preises der Gesamtpreis (ConsiderationBase = "Total") oder der Preis der gerade betrachteten Person (ConsiderationBase = "Person") herangezogen werden soll.</xs:documentation>
				<xs:documentation xml:lang="en" xml:id="en_486">The ConsiderationBase defines whether the total price (ConsiderationBase = "Total") or the price of the currently viewed person (ConsiderationBase = "Person") should be considered for the determination of the price.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="CarRentalPropertiesType">
		<xs:sequence>
			<xs:element name="CarRentalStationType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5870">Art der Mietwagenstation</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5870">Type of car rental station</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="CarRentalStationTypeEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="CarRentalProductOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5871">Zusätzliche Optionen, die zu einem Mietwagen hinzugebucht werden können oder
						bereits enthalten sind.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5871">Additional services that can be added to a rental car booking or that are already included.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="CarRentalProductOptionsEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="CarFacilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5872">Ausstattungsmerkmale</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5872">Rental car features</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:list itemType="CarRentalFacilityEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="CarInsurance" type="CarRentalInsuranceType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5873">Das Element Insurance kann mehrfach geliefert werden und beinhaltet die Art
						der Versicherung, eine Beschreibung, die Deckungssumme und die Selbstbeteiligung.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5873">The item Insurance can be supplied multiple times and includes the type of insurance, a description, the coverage, and the deductible.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CarCapacity" type="CarCapacityType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5874">Angaben zum Fassungsvermögen des Mietwagens. Dieses Fassungsvermögen ersetzt nicht die Occupancy. Das Fassungsvermögen liefert nur Informationen über die maximale empfohlene Anzahl von Personen und Gepäck.</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5874">Information on the capacity of the rental car. This capacity does not replace the occupancy. The capacity provides information only about the maximum recommended number of passengers and luggage.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CarRentalInsuranceType">
		<xs:sequence>
			<xs:element name="Insurance" type="CarRentalInsuranceEnum">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5875">Versicherungsart</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5875">Type of insurance</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Description" type="LanguageTextType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5876">Beschreibung der Versicherung</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5876">Description of insurance</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AmountOfCover" type="xs:decimal" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5877">Die Schadenssumme, welche durch die Versicherung abgedeckt wird</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5877">The damage sum which is covered by the insurance</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Excess" type="xs:decimal" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5878">Höhe der Selbstbeteiligung im Falle eines Schadens</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5878">Amount of the deductible in case of damage</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CarCapacityType">
		<xs:sequence>
			<xs:element name="Passengers" type="xs:positiveInteger" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5879">Maximale Anzahl an Personen</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5879">Max. number of passengers</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Bags" type="xs:unsignedInt" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="de" xml:id="de_5880">Maximale Anzahl an Gepäckstücken</xs:documentation>
					<xs:documentation xml:lang="en" xml:id="en_5880">Max. number of baggage</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
</xs:schema>
